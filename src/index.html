<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TodoManager - Manage Your Tasks Efficiently</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #F5F5F5 0%, #E8E8E8 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
            overflow-x: hidden;
        }

        .container {
            max-width: 600px;
            width: 100%;
            text-align: center;
            animation: fadeIn 0.6s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .logo-container {
            margin-bottom: 48px;
            animation: slideDown 0.8s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .logo {
            width: 120px;
            height: 120px;
            margin: 0 auto 24px;
            filter: drop-shadow(0 4px 12px rgba(255, 184, 0, 0.3));
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        .logo:hover {
            animation: float 3s ease-in-out infinite, pulse 0.6s ease;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        h1 {
            font-size: 48px;
            font-weight: 700;
            color: #1F1F1F;
            margin-bottom: 16px;
            letter-spacing: -1px;
        }

        .tagline {
            font-size: 18px;
            color: #6C757D;
            margin-bottom: 64px;
            font-weight: 400;
        }

        .options-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-bottom: 32px;
        }

        .option-card {
            background: white;
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid transparent;
            animation: slideUp 0.6s ease;
            animation-fill-mode: both;
        }

        .option-card:nth-child(1) {
            animation-delay: 0.2s;
        }

        .option-card:nth-child(2) {
            animation-delay: 0.3s;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .option-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            border-color: #FFB800;
        }

        .option-card:active {
            transform: translateY(-2px) scale(1.01);
        }

        .option-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            background: linear-gradient(135deg, #FFB800 0%, #FFA000 100%);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .option-card:hover .option-icon {
            transform: rotate(5deg) scale(1.1);
            box-shadow: 0 4px 16px rgba(255, 184, 0, 0.4);
        }

        .option-icon svg {
            width: 36px;
            height: 36px;
            color: #1F1F1F;
        }

        .option-title {
            font-size: 24px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 8px;
        }

        .option-description {
            font-size: 14px;
            color: #6C757D;
            line-height: 1.5;
        }

        .footer {
            margin-top: 48px;
            font-size: 14px;
            color: #ADB5BD;
            animation: fadeIn 0.8s ease 0.5s both;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 36px;
            }

            .tagline {
                font-size: 16px;
                margin-bottom: 48px;
            }

            .logo {
                width: 100px;
                height: 100px;
            }

            .option-card {
                padding: 24px;
            }

            .option-title {
                font-size: 20px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Page visibility */
        .hidden {
            display: none !important;
        }

        .page {
            min-height: 100vh;
            width: 100%;
        }

        /* Header styles */
        .header {
            height: 60px;
            background: #FFFFFF;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 24px;
        }

        .header-title {
            font-size: 16px;
            font-weight: 500;
            color: #1F1F1F;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: 4px;
        }

        .tab-btn {
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            color: #6C757D;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tab-btn:hover {
            color: #1F1F1F;
            background: #F8F9FA;
        }

        .tab-btn.active {
            color: #1F1F1F;
            background: #FFB800;
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .icon-button {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }

        .icon-button:hover {
            background: #F8F9FA;
        }

        .icon-button:active {
            transform: scale(0.95);
        }

        .icon-button svg {
            width: 24px;
            height: 24px;
            color: #6C757D;
            transition: color 0.2s ease, transform 0.3s ease;
        }

        .icon-button:hover svg {
            color: #1F1F1F;
        }

        /* Settings icon rotation on hover */
        .icon-button[title="Settings"]:hover svg {
            transform: rotate(90deg);
        }

        /* Main content area */
        .main-content {
            padding-top: 84px;
            padding-left: 24px;
            padding-right: 24px;
            padding-bottom: 24px;
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Todo list styles */
        .todo-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .todo-item {
            background: #FFFFFF;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s ease;
        }

        .todo-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translateY(-2px);
        }

        .todo-checkbox {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #E0E0E0;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.2s ease;
        }

        .todo-checkbox.checked {
            background: #00A86B;
            border-color: #00A86B;
        }

        .todo-content {
            flex: 1;
        }

        .todo-title {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
        }

        /* Empty state styles */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 64px 24px;
            animation: fadeIn 0.5s ease;
        }

        .empty-icon {
            width: 64px;
            height: 64px;
            color: #ADB5BD;
            margin-bottom: 16px;
        }

        .empty-text {
            font-size: 16px;
            font-weight: 500;
            color: #ADB5BD;
        }

        /* Keyboard shortcut hint text */
        .shortcut-hint {
            font-size: 13px;
            font-style: italic;
            color: #ADB5BD;
            margin-top: 12px;
        }

        .shortcut-hint-floating {
            font-size: 12px;
            font-style: italic;
            color: #ADB5BD;
            text-align: center;
            padding: 8px 0;
            margin-bottom: 8px;
        }

        /* Home page body override */
        #home-page {
            background: #F5F5F5;
        }

        /* Responsive styles for home page */
        @media (max-width: 768px) {
            .header {
                padding: 0 16px;
            }

            .main-content {
                padding-left: 16px;
                padding-right: 16px;
            }
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            position: relative;
            background: #FFFFFF;
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 480px;
            max-height: calc(100vh - 48px);
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            animation: modalSlideIn 0.3s ease;
            transform-origin: center center;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 24px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 8px;
        }

        .form-label .required {
            color: #DC3545;
        }

        .form-input {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .form-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .form-input::placeholder {
            color: #ADB5BD;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 24px;
        }

        .btn {
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .btn-primary {
            background: #FFB800;
            color: #1F1F1F;
        }

        .btn-primary:hover {
            background: #E5A600;
            transform: scale(1.02);
        }

        .btn-secondary {
            background: #F8F9FA;
            color: #6C757D;
        }

        .btn-secondary:hover {
            background: #E9ECEF;
        }

        /* Todo item with due date */
        .todo-due-date {
            font-size: 12px;
            color: #6C757D;
            margin-top: 4px;
        }

        .todo-due-date.overdue {
            color: #DC3545;
        }

        .todo-item.completed .todo-title {
            text-decoration: line-through;
            color: #ADB5BD;
        }

        /* Checkmark icon inside checkbox */
        .todo-checkbox.checked::after {
            content: '';
            display: block;
            width: 8px;
            height: 5px;
            border-left: 2px solid #FFFFFF;
            border-bottom: 2px solid #FFFFFF;
            transform: rotate(-45deg);
            margin: 6px auto;
        }

        /* Todo actions (edit button) */
        .todo-actions {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: auto;
        }

        .todo-edit-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
            flex-shrink: 0;
        }

        .todo-edit-btn:hover {
            background: #F0F0F0;
        }

        .todo-edit-btn svg {
            width: 18px;
            height: 18px;
            color: #6C757D;
            transition: color 0.2s ease;
        }

        .todo-edit-btn:hover svg {
            color: #1F1F1F;
        }

        /* Modal responsive */
        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                padding: 20px;
            }

            .modal-actions {
                flex-direction: column-reverse;
            }

            .btn {
                width: 100%;
            }
        }

        /* Opportunity list styles */
        .opportunity-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .opportunity-item {
            background: #FFFFFF;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            align-items: center;
            gap: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .opportunity-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translateY(-2px);
        }

        .opportunity-content {
            flex: 1;
            min-width: 0;
        }

        .opportunity-name {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 4px;
        }

        .opportunity-contact {
            font-size: 12px;
            color: #6C757D;
        }

        /* Status badges */
        .status-badge {
            padding: 4px 12px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 16px;
            white-space: nowrap;
        }

        .status-requested {
            background: #E3F2FD;
            color: #1976D2;
        }

        .status-open {
            background: #E8F5E9;
            color: #388E3C;
        }

        .status-paused {
            background: #FFF3E0;
            color: #F57C00;
        }

        .status-cancelled {
            background: #FFEBEE;
            color: #D32F2F;
        }

        .status-closed {
            background: #F3E5F5;
            color: #7B1FA2;
        }

        /* Side Panel */
        .side-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 400px;
            max-width: 100%;
            height: 100vh;
            background: #FFFFFF;
            box-shadow: -4px 0 24px rgba(0, 0, 0, 0.15);
            z-index: 200;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .side-panel.open {
            transform: translateX(0);
        }

        .side-panel-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 199;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .side-panel-backdrop.open {
            opacity: 1;
            visibility: visible;
        }

        .side-panel-header {
            padding: 20px 24px;
            border-bottom: 1px solid #E0E0E0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .side-panel-title {
            font-size: 18px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .side-panel-close {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }

        .side-panel-close:hover {
            background: #F8F9FA;
        }

        .side-panel-close svg {
            width: 20px;
            height: 20px;
            color: #6C757D;
        }

        .side-panel-body {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
        }

        .detail-group {
            margin-bottom: 20px;
        }

        .detail-label {
            font-size: 12px;
            font-weight: 500;
            color: #6C757D;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .detail-value {
            font-size: 14px;
            color: #1F1F1F;
        }

        .detail-select {
            width: 100%;
            height: 40px;
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            cursor: pointer;
            transition: border-color 0.2s ease;
        }

        .detail-select:focus {
            outline: none;
            border-color: #FFB800;
        }

        /* Responsive side panel */
        @media (max-width: 768px) {
            .side-panel {
                width: 100%;
            }
        }

        /* Autocomplete styles */
        .autocomplete-wrapper {
            position: relative;
        }

        .autocomplete-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .autocomplete-input {
            width: 100%;
            height: 48px;
            padding: 12px 40px 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .autocomplete-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .autocomplete-input::placeholder {
            color: #ADB5BD;
        }

        .autocomplete-clear {
            position: absolute;
            right: 12px;
            width: 20px;
            height: 20px;
            border: none;
            background: #E0E0E0;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease, background-color 0.2s ease;
        }

        .autocomplete-clear.visible {
            opacity: 1;
        }

        .autocomplete-clear:hover {
            background: #D0D0D0;
        }

        .autocomplete-clear svg {
            width: 12px;
            height: 12px;
            color: #6C757D;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 4px;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-height: 200px;
            overflow-y: auto;
            z-index: 10;
            display: none;
        }

        .autocomplete-dropdown.open {
            display: block;
        }

        .autocomplete-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.15s ease;
            font-size: 14px;
            color: #1F1F1F;
        }

        .autocomplete-item:hover,
        .autocomplete-item.highlighted {
            background: #F8F9FA;
        }

        .autocomplete-item-name {
            font-weight: 500;
        }

        .autocomplete-item-contact {
            font-size: 12px;
            color: #6C757D;
            margin-top: 2px;
        }

        .autocomplete-empty {
            padding: 12px 16px;
            font-size: 14px;
            color: #6C757D;
            font-style: italic;
        }

        .autocomplete-create-hint {
            padding: 8px 16px;
            font-size: 12px;
            color: #6C757D;
            background: #F8F9FA;
            border-top: 1px solid #E0E0E0;
        }

        /* Inline opportunity creation form */
        .inline-opp-form {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
            background: #F8F9FA;
            border-radius: 8px;
            margin-top: 0;
            padding: 0 16px;
        }

        .inline-opp-form.open {
            max-height: 300px;
            padding: 16px;
            margin-top: 12px;
        }

        .inline-opp-form .form-group {
            margin-bottom: 12px;
        }

        .inline-opp-form .form-group:last-child {
            margin-bottom: 0;
        }

        .inline-opp-form .form-label {
            font-size: 12px;
            margin-bottom: 4px;
        }

        .inline-opp-form .form-input {
            height: 40px;
            padding: 8px 12px;
            font-size: 13px;
        }

        .inline-opp-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .inline-opp-title {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .inline-opp-actions {
            display: flex;
            gap: 8px;
        }

        .inline-opp-actions .btn {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Todo opportunity badge */
        .todo-opportunity {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 500;
            color: #1976D2;
            background: #E3F2FD;
            border-radius: 12px;
            margin-top: 4px;
        }

        .todo-opportunity svg {
            width: 12px;
            height: 12px;
        }

        /* Opportunity action buttons */
        .opportunity-actions {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: 8px;
        }

        .opp-action-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease, opacity 0.2s ease;
            flex-shrink: 0;
        }

        .opp-action-btn:hover:not(:disabled) {
            background: #F0F0F0;
        }

        .opp-action-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .opp-action-btn svg {
            width: 18px;
            height: 18px;
            color: #6C757D;
            transition: color 0.2s ease;
        }

        .opp-action-btn:hover:not(:disabled) svg {
            color: #1F1F1F;
        }

        .opp-action-btn.close-btn:hover:not(:disabled) svg {
            color: #7B1FA2;
        }

        .opp-action-btn.delete-btn:hover:not(:disabled) svg {
            color: #D32F2F;
        }

        .opp-action-btn.cancel-btn:hover:not(:disabled) svg {
            color: #F57C00;
        }

        .opp-action-btn.archive-btn:hover:not(:disabled) svg {
            color: #5C6BC0;
        }

        /* Archived opportunity styling */
        .opportunity-item.archived {
            opacity: 0.6;
        }

        .opportunity-item.archived .opportunity-name {
            text-decoration: line-through;
        }

        /* Show Archived Toggle */
        .archive-toggle-container {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            margin-bottom: 16px;
            padding-right: 8px;
        }

        .archive-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 13px;
            color: #6C757D;
            user-select: none;
        }

        .archive-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #FFB800;
            cursor: pointer;
        }

        .archive-toggle:hover {
            color: #1F1F1F;
        }

        /* Confirmation modal */
        .confirm-modal-content {
            text-align: center;
        }

        .confirm-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            color: #D32F2F;
        }

        .confirm-title {
            font-size: 20px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 12px;
        }

        .confirm-message {
            font-size: 14px;
            color: #6C757D;
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .confirm-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .btn-danger {
            background: #D32F2F;
            color: #FFFFFF;
        }

        .btn-danger:hover {
            background: #B71C1C;
        }

        /* Comments section in side panel */
        .comments-section {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid #E0E0E0;
        }

        .comments-header {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 16px;
        }

        .comments-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .comment-item {
            padding: 12px;
            background: #F8F9FA;
            border-radius: 8px;
            border-left: 3px solid #E0E0E0;
        }

        .comment-item.cancellation {
            background: #FFF5F5;
            border-left-color: #D32F2F;
        }

        .comment-timestamp {
            font-size: 11px;
            color: #6C757D;
            margin-bottom: 4px;
        }

        .comment-item.cancellation .comment-timestamp {
            color: #D32F2F;
        }

        .comment-text {
            font-size: 13px;
            color: #1F1F1F;
            line-height: 1.5;
        }

        .comment-item.cancellation .comment-text {
            color: #B71C1C;
        }

        .comment-badge {
            display: inline-block;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
        }

        .comment-badge.cancellation {
            background: #FFEBEE;
            color: #D32F2F;
        }

        .no-comments {
            font-size: 13px;
            color: #ADB5BD;
            font-style: italic;
        }

        /* Comment input area */
        .comment-input-area {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #E0E0E0;
        }

        .comment-textarea {
            width: 100%;
            min-height: 80px;
            padding: 10px 12px;
            font-size: 13px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            resize: vertical;
        }

        .comment-textarea:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .comment-textarea::placeholder {
            color: #ADB5BD;
        }

        .comment-submit-btn {
            margin-top: 8px;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 500;
            background: #FFB800;
            color: #1F1F1F;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .comment-submit-btn:hover {
            background: #E5A600;
        }

        .comment-submit-btn:disabled {
            background: #E0E0E0;
            color: #ADB5BD;
            cursor: not-allowed;
        }

        /* Cancel modal with textarea */
        .cancel-modal-content {
            text-align: left;
        }

        .cancel-modal-content .modal-title {
            text-align: center;
        }

        .cancel-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            color: #F57C00;
            display: block;
        }

        .cancel-modal-content .form-group {
            margin-bottom: 20px;
        }

        .form-textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            resize: vertical;
        }

        .form-textarea:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .form-textarea::placeholder {
            color: #ADB5BD;
        }

        .btn-warning {
            background: #F57C00;
            color: #FFFFFF;
        }

        .btn-warning:hover {
            background: #E65100;
        }

        /* People page styles */
        .people-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .person-item {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .person-item:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
        }

        .person-info {
            flex: 1;
            min-width: 0;
        }

        .person-name {
            font-size: 15px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 4px;
        }

        .person-role {
            font-size: 13px;
            color: #6C757D;
        }

        .person-role-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 500;
            color: #6C757D;
            background: #F5F5F5;
            border-radius: 12px;
        }

        .person-actions {
            display: flex;
            gap: 4px;
        }

        /* Roles section */
        .roles-section {
            margin-top: 32px;
            padding-top: 24px;
            border-top: 1px solid #E0E0E0;
        }

        .roles-title {
            font-size: 14px;
            font-weight: 600;
            color: #6C757D;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .roles-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .role-tag {
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            font-size: 13px;
            color: #1F1F1F;
            background: #F5F5F5;
            border-radius: 16px;
        }

        /* Inline person creation form */
        .inline-person-form {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
            background: #F8F9FA;
            border-radius: 8px;
            margin-top: 0;
            padding: 0 16px;
        }

        .inline-person-form.open {
            max-height: 200px;
            padding: 16px;
            margin-top: 12px;
        }

        .inline-person-form .form-group {
            margin-bottom: 12px;
        }

        .inline-person-form .form-group:last-child {
            margin-bottom: 0;
        }

        .inline-person-form .form-label {
            font-size: 12px;
            margin-bottom: 4px;
        }

        .inline-person-form .form-input {
            height: 40px;
            padding: 8px 12px;
            font-size: 13px;
        }

        .inline-person-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .inline-person-title {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .inline-person-actions {
            display: flex;
            gap: 8px;
        }

        .inline-person-actions .btn {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Contact badge in opportunity list */
        .opp-contact-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 500;
            color: #1976D2;
            background: #E3F2FD;
            border-radius: 12px;
        }

        /* Settings page layout */
        #settings-page {
            background: #F5F5F5;
        }

        .settings-container {
            display: flex;
            min-height: calc(100vh - 60px);
            margin-top: 60px;
        }

        .settings-menu {
            width: 20%;
            background: #FFFFFF;
            border-right: 1px solid #E0E0E0;
            padding: 24px 0;
        }

        .settings-menu-title {
            font-size: 14px;
            font-weight: 600;
            color: #6C757D;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 0 24px;
            margin-bottom: 16px;
        }

        .settings-menu-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .settings-menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 24px;
            font-size: 15px;
            font-weight: 500;
            color: #1F1F1F;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .settings-menu-item:hover {
            background: #F8F9FA;
        }

        .settings-menu-item.active {
            background: #FFF8E1;
            border-left-color: #FFB800;
            color: #1F1F1F;
        }

        .settings-menu-item svg {
            width: 24px;
            height: 24px;
            color: #6C757D;
            flex-shrink: 0;
        }

        .settings-menu-item.active svg {
            color: #FFB800;
        }

        .settings-content {
            width: 80%;
            position: relative;
            padding: 24px;
            overflow-y: auto;
        }

        .settings-close-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: #FFFFFF;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .settings-close-btn:hover {
            background: #F8F9FA;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .settings-close-btn svg {
            width: 24px;
            height: 24px;
            color: #6C757D;
        }

        .settings-close-btn:hover svg {
            color: #1F1F1F;
        }

        .settings-section-title {
            font-size: 24px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 24px;
        }

        /* Responsive settings */
        @media (max-width: 768px) {
            .settings-container {
                flex-direction: column;
            }

            .settings-menu {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #E0E0E0;
                padding: 16px 0;
            }

            .settings-content {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- Landing Page -->
    <div id="landing-page" class="container">
        <div class="logo-container">
            <svg class="logo" viewBox="0 0 120 120" fill="none" xmlns="http://www.w3.org/2000/svg">
                <!-- Clipboard background -->
                <rect x="20" y="15" width="80" height="95" rx="8" fill="#FFB800"/>
                <rect x="25" y="20" width="70" height="85" rx="6" fill="#FFFFFF"/>

                <!-- Clipboard clip -->
                <path d="M45 10 H75 C78 10 80 12 80 15 V20 H40 V15 C40 12 42 10 45 10 Z" fill="#FFB800"/>
                <rect x="48" y="5" width="24" height="12" rx="3" fill="#1F1F1F"/>

                <!-- Checkmark items -->
                <g opacity="0.9">
                    <!-- First item - checked -->
                    <circle cx="35" cy="38" r="5" fill="#00A86B"/>
                    <path d="M33 38 L34.5 39.5 L37.5 36.5" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <rect x="45" y="36" width="45" height="4" rx="2" fill="#E0E0E0"/>

                    <!-- Second item - checked -->
                    <circle cx="35" cy="55" r="5" fill="#00A86B"/>
                    <path d="M33 55 L34.5 56.5 L37.5 53.5" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <rect x="45" y="53" width="35" height="4" rx="2" fill="#E0E0E0"/>

                    <!-- Third item - unchecked -->
                    <circle cx="35" cy="72" r="5" fill="#E0E0E0"/>
                    <rect x="45" y="70" width="40" height="4" rx="2" fill="#E0E0E0"/>

                    <!-- Fourth item - unchecked -->
                    <circle cx="35" cy="89" r="5" fill="#E0E0E0"/>
                    <rect x="45" y="87" width="30" height="4" rx="2" fill="#E0E0E0"/>
                </g>
            </svg>
            <h1>TodoManager</h1>
            <p class="tagline">Organize your tasks, achieve your goals</p>
        </div>

        <div class="options-container">
            <div class="option-card" onclick="startFromScratch()">
                <div class="option-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </div>
                <h2 class="option-title">Start from Scratch</h2>
                <p class="option-description">Begin fresh with a clean workspace and create your first task list</p>
            </div>

            <div class="option-card" onclick="continueWorking()">
                <div class="option-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 11l3 3L22 4"></path>
                        <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"></path>
                    </svg>
                </div>
                <h2 class="option-title">Continue Working</h2>
                <p class="option-description">Pick up where you left off and manage your existing tasks</p>
            </div>
        </div>

        <div class="footer">
            <p>&copy; 2025 TodoManager. Built with care.</p>
        </div>
    </div>

    <!-- App Header (shared across pages) -->
    <header id="app-header" class="header hidden">
        <div class="header-left">
            <nav class="tab-nav">
                <button id="tab-home" class="tab-btn active" onclick="switchTab('home')">Todo's</button>
                <button id="tab-opportunities" class="tab-btn" onclick="switchTab('opportunities')">Opportunities</button>
            </nav>
        </div>
        <div class="header-actions">
            <button class="icon-button" onclick="openSettings()" title="Settings">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="3"></circle>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                </svg>
            </button>
            <button class="icon-button" onclick="exportData()" title="Export">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
            </button>
        </div>
    </header>

    <!-- Home Page -->
    <div id="home-page" class="page hidden">

        <!-- Main Content -->
        <main class="main-content">
            <!-- Floating shortcut hint (shown when items exist) -->
            <p id="todo-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

            <!-- Todo List Container -->
            <div id="todo-list" class="todo-list">
                <!-- Todos will be rendered here -->
            </div>

            <!-- Empty State -->
            <div id="empty-state" class="empty-state">
                <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"></path>
                    <rect x="9" y="3" width="6" height="4" rx="1"></rect>
                    <line x1="9" y1="12" x2="15" y2="12"></line>
                    <line x1="9" y1="16" x2="13" y2="16"></line>
                </svg>
                <p class="empty-text">No Todos</p>
                <p class="shortcut-hint">Press Shift + N to create new items</p>
            </div>
        </main>
    </div>

    <!-- Opportunities Page -->
    <div id="opportunities-page" class="page hidden">
        <!-- Main Content -->
        <main class="main-content">
            <!-- Archive Toggle -->
            <div class="archive-toggle-container">
                <label class="archive-toggle">
                    <input type="checkbox" id="show-archived-toggle" onchange="toggleShowArchived()">
                    <span>Show Archived</span>
                </label>
            </div>
            <!-- Floating shortcut hint (shown when items exist) -->
            <p id="opp-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

            <!-- Opportunity List Container -->
            <div id="opportunity-list" class="opportunity-list">
                <!-- Opportunities will be rendered here -->
            </div>

            <!-- Empty State -->
            <div id="opportunity-empty-state" class="empty-state">
                <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                </svg>
                <p class="empty-text">No Opportunities</p>
                <p class="shortcut-hint">Press Shift + N to create new items</p>
            </div>
        </main>
    </div>

    <!-- Settings Page -->
    <div id="settings-page" class="page hidden">
        <div class="settings-container">
            <!-- Left Menu -->
            <nav class="settings-menu">
                <h2 class="settings-menu-title">Settings</h2>
                <ul class="settings-menu-list">
                    <li class="settings-menu-item active" data-section="people" onclick="switchSettingsSection('people')">
                        <!-- Multi-user icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                        <span>People</span>
                    </li>
                </ul>
            </nav>

            <!-- Content Area -->
            <div class="settings-content">
                <!-- Close Button -->
                <button class="settings-close-btn" onclick="closeSettings()" title="Close Settings">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>

                <!-- People Section -->
                <div id="settings-section-people" class="settings-section">
                    <h2 class="settings-section-title">People</h2>

                    <!-- Floating shortcut hint (shown when items exist) -->
                    <p id="people-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

                    <!-- People List Container -->
                    <div id="people-list" class="people-list">
                        <!-- People will be rendered here -->
                    </div>

                    <!-- Empty State -->
                    <div id="people-empty-state" class="empty-state">
                        <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                        <p class="empty-text">No People</p>
                        <p class="shortcut-hint">Press Shift + N to create new items</p>
                    </div>

                    <!-- Roles Section -->
                    <div id="roles-section" class="roles-section hidden">
                        <h3 class="roles-title">Roles</h3>
                        <div id="roles-list" class="roles-list">
                            <!-- Roles will be rendered here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Side Panel for Opportunity Details -->
    <div id="side-panel-backdrop" class="side-panel-backdrop" onclick="closeSidePanel()"></div>
    <div id="side-panel" class="side-panel">
        <div class="side-panel-header">
            <h2 class="side-panel-title">Opportunity Details</h2>
            <button class="side-panel-close" onclick="closeSidePanel()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="side-panel-body">
            <div class="detail-group">
                <div class="detail-label">Name</div>
                <div id="panel-opp-name" class="detail-value"></div>
            </div>
            <div class="detail-group">
                <div class="detail-label">Description</div>
                <div id="panel-opp-description" class="detail-value"></div>
            </div>
            <div class="detail-group">
                <div class="detail-label">Start Date</div>
                <div id="panel-opp-date" class="detail-value"></div>
            </div>
            <div class="detail-group">
                <div class="detail-label">Contact</div>
                <div id="panel-opp-contact" class="detail-value"></div>
            </div>
            <div class="detail-group">
                <div class="detail-label">Status</div>
                <span id="panel-opp-status" class="status-badge"></span>
            </div>
            <!-- Comments Section -->
            <div class="comments-section">
                <div class="comments-header">Comments</div>
                <div id="panel-comments" class="comments-list">
                    <!-- Comments will be rendered here -->
                </div>
                <!-- Comment Input Area -->
                <div class="comment-input-area">
                    <textarea id="comment-input" class="comment-textarea" placeholder="Add a comment..."></textarea>
                    <button type="button" class="comment-submit-btn" onclick="addComment()">Add Comment</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Create Todo Modal -->
    <div id="todo-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeModal()"></div>
        <div class="modal-content">
            <h2 id="modal-title" class="modal-title">New Todo</h2>
            <form id="todo-form" onsubmit="saveTodo(event)">
                <div class="form-group">
                    <label for="todo-description" class="form-label">Description <span class="required">*</span></label>
                    <input type="text" id="todo-description" class="form-input" placeholder="What needs to be done?" required autofocus>
                </div>
                <div class="form-group">
                    <label for="todo-due-date" class="form-label">Due Date</label>
                    <input type="date" id="todo-due-date" class="form-input">
                </div>
                <div class="form-group">
                    <label for="todo-opportunity" class="form-label">Linked Opportunity</label>
                    <div class="autocomplete-wrapper">
                        <div class="autocomplete-input-wrapper">
                            <input type="text" id="todo-opportunity" class="autocomplete-input" placeholder="Type to search or create..." autocomplete="off">
                            <button type="button" id="todo-opportunity-clear" class="autocomplete-clear" onclick="clearOpportunitySelection()">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="18" y1="6" x2="6" y2="18"></line>
                                    <line x1="6" y1="6" x2="18" y2="18"></line>
                                </svg>
                            </button>
                        </div>
                        <div id="opportunity-dropdown" class="autocomplete-dropdown">
                            <!-- Dropdown items will be rendered here -->
                        </div>
                    </div>
                    <!-- Inline Opportunity Creation Form -->
                    <div id="inline-opp-form" class="inline-opp-form">
                        <div class="inline-opp-header">
                            <span class="inline-opp-title">Create New Opportunity</span>
                            <div class="inline-opp-actions">
                                <button type="button" class="btn btn-secondary" onclick="cancelInlineOpportunity()">Cancel</button>
                                <button type="button" class="btn btn-primary" onclick="confirmInlineOpportunity()">Add</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="inline-opp-name" class="form-label">Name</label>
                            <input type="text" id="inline-opp-name" class="form-input" placeholder="Opportunity name" readonly>
                        </div>
                        <div class="form-group">
                            <label for="inline-opp-description" class="form-label">Description</label>
                            <input type="text" id="inline-opp-description" class="form-input" placeholder="Brief description">
                        </div>
                        <div class="form-group">
                            <label for="inline-opp-start-date" class="form-label">Start Date</label>
                            <input type="date" id="inline-opp-start-date" class="form-input">
                        </div>
                        <div class="form-group">
                            <label for="inline-opp-contact" class="form-label">Contact</label>
                            <div class="autocomplete-wrapper">
                                <input type="text" id="inline-opp-contact" class="form-input" placeholder="Type to search or create person..." autocomplete="off">
                                <button type="button" id="inline-opp-contact-clear" class="autocomplete-clear" onclick="clearInlineOppContact()"></button>
                                <div id="inline-opp-contact-dropdown" class="autocomplete-dropdown">
                                    <!-- Contact dropdown items will be rendered here -->
                                </div>
                            </div>
                            <!-- Inline Person Creation Form (within inline opportunity) -->
                            <div id="inline-opp-person-form" class="inline-person-form">
                                <div class="inline-person-header">
                                    <span class="inline-person-title">Create New Person</span>
                                    <div class="inline-person-actions">
                                        <button type="button" class="btn btn-secondary" onclick="cancelInlineOppPerson()">Cancel</button>
                                        <button type="button" class="btn btn-primary" onclick="confirmInlineOppPerson()">Add</button>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label for="inline-opp-person-name" class="form-label">Name</label>
                                    <input type="text" id="inline-opp-person-name" class="form-input" placeholder="Person's name" readonly>
                                </div>
                                <div class="form-group">
                                    <label for="inline-opp-person-role" class="form-label">Role</label>
                                    <input type="text" id="inline-opp-person-role" class="form-input" placeholder="Person's role">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Create Opportunity Modal -->
    <div id="opportunity-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeOpportunityModal()"></div>
        <div class="modal-content">
            <h2 class="modal-title">New Opportunity</h2>
            <form id="opportunity-form" onsubmit="saveOpportunity(event)">
                <div class="form-group">
                    <label for="opp-name" class="form-label">Name <span class="required">*</span></label>
                    <input type="text" id="opp-name" class="form-input" placeholder="Opportunity name" required autofocus>
                </div>
                <div class="form-group">
                    <label for="opp-description" class="form-label">Description</label>
                    <input type="text" id="opp-description" class="form-input" placeholder="Brief description">
                </div>
                <div class="form-group">
                    <label for="opp-start-date" class="form-label">Start Date</label>
                    <input type="date" id="opp-start-date" class="form-input">
                </div>
                <div class="form-group">
                    <label for="opp-contact" class="form-label">Contact</label>
                    <div class="autocomplete-wrapper">
                        <input type="text" id="opp-contact" class="form-input" placeholder="Type to search or create person..." autocomplete="off">
                        <button type="button" id="opp-contact-clear" class="autocomplete-clear" onclick="clearOppContact()"></button>
                        <div id="contact-dropdown" class="autocomplete-dropdown">
                            <!-- Contact dropdown items will be rendered here -->
                        </div>
                    </div>
                    <!-- Inline Person Creation Form -->
                    <div id="inline-person-form" class="inline-person-form">
                        <div class="inline-person-header">
                            <span class="inline-person-title">Create New Person</span>
                            <div class="inline-person-actions">
                                <button type="button" class="btn btn-secondary" onclick="cancelInlinePerson()">Cancel</button>
                                <button type="button" class="btn btn-primary" onclick="confirmInlinePerson()">Add</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="inline-person-name" class="form-label">Name</label>
                            <input type="text" id="inline-person-name" class="form-input" placeholder="Person's name">
                        </div>
                        <div class="form-group">
                            <label for="inline-person-role" class="form-label">Role</label>
                            <input type="text" id="inline-person-role" class="form-input" placeholder="Person's role">
                        </div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeOpportunityModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="confirm-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeConfirmModal()"></div>
        <div class="modal-content confirm-modal-content">
            <svg class="confirm-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
            <h2 class="confirm-title">Delete Opportunity?</h2>
            <p id="confirm-message" class="confirm-message">Are you sure you want to delete this opportunity? This action cannot be undone.</p>
            <div class="confirm-actions">
                <button type="button" class="btn btn-secondary" onclick="closeConfirmModal()">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="confirmDeleteOpportunity()">Delete</button>
            </div>
        </div>
    </div>

    <!-- Cancel Opportunity Modal -->
    <div id="cancel-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeCancelModal()"></div>
        <div class="modal-content cancel-modal-content">
            <svg class="cancel-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="15" y1="9" x2="9" y2="15"></line>
                <line x1="9" y1="9" x2="15" y2="15"></line>
            </svg>
            <h2 class="modal-title">Cancel Opportunity</h2>
            <p id="cancel-opp-name" style="text-align: center; color: #6C757D; margin-bottom: 20px;"></p>
            <div class="form-group">
                <label for="cancel-reason" class="form-label">Reason for Cancellation <span class="required">*</span></label>
                <textarea id="cancel-reason" class="form-textarea" placeholder="Please provide a reason for cancelling this opportunity..." required></textarea>
            </div>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeCancelModal()">Back</button>
                <button type="button" class="btn btn-warning" onclick="confirmCancelOpportunity()">Cancel Opportunity</button>
            </div>
        </div>
    </div>

    <!-- Person Modal -->
    <div id="person-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closePersonModal()"></div>
        <div class="modal-content">
            <h2 id="person-modal-title" class="modal-title">New Person</h2>
            <form id="person-form" onsubmit="savePerson(event)">
                <div class="form-group">
                    <label for="person-name" class="form-label">Name <span class="required">*</span></label>
                    <input type="text" id="person-name" class="form-input" placeholder="Person's name" required>
                </div>
                <div class="form-group">
                    <label for="person-role" class="form-label">Role</label>
                    <div class="autocomplete-wrapper">
                        <input type="text" id="person-role" class="form-input" placeholder="Type to search or create role..." autocomplete="off">
                        <button type="button" id="person-role-clear" class="autocomplete-clear" onclick="clearPersonRole()"></button>
                        <div id="role-dropdown" class="autocomplete-dropdown">
                            <!-- Role dropdown items will be rendered here -->
                        </div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closePersonModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Delete Person Confirmation Modal -->
    <div id="delete-person-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeDeletePersonModal()"></div>
        <div class="modal-content confirm-modal-content">
            <svg class="confirm-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
            <h2 class="modal-title">Delete Person</h2>
            <p id="delete-person-name" style="text-align: center; color: #6C757D; margin-bottom: 20px;"></p>
            <p style="text-align: center; margin-bottom: 20px;">Are you sure you want to delete this person? This will remove them from any linked opportunities.</p>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeDeletePersonModal()">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="confirmDeletePerson()">Delete</button>
            </div>
        </div>
    </div>

    <script>
        // Application state
        const state = {
            todos: [],
            opportunities: [],
            people: [],
            roles: [],
            currentPage: 'landing',
            currentTab: 'home',  // 'home', 'opportunities', or 'settings'
            previousTab: 'home',  // Track previous tab for settings return navigation
            settingsSection: 'people',  // Current settings section
            modalOpen: false,
            opportunityModalOpen: false,
            personModalOpen: false,
            confirmModalOpen: false,
            cancelModalOpen: false,
            sidePanelOpen: false,
            editingTodoIndex: null,  // Track which todo is being edited (null = create mode)
            editingPersonIndex: null,  // Track which person is being edited (null = create mode)
            selectedOpportunityIndex: null,  // Track which opportunity is open in side panel
            deleteOpportunityIndex: null,  // Track which opportunity is pending deletion
            deletePersonIndex: null,  // Track which person is pending deletion
            cancelOpportunityIndex: null,  // Track which opportunity is pending cancellation
            // Autocomplete state
            selectedOpportunityId: null,  // ID of selected opportunity for todo linking
            selectedPersonId: null,  // ID of selected person for opportunity contact
            pendingOpportunity: null,  // New opportunity to create when saving todo
            pendingPerson: null,  // New person to create when saving opportunity
            autocompleteOpen: false,
            autocompleteHighlightIndex: -1,
            roleAutocompleteOpen: false,
            roleAutocompleteHighlightIndex: -1,
            contactAutocompleteOpen: false,
            contactAutocompleteHighlightIndex: -1,
            inlineOppFormOpen: false,
            inlinePersonFormOpen: false,
            // Inline person form within inline opportunity (in Todo modal)
            inlineOppContactAutocompleteOpen: false,
            inlineOppContactAutocompleteHighlightIndex: -1,
            inlineOppPersonFormOpen: false,
            selectedInlineOppPersonId: null,
            pendingInlineOppPerson: null,
            showArchived: false
        };

        // DOM Elements - Landing and Home
        const landingPage = document.getElementById('landing-page');
        const homePage = document.getElementById('home-page');
        const todoList = document.getElementById('todo-list');
        const emptyState = document.getElementById('empty-state');
        const todoShortcutHintFloating = document.getElementById('todo-shortcut-hint-floating');
        const todoModal = document.getElementById('todo-modal');
        const todoForm = document.getElementById('todo-form');
        const todoDescriptionInput = document.getElementById('todo-description');
        const todoDueDateInput = document.getElementById('todo-due-date');
        const modalTitle = document.getElementById('modal-title');

        // DOM Elements - Autocomplete
        const todoOpportunityInput = document.getElementById('todo-opportunity');
        const todoOpportunityClear = document.getElementById('todo-opportunity-clear');
        const opportunityDropdown = document.getElementById('opportunity-dropdown');
        const inlineOppForm = document.getElementById('inline-opp-form');
        const inlineOppName = document.getElementById('inline-opp-name');
        const inlineOppDescription = document.getElementById('inline-opp-description');
        const inlineOppStartDate = document.getElementById('inline-opp-start-date');
        const inlineOppContact = document.getElementById('inline-opp-contact');
        const inlineOppContactClear = document.getElementById('inline-opp-contact-clear');
        const inlineOppContactDropdown = document.getElementById('inline-opp-contact-dropdown');
        const inlineOppPersonForm = document.getElementById('inline-opp-person-form');
        const inlineOppPersonName = document.getElementById('inline-opp-person-name');
        const inlineOppPersonRole = document.getElementById('inline-opp-person-role');

        // DOM Elements - Opportunities
        const opportunitiesPage = document.getElementById('opportunities-page');
        const opportunityList = document.getElementById('opportunity-list');
        const opportunityEmptyState = document.getElementById('opportunity-empty-state');
        const oppShortcutHintFloating = document.getElementById('opp-shortcut-hint-floating');
        const opportunityModal = document.getElementById('opportunity-modal');
        const opportunityForm = document.getElementById('opportunity-form');
        const oppNameInput = document.getElementById('opp-name');
        const oppDescriptionInput = document.getElementById('opp-description');
        const oppStartDateInput = document.getElementById('opp-start-date');
        const oppContactInput = document.getElementById('opp-contact');
        const oppContactClear = document.getElementById('opp-contact-clear');
        const contactDropdown = document.getElementById('contact-dropdown');
        const inlinePersonForm = document.getElementById('inline-person-form');
        const inlinePersonName = document.getElementById('inline-person-name');
        const inlinePersonRole = document.getElementById('inline-person-role');

        // DOM Elements - Side Panel
        const sidePanel = document.getElementById('side-panel');
        const sidePanelBackdrop = document.getElementById('side-panel-backdrop');
        const panelOppName = document.getElementById('panel-opp-name');
        const panelOppDescription = document.getElementById('panel-opp-description');
        const panelOppDate = document.getElementById('panel-opp-date');
        const panelOppContact = document.getElementById('panel-opp-contact');
        const panelOppStatus = document.getElementById('panel-opp-status');

        // DOM Elements - Header and Tabs
        const appHeader = document.getElementById('app-header');
        const tabHome = document.getElementById('tab-home');
        const tabOpportunities = document.getElementById('tab-opportunities');

        // DOM Elements - Confirmation Modal
        const confirmModal = document.getElementById('confirm-modal');
        const confirmMessage = document.getElementById('confirm-message');

        // DOM Elements - Cancel Modal
        const cancelModal = document.getElementById('cancel-modal');
        const cancelOppName = document.getElementById('cancel-opp-name');
        const cancelReason = document.getElementById('cancel-reason');

        // DOM Elements - Comments
        const panelComments = document.getElementById('panel-comments');
        const commentInput = document.getElementById('comment-input');

        // DOM Elements - Archive Toggle
        const showArchivedToggle = document.getElementById('show-archived-toggle');

        // DOM Elements - Settings
        const settingsPage = document.getElementById('settings-page');
        const peopleList = document.getElementById('people-list');
        const peopleEmptyState = document.getElementById('people-empty-state');
        const peopleShortcutHintFloating = document.getElementById('people-shortcut-hint-floating');
        const rolesSection = document.getElementById('roles-section');
        const rolesList = document.getElementById('roles-list');

        // DOM Elements - Person Modal
        const personModal = document.getElementById('person-modal');
        const personModalTitle = document.getElementById('person-modal-title');
        const personForm = document.getElementById('person-form');
        const personNameInput = document.getElementById('person-name');
        const personRoleInput = document.getElementById('person-role');
        const personRoleClear = document.getElementById('person-role-clear');
        const roleDropdown = document.getElementById('role-dropdown');

        // DOM Elements - Delete Person Modal
        const deletePersonModal = document.getElementById('delete-person-modal');
        const deletePersonName = document.getElementById('delete-person-name');

        // Navigation functions
        function navigateTo(page) {
            // Hide all pages
            landingPage.classList.add('hidden');
            landingPage.classList.remove('container');
            homePage.classList.add('hidden');
            opportunitiesPage.classList.add('hidden');
            settingsPage.classList.add('hidden');
            appHeader.classList.add('hidden');

            // Show requested page
            if (page === 'landing') {
                landingPage.classList.remove('hidden');
                landingPage.classList.add('container');
                document.body.style.display = 'flex';
                document.body.style.alignItems = 'center';
                document.body.style.justifyContent = 'center';
            } else if (page === 'app') {
                // Show app with header and current tab
                appHeader.classList.remove('hidden');
                document.body.style.display = 'block';
                document.body.style.alignItems = '';
                document.body.style.justifyContent = '';
                switchTab(state.currentTab);
            }

            state.currentPage = page;
        }

        // Tab switching function
        function switchTab(tab) {
            state.currentTab = tab;

            // Update tab buttons (settings doesn't have a tab button)
            tabHome.classList.toggle('active', tab === 'home');
            tabOpportunities.classList.toggle('active', tab === 'opportunities');

            // Show/hide pages
            homePage.classList.toggle('hidden', tab !== 'home');
            opportunitiesPage.classList.toggle('hidden', tab !== 'opportunities');
            settingsPage.classList.toggle('hidden', tab !== 'settings');

            // Render content
            if (tab === 'home') {
                renderTodos();
            } else if (tab === 'opportunities') {
                renderOpportunities();
            } else if (tab === 'settings') {
                renderPeople();
            }
        }

        // Open Settings page
        function openSettings() {
            // Save current tab before navigating to settings
            if (state.currentTab !== 'settings') {
                state.previousTab = state.currentTab;
            }
            switchTab('settings');
        }

        // Close Settings and return to previous page
        function closeSettings() {
            switchTab(state.previousTab);
        }

        // Switch settings section (for future extensibility)
        function switchSettingsSection(section) {
            state.settingsSection = section;

            // Update menu item active state
            const menuItems = document.querySelectorAll('.settings-menu-item');
            menuItems.forEach(item => {
                item.classList.toggle('active', item.dataset.section === section);
            });

            // For now, only People section exists
            // Future sections would be shown/hidden here
            if (section === 'people') {
                renderPeople();
            }
        }

        function startFromScratch() {
            // Clear data and navigate to app
            state.todos = [];
            state.opportunities = [];
            state.currentTab = 'home';
            navigateTo('app');
        }

        function continueWorking() {
            // Navigate to app with existing data
            navigateTo('app');
        }

        // Placeholder functions for header actions
        function exportData() {
            // Export functionality not implemented yet
            console.log('Export clicked - not implemented');
        }

        // Placeholder for data persistence
        function saveData() {
            // Data persistence not implemented yet - data lives in memory
        }

        // Modal functions
        function openModal(todoIndex = null) {
            todoModal.classList.remove('hidden');
            state.modalOpen = true;
            state.editingTodoIndex = todoIndex;

            // Reset form
            todoForm.reset();

            // Reset autocomplete state
            state.selectedOpportunityId = null;
            state.pendingOpportunity = null;
            state.autocompleteOpen = false;
            state.autocompleteHighlightIndex = -1;
            state.inlineOppFormOpen = false;
            // Reset inline opp person state
            state.inlineOppContactAutocompleteOpen = false;
            state.inlineOppContactAutocompleteHighlightIndex = -1;
            state.inlineOppPersonFormOpen = false;
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;
            todoOpportunityInput.value = '';
            todoOpportunityClear.classList.remove('visible');
            opportunityDropdown.classList.remove('open');
            inlineOppForm.classList.remove('open');
            // Reset inline opp contact fields
            inlineOppContact.value = '';
            inlineOppContactClear.classList.remove('visible');
            inlineOppContactDropdown.classList.remove('open');
            inlineOppPersonForm.classList.remove('open');

            if (todoIndex !== null) {
                // Edit mode - populate with existing todo data
                const todo = state.todos[todoIndex];
                modalTitle.textContent = 'Edit Todo';
                todoDescriptionInput.value = todo.title;
                todoDueDateInput.value = todo.dueDate || '';

                // Pre-populate linked opportunity
                if (todo.opportunityId) {
                    const opp = state.opportunities.find(o => o.id === todo.opportunityId);
                    if (opp) {
                        state.selectedOpportunityId = opp.id;
                        todoOpportunityInput.value = opp.name;
                        todoOpportunityClear.classList.add('visible');
                    }
                }
            } else {
                // Create mode
                modalTitle.textContent = 'New Todo';
                // Set default due date to today
                todoDueDateInput.value = getTodayDate();
            }

            // Focus on description input
            setTimeout(() => todoDescriptionInput.focus(), 100);
        }

        // Edit a todo - opens modal in edit mode
        function editTodo(index) {
            openModal(index);
        }

        // Get today's date in YYYY-MM-DD format for date input
        function getTodayDate() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function closeModal() {
            todoModal.classList.add('hidden');
            state.modalOpen = false;
            state.editingTodoIndex = null;
            state.selectedOpportunityId = null;
            state.pendingOpportunity = null;
            state.autocompleteOpen = false;
            state.inlineOppFormOpen = false;
            todoForm.reset();
            opportunityDropdown.classList.remove('open');
            inlineOppForm.classList.remove('open');
        }

        // Generate unique ID
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
        }

        // Save todo (handles both create and update)
        function saveTodo(event) {
            event.preventDefault();

            const description = todoDescriptionInput.value.trim();
            const dueDate = todoDueDateInput.value;

            if (!description) return;

            // Handle pending opportunity creation
            let opportunityId = state.selectedOpportunityId;
            if (state.pendingOpportunity) {
                // First, handle person creation if needed
                let contactPersonId = state.pendingOpportunity.contactPersonId;

                // Check for pending person from inline opp form (may be set after opportunity was confirmed)
                const pendingPersonData = state.pendingOpportunity.pendingPerson || state.pendingInlineOppPerson;

                if (pendingPersonData) {
                    // Create the new person (use the combined pending person data)
                    const pendingPerson = pendingPersonData;

                    // Handle role creation if needed
                    let roleId = null;
                    if (pendingPerson.role) {
                        // Check if role exists
                        const existingRole = state.roles.find(r => r.name.toLowerCase() === pendingPerson.role.toLowerCase());
                        if (existingRole) {
                            roleId = existingRole.id;
                        } else {
                            // Create new role
                            const newRole = {
                                id: generateId(),
                                name: pendingPerson.role,
                                createdAt: new Date().toISOString()
                            };
                            state.roles.push(newRole);
                            roleId = newRole.id;
                        }
                    }

                    // Create the person
                    const newPerson = {
                        id: generateId(),
                        name: pendingPerson.name,
                        roleId: roleId,
                        createdAt: new Date().toISOString()
                    };
                    state.people.push(newPerson);
                    contactPersonId = newPerson.id;
                }

                // Create the new opportunity
                const newOpp = {
                    id: generateId(),
                    name: state.pendingOpportunity.name,
                    description: state.pendingOpportunity.description || null,
                    startDate: state.pendingOpportunity.startDate || getTodayDate(),
                    contactPersonId: contactPersonId || null,
                    status: 'requested',
                    comments: [],
                    archived: false,
                    createdAt: new Date().toISOString()
                };
                state.opportunities.push(newOpp);
                opportunityId = newOpp.id;
            }

            if (state.editingTodoIndex !== null) {
                // Update existing todo
                const todo = state.todos[state.editingTodoIndex];
                todo.title = description;
                todo.dueDate = dueDate || null;
                todo.opportunityId = opportunityId;
                // Preserve id, completed, and createdAt
            } else {
                // Create new todo
                const newTodo = {
                    id: generateId(),
                    title: description,
                    dueDate: dueDate || null,
                    opportunityId: opportunityId,
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                state.todos.push(newTodo);
            }

            // Auto-update opportunity status to Open if todo is linked and not completed
            if (opportunityId) {
                updateOpportunityAutoStatus(opportunityId);
            }

            closeModal();
            renderTodos();
            // Also re-render opportunities if on that tab
            if (state.currentTab === 'opportunities') {
                renderOpportunities();
            }
        }

        // Auto-update opportunity status based on linked todos
        // Status Flow: Requested  Open (when todo linked)  Paused (all todos complete)  Closed
        function updateOpportunityAutoStatus(opportunityId) {
            const opp = state.opportunities.find(o => o.id === opportunityId);
            if (!opp) return;

            // Don't change closed or cancelled opportunities
            if (opp.status === 'closed' || opp.status === 'cancelled') return;

            // Get all todos linked to this opportunity
            const linkedTodos = state.todos.filter(t => t.opportunityId === opportunityId);

            // Check if any linked todo is not completed
            const hasActiveTodo = linkedTodos.some(t => !t.completed);
            const hasAnyTodo = linkedTodos.length > 0;

            if (hasActiveTodo) {
                // Has non-completed todos  Open
                if (opp.status !== 'open') {
                    opp.status = 'open';
                }
            } else if (hasAnyTodo) {
                // All todos are completed  Paused
                if (opp.status !== 'paused') {
                    opp.status = 'paused';
                }
            }
            // If no todos linked, keep current status
        }

        // Render functions
        function renderTodos() {
            if (state.currentPage !== 'app' || state.currentTab !== 'home') return;

            // Clear current list
            todoList.innerHTML = '';

            if (state.todos.length === 0) {
                // Show empty state
                todoList.classList.add('hidden');
                emptyState.classList.remove('hidden');
                todoShortcutHintFloating.classList.add('hidden');
            } else {
                // Show todo list
                todoList.classList.remove('hidden');
                emptyState.classList.add('hidden');
                todoShortcutHintFloating.classList.remove('hidden');

                state.todos.forEach((todo, index) => {
                    const todoItem = document.createElement('div');
                    todoItem.className = `todo-item ${todo.completed ? 'completed' : ''}`;

                    // Format due date
                    let dueDateHtml = '';
                    if (todo.dueDate) {
                        const dueDate = new Date(todo.dueDate);
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);
                        const isOverdue = dueDate < today && !todo.completed;
                        dueDateHtml = `<div class="todo-due-date ${isOverdue ? 'overdue' : ''}">Due: ${formatDate(todo.dueDate)}</div>`;
                    }

                    // Format linked opportunity
                    let opportunityHtml = '';
                    if (todo.opportunityId) {
                        const opp = state.opportunities.find(o => o.id === todo.opportunityId);
                        if (opp) {
                            opportunityHtml = `
                                <div class="todo-opportunity">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <circle cx="12" cy="12" r="10"></circle>
                                        <polyline points="12 6 12 12 16 14"></polyline>
                                    </svg>
                                    ${escapeHtml(opp.name)}
                                </div>
                            `;
                        }
                    }

                    todoItem.innerHTML = `
                        <div class="todo-checkbox ${todo.completed ? 'checked' : ''}" onclick="toggleTodo(${index})"></div>
                        <div class="todo-content">
                            <div class="todo-title">${escapeHtml(todo.title)}</div>
                            ${dueDateHtml}
                            ${opportunityHtml}
                        </div>
                        <div class="todo-actions">
                            <button class="todo-edit-btn" onclick="editTodo(${index})" title="Edit">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                        </div>
                    `;
                    todoList.appendChild(todoItem);
                });
            }
        }

        function toggleTodo(index) {
            const todo = state.todos[index];
            todo.completed = !todo.completed;

            // Check and update opportunity status if linked
            if (todo.opportunityId) {
                updateOpportunityAutoStatus(todo.opportunityId);
            }

            renderTodos();
            // Re-render opportunities if on that tab to update status badges
            if (state.currentTab === 'opportunities') {
                renderOpportunities();
            }
        }

        // Utility function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Format date for display
        function formatDate(dateString) {
            const date = new Date(dateString);
            const options = { year: 'numeric', month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        // Opportunity Modal functions
        function openOpportunityModal() {
            opportunityModal.classList.remove('hidden');
            state.opportunityModalOpen = true;

            // Reset form
            opportunityForm.reset();
            // Set default start date to today
            oppStartDateInput.value = getTodayDate();

            // Reset contact autocomplete state
            state.selectedPersonId = null;
            state.pendingPerson = null;
            state.contactAutocompleteOpen = false;
            state.contactAutocompleteHighlightIndex = -1;
            state.inlinePersonFormOpen = false;
            oppContactClear.classList.remove('visible');
            contactDropdown.classList.remove('open');
            inlinePersonForm.classList.remove('open');

            // Focus on name input
            setTimeout(() => oppNameInput.focus(), 100);
        }

        function closeOpportunityModal() {
            opportunityModal.classList.add('hidden');
            state.opportunityModalOpen = false;
            state.selectedPersonId = null;
            state.pendingPerson = null;
            state.contactAutocompleteOpen = false;
            state.inlinePersonFormOpen = false;
            opportunityForm.reset();
            contactDropdown.classList.remove('open');
            inlinePersonForm.classList.remove('open');
        }

        // Save opportunity
        function saveOpportunity(event) {
            event.preventDefault();

            const name = oppNameInput.value.trim();
            const description = oppDescriptionInput.value.trim();
            const startDate = oppStartDateInput.value;
            const contactName = oppContactInput.value.trim();

            if (!name) return;

            // Handle pending person creation
            let contactId = state.selectedPersonId;
            if (state.pendingPerson) {
                // Create the pending person
                const roleId = getOrCreateRole(state.pendingPerson.role);
                const newPerson = {
                    id: generateId(),
                    name: state.pendingPerson.name,
                    roleId: roleId
                };
                state.people.push(newPerson);
                contactId = newPerson.id;
            }

            const newOpportunity = {
                id: generateId(),
                name: name,
                description: description || null,
                startDate: startDate || getTodayDate(),
                contact: contactName || null,  // Keep text for display
                contactId: contactId || null,  // Link to person
                status: 'requested',  // Default status
                comments: [],
                archived: false,
                createdAt: new Date().toISOString()
            };

            state.opportunities.push(newOpportunity);
            closeOpportunityModal();
            renderOpportunities();
            renderPeople();  // Refresh people list if new person was created
        }

        // Toggle show archived opportunities
        function toggleShowArchived() {
            state.showArchived = showArchivedToggle.checked;
            renderOpportunities();
        }

        // Render opportunities list
        function renderOpportunities() {
            if (state.currentPage !== 'app' || state.currentTab !== 'opportunities') return;

            // Clear current list
            opportunityList.innerHTML = '';

            // Filter opportunities based on archived state
            const filteredOpportunities = state.opportunities.filter(opp => {
                if (state.showArchived) return true;
                return !opp.archived;
            });

            if (filteredOpportunities.length === 0) {
                // Show empty state
                opportunityList.classList.add('hidden');
                opportunityEmptyState.classList.remove('hidden');
                oppShortcutHintFloating.classList.add('hidden');
            } else {
                // Show opportunity list
                opportunityList.classList.remove('hidden');
                opportunityEmptyState.classList.add('hidden');
                oppShortcutHintFloating.classList.remove('hidden');

                filteredOpportunities.forEach((opp) => {
                    // Find original index in state.opportunities
                    const index = state.opportunities.indexOf(opp);
                    const oppItem = document.createElement('div');
                    oppItem.className = 'opportunity-item' + (opp.archived ? ' archived' : '');

                    const statusClass = `status-${opp.status}`;
                    const canClose = opp.status === 'paused';
                    const isClosedOrCancelled = opp.status === 'closed' || opp.status === 'cancelled';

                    // Build action buttons based on status
                    let actionButtons = '';
                    if (isClosedOrCancelled && !opp.archived) {
                        // Only show Archive button for closed/cancelled (not yet archived)
                        actionButtons = `
                            <button class="opp-action-btn archive-btn" onclick="event.stopPropagation(); archiveOpportunity(${index})" title="Archive Opportunity">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="21 8 21 21 3 21 3 8"></polyline>
                                    <rect x="1" y="3" width="22" height="5"></rect>
                                    <line x1="10" y1="12" x2="14" y2="12"></line>
                                </svg>
                            </button>
                        `;
                    } else if (!opp.archived) {
                        // Show normal action buttons for non-archived, non-closed/cancelled
                        actionButtons = `
                            <button class="opp-action-btn close-btn" onclick="event.stopPropagation(); closeOpportunityAction(${index})" title="${canClose ? 'Close Opportunity' : 'Only Paused opportunities can be closed'}" ${canClose ? '' : 'disabled'}>
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                            </button>
                            <button class="opp-action-btn cancel-btn" onclick="event.stopPropagation(); openCancelConfirmation(${index})" title="Cancel Opportunity">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="15" y1="9" x2="9" y2="15"></line>
                                    <line x1="9" y1="9" x2="15" y2="15"></line>
                                </svg>
                            </button>
                            <button class="opp-action-btn delete-btn" onclick="event.stopPropagation(); openDeleteConfirmation(${index})" title="Delete Opportunity">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                    <line x1="10" y1="11" x2="10" y2="17"></line>
                                    <line x1="14" y1="11" x2="14" y2="17"></line>
                                </svg>
                            </button>
                        `;
                    }
                    // No buttons for archived opportunities

                    oppItem.innerHTML = `
                        <div class="opportunity-content" onclick="openSidePanel(${index})">
                            <div class="opportunity-name">${escapeHtml(opp.name)}</div>
                            ${opp.contact ? `<div class="opportunity-contact">${escapeHtml(opp.contact)}</div>` : ''}
                        </div>
                        <span class="status-badge ${statusClass}">${capitalizeFirst(opp.status)}</span>
                        <div class="opportunity-actions">
                            ${actionButtons}
                        </div>
                    `;
                    opportunityList.appendChild(oppItem);
                });
            }
        }

        // Capitalize first letter
        function capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        // Side Panel functions
        function openSidePanel(index) {
            state.selectedOpportunityIndex = index;
            state.sidePanelOpen = true;

            const opp = state.opportunities[index];

            // Populate panel
            panelOppName.textContent = opp.name;
            panelOppDescription.textContent = opp.description || 'No description';
            panelOppDate.textContent = opp.startDate ? formatDate(opp.startDate) : 'Not set';
            // Get contact name - either from contactPersonId or legacy contact field
            let contactDisplay = 'Not set';
            if (opp.contactPersonId) {
                const person = state.people.find(p => p.id === opp.contactPersonId);
                if (person) {
                    contactDisplay = person.name;
                }
            } else if (opp.contact) {
                contactDisplay = opp.contact;
            }
            panelOppContact.textContent = contactDisplay;

            // Update status badge
            updatePanelStatusBadge(opp.status);

            // Render comments
            renderCommentsInPanel(opp);

            // Show panel
            sidePanel.classList.add('open');
            sidePanelBackdrop.classList.add('open');
        }

        function closeSidePanel() {
            state.sidePanelOpen = false;
            state.selectedOpportunityIndex = null;

            sidePanel.classList.remove('open');
            sidePanelBackdrop.classList.remove('open');
        }

        // Update status badge in side panel
        function updatePanelStatusBadge(status) {
            panelOppStatus.textContent = capitalizeFirst(status);
            panelOppStatus.className = `status-badge status-${status}`;
        }

        // Archive opportunity (for closed/cancelled opportunities)
        function archiveOpportunity(index) {
            const opp = state.opportunities[index];
            if (opp.status !== 'closed' && opp.status !== 'cancelled') return;

            opp.archived = true;

            // Close side panel if this opportunity was open
            if (state.sidePanelOpen && state.selectedOpportunityIndex === index) {
                closeSidePanel();
            }

            // Re-render opportunities list
            renderOpportunities();
        }

        // Close opportunity action (set status to Closed)
        function closeOpportunityAction(index) {
            const opp = state.opportunities[index];
            if (opp.status !== 'paused') return; // Only paused can be closed

            opp.status = 'closed';
            renderOpportunities();

            // Also update side panel if open
            if (state.sidePanelOpen && state.selectedOpportunityIndex === index) {
                updatePanelStatusBadge('closed');
            }
        }

        // Open delete confirmation modal
        function openDeleteConfirmation(index) {
            state.deleteOpportunityIndex = index;
            state.confirmModalOpen = true;

            const opp = state.opportunities[index];
            confirmMessage.textContent = `Are you sure you want to delete "${opp.name}"? This action cannot be undone.`;

            confirmModal.classList.remove('hidden');
        }

        // Close confirmation modal
        function closeConfirmModal() {
            confirmModal.classList.add('hidden');
            state.confirmModalOpen = false;
            state.deleteOpportunityIndex = null;
        }

        // Confirm and execute opportunity deletion
        function confirmDeleteOpportunity() {
            if (state.deleteOpportunityIndex === null) return;

            const oppId = state.opportunities[state.deleteOpportunityIndex].id;

            // Remove opportunity link from all associated todos
            state.todos.forEach(todo => {
                if (todo.opportunityId === oppId) {
                    todo.opportunityId = null;
                }
            });

            // Remove the opportunity
            state.opportunities.splice(state.deleteOpportunityIndex, 1);

            // Close side panel if the deleted opportunity was open
            if (state.sidePanelOpen && state.selectedOpportunityIndex === state.deleteOpportunityIndex) {
                closeSidePanel();
            } else if (state.sidePanelOpen && state.selectedOpportunityIndex > state.deleteOpportunityIndex) {
                // Adjust index if needed
                state.selectedOpportunityIndex--;
            }

            // Close confirmation modal
            closeConfirmModal();

            // Re-render both lists
            renderOpportunities();
            renderTodos();
        }

        // =============================================
        // Cancel Opportunity Functions
        // =============================================

        // Open cancel confirmation modal
        function openCancelConfirmation(index) {
            state.cancelOpportunityIndex = index;
            state.cancelModalOpen = true;

            const opp = state.opportunities[index];
            cancelOppName.textContent = `"${opp.name}"`;
            cancelReason.value = '';

            cancelModal.classList.remove('hidden');
            setTimeout(() => cancelReason.focus(), 100);
        }

        // Close cancel modal
        function closeCancelModal() {
            cancelModal.classList.add('hidden');
            state.cancelModalOpen = false;
            state.cancelOpportunityIndex = null;
            cancelReason.value = '';
        }

        // Confirm and execute opportunity cancellation
        function confirmCancelOpportunity() {
            if (state.cancelOpportunityIndex === null) return;

            const reason = cancelReason.value.trim();
            if (!reason) {
                cancelReason.focus();
                return;
            }

            const opp = state.opportunities[state.cancelOpportunityIndex];

            // Initialize comments array if not exists (for backwards compatibility)
            if (!opp.comments) {
                opp.comments = [];
            }

            // Add cancellation comment
            opp.comments.push({
                text: reason,
                timestamp: new Date().toISOString(),
                type: 'cancellation'
            });

            // Set status to cancelled
            opp.status = 'cancelled';

            // Update side panel if this opportunity is open
            if (state.sidePanelOpen && state.selectedOpportunityIndex === state.cancelOpportunityIndex) {
                updatePanelStatusBadge('cancelled');
                renderCommentsInPanel(opp);
            }

            // Close cancel modal
            closeCancelModal();

            // Re-render opportunities list
            renderOpportunities();
        }

        // Format datetime for display
        function formatDateTime(isoString) {
            const date = new Date(isoString);
            const options = {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            };
            return date.toLocaleString('en-US', options);
        }

        // Render comments in side panel
        function renderCommentsInPanel(opp) {
            // Initialize comments array if not exists
            const comments = opp.comments || [];

            if (comments.length === 0) {
                panelComments.innerHTML = '<p class="no-comments">No comments yet</p>';
                return;
            }

            panelComments.innerHTML = comments.map(comment => {
                const isCancellation = comment.type === 'cancellation';
                const badge = isCancellation ? '<span class="comment-badge cancellation">Cancellation</span>' : '';
                return `
                    <div class="comment-item ${isCancellation ? 'cancellation' : ''}">
                        <div class="comment-timestamp">${formatDateTime(comment.timestamp)}${badge}</div>
                        <div class="comment-text">${escapeHtml(comment.text)}</div>
                    </div>
                `;
            }).join('');
        }

        // Add a new comment to the current opportunity
        function addComment() {
            if (state.selectedOpportunityIndex === null) return;

            const text = commentInput.value.trim();
            if (!text) return;

            const opp = state.opportunities[state.selectedOpportunityIndex];

            // Initialize comments array if not exists
            if (!opp.comments) {
                opp.comments = [];
            }

            // Add new standard comment
            opp.comments.push({
                text: text,
                timestamp: new Date().toISOString(),
                type: 'standard'
            });

            // Clear input
            commentInput.value = '';

            // Re-render comments
            renderCommentsInPanel(opp);
        }

        // =============================================
        // Autocomplete Functions for Todo-Opportunity Linking
        // =============================================

        // Filter opportunities based on search query
        function filterOpportunities(query) {
            if (!query || query.trim() === '') return [];
            const lowerQuery = query.toLowerCase().trim();
            return state.opportunities.filter(opp =>
                opp.name.toLowerCase().includes(lowerQuery)
            );
        }

        // Render autocomplete dropdown
        function renderAutocompleteDropdown(query) {
            const matches = filterOpportunities(query);
            opportunityDropdown.innerHTML = '';

            if (matches.length > 0) {
                matches.forEach((opp, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.setAttribute('data-index', index);
                    item.setAttribute('data-id', opp.id);
                    item.innerHTML = `
                        <div class="autocomplete-item-name">${escapeHtml(opp.name)}</div>
                        ${opp.contact ? `<div class="autocomplete-item-contact">${escapeHtml(opp.contact)}</div>` : ''}
                    `;
                    item.onclick = () => selectOpportunity(opp);
                    opportunityDropdown.appendChild(item);
                });
            } else if (query && query.trim() !== '') {
                // Show hint to create new
                const hint = document.createElement('div');
                hint.className = 'autocomplete-empty';
                hint.textContent = 'No matches found';
                opportunityDropdown.appendChild(hint);

                const createHint = document.createElement('div');
                createHint.className = 'autocomplete-create-hint';
                createHint.textContent = 'Press Enter to create new opportunity';
                opportunityDropdown.appendChild(createHint);
            }

            // Update highlight
            state.autocompleteHighlightIndex = -1;
            updateAutocompleteHighlight();
        }

        // Update autocomplete item highlight
        function updateAutocompleteHighlight() {
            const items = opportunityDropdown.querySelectorAll('.autocomplete-item');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.autocompleteHighlightIndex);
            });
        }

        // Select an opportunity from dropdown
        function selectOpportunity(opp) {
            state.selectedOpportunityId = opp.id;
            state.pendingOpportunity = null;
            todoOpportunityInput.value = opp.name;
            todoOpportunityClear.classList.add('visible');
            closeAutocompleteDropdown();
            closeInlineOppForm();
        }

        // Clear opportunity selection
        function clearOpportunitySelection() {
            state.selectedOpportunityId = null;
            state.pendingOpportunity = null;
            todoOpportunityInput.value = '';
            todoOpportunityClear.classList.remove('visible');
            closeAutocompleteDropdown();
            closeInlineOppForm();
        }

        // Open autocomplete dropdown
        function openAutocompleteDropdown() {
            state.autocompleteOpen = true;
            opportunityDropdown.classList.add('open');
        }

        // Close autocomplete dropdown
        function closeAutocompleteDropdown() {
            state.autocompleteOpen = false;
            state.autocompleteHighlightIndex = -1;
            opportunityDropdown.classList.remove('open');
        }

        // Open inline opportunity form with slide animation
        function openInlineOppForm(name) {
            state.inlineOppFormOpen = true;
            inlineOppName.value = name;
            inlineOppDescription.value = '';
            inlineOppStartDate.value = getTodayDate();
            inlineOppContact.value = '';
            inlineOppForm.classList.add('open');
            closeAutocompleteDropdown();

            // Focus on description after animation
            setTimeout(() => inlineOppDescription.focus(), 350);
        }

        // Close inline opportunity form
        function closeInlineOppForm() {
            state.inlineOppFormOpen = false;
            inlineOppForm.classList.remove('open');
        }

        // Cancel inline opportunity creation
        function cancelInlineOpportunity() {
            state.pendingOpportunity = null;
            todoOpportunityInput.value = '';
            todoOpportunityClear.classList.remove('visible');
            closeInlineOppForm();
        }

        // Confirm inline opportunity creation
        function confirmInlineOpportunity() {
            const name = inlineOppName.value.trim();
            if (!name) return;

            // Store pending opportunity data (will be created when todo is saved)
            state.pendingOpportunity = {
                name: name,
                description: inlineOppDescription.value.trim(),
                startDate: inlineOppStartDate.value,
                contact: inlineOppContact.value.trim(),
                // Include person data for the contact
                contactPersonId: state.selectedInlineOppPersonId,
                pendingPerson: state.pendingInlineOppPerson
            };

            // Update UI to show it's selected
            todoOpportunityInput.value = name + ' (new)';
            todoOpportunityClear.classList.add('visible');
            closeInlineOppForm();
        }

        // Handle autocomplete input events
        todoOpportunityInput.addEventListener('input', (e) => {
            const query = e.target.value;

            // Reset selection when typing
            state.selectedOpportunityId = null;
            state.pendingOpportunity = null;

            // Show/hide clear button
            todoOpportunityClear.classList.toggle('visible', query.length > 0);

            // Close inline form if open
            if (state.inlineOppFormOpen) {
                closeInlineOppForm();
            }

            // Render and open dropdown
            if (query.trim() !== '') {
                renderAutocompleteDropdown(query);
                openAutocompleteDropdown();
            } else {
                closeAutocompleteDropdown();
            }
        });

        // Handle autocomplete keyboard navigation
        todoOpportunityInput.addEventListener('keydown', (e) => {
            const items = opportunityDropdown.querySelectorAll('.autocomplete-item');
            const matches = filterOpportunities(todoOpportunityInput.value);

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.autocompleteOpen && items.length > 0) {
                    state.autocompleteHighlightIndex = Math.min(state.autocompleteHighlightIndex + 1, items.length - 1);
                    updateAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.autocompleteOpen && items.length > 0) {
                    state.autocompleteHighlightIndex = Math.max(state.autocompleteHighlightIndex - 1, 0);
                    updateAutocompleteHighlight();
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();

                const query = todoOpportunityInput.value.trim();

                if (state.autocompleteOpen && state.autocompleteHighlightIndex >= 0 && matches.length > 0) {
                    // Select highlighted item
                    selectOpportunity(matches[state.autocompleteHighlightIndex]);
                } else if (query && matches.length === 0 && !state.inlineOppFormOpen) {
                    // No matches - open inline creation form
                    openInlineOppForm(query);
                } else if (state.autocompleteOpen && matches.length > 0 && state.autocompleteHighlightIndex === -1) {
                    // Just close dropdown if there are matches but none selected
                    closeAutocompleteDropdown();
                }
            } else if (e.key === 'Escape') {
                if (state.autocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeAutocompleteDropdown();
                }
            }
        });

        // Handle inline opportunity description Enter key - move to Contact field
        inlineOppDescription.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                // Move focus to Contact field and scroll
                inlineOppContact.focus();
                setTimeout(() => {
                    inlineOppContact.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        });

        // Handle inline opportunity name Enter key - move to Description field
        inlineOppName.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                inlineOppDescription.focus();
            }
        });

        // Handle inline opportunity start date Enter key - move to Contact field
        inlineOppStartDate.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                inlineOppContact.focus();
                setTimeout(() => {
                    inlineOppContact.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        });

        // =============================================
        // People Management Functions
        // =============================================

        // Render people list
        function renderPeople() {
            peopleList.innerHTML = '';

            if (state.people.length === 0) {
                // Show empty state
                peopleList.classList.add('hidden');
                peopleEmptyState.classList.remove('hidden');
                peopleShortcutHintFloating.classList.add('hidden');
                rolesSection.classList.add('hidden');
            } else {
                // Show people list
                peopleList.classList.remove('hidden');
                peopleEmptyState.classList.add('hidden');
                peopleShortcutHintFloating.classList.remove('hidden');

                state.people.forEach((person, index) => {
                    const personItem = document.createElement('div');
                    personItem.className = 'person-item';

                    const roleName = person.roleId ? getRoleName(person.roleId) : '';

                    personItem.innerHTML = `
                        <div class="person-info">
                            <div class="person-name">${escapeHtml(person.name)}</div>
                            ${roleName ? `<span class="person-role-badge">${escapeHtml(roleName)}</span>` : ''}
                        </div>
                        <div class="person-actions">
                            <button class="action-btn" onclick="event.stopPropagation(); openPersonModal(${index})" title="Edit">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                            <button class="action-btn action-btn-danger" onclick="event.stopPropagation(); openDeletePersonModal(${index})" title="Delete">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                            </button>
                        </div>
                    `;

                    peopleList.appendChild(personItem);
                });

                // Show roles section if there are roles
                if (state.roles.length > 0) {
                    rolesSection.classList.remove('hidden');
                    renderRoles();
                } else {
                    rolesSection.classList.add('hidden');
                }
            }

            saveData();
        }

        // Render roles list
        function renderRoles() {
            rolesList.innerHTML = '';
            state.roles.forEach(role => {
                const roleTag = document.createElement('span');
                roleTag.className = 'role-tag';
                roleTag.textContent = role.name;
                rolesList.appendChild(roleTag);
            });
        }

        // Get role name by ID
        function getRoleName(roleId) {
            const role = state.roles.find(r => r.id === roleId);
            return role ? role.name : '';
        }

        // Get or create role by name
        function getOrCreateRole(roleName) {
            if (!roleName || roleName.trim() === '') return null;
            const trimmedName = roleName.trim();
            const existingRole = state.roles.find(r => r.name.toLowerCase() === trimmedName.toLowerCase());
            if (existingRole) return existingRole.id;

            // Create new role
            const newRole = {
                id: generateId(),
                name: trimmedName
            };
            state.roles.push(newRole);
            return newRole.id;
        }

        // Open person modal
        function openPersonModal(personIndex = null) {
            state.personModalOpen = true;
            state.editingPersonIndex = personIndex;
            state.roleAutocompleteOpen = false;
            state.roleAutocompleteHighlightIndex = -1;

            personRoleInput.value = '';
            personRoleClear.classList.remove('visible');
            roleDropdown.classList.remove('open');

            if (personIndex !== null) {
                // Edit mode
                const person = state.people[personIndex];
                personModalTitle.textContent = 'Edit Person';
                personNameInput.value = person.name;
                if (person.roleId) {
                    personRoleInput.value = getRoleName(person.roleId);
                    personRoleClear.classList.add('visible');
                }
            } else {
                // Create mode
                personModalTitle.textContent = 'New Person';
                personNameInput.value = '';
            }

            personModal.classList.remove('hidden');
            setTimeout(() => personNameInput.focus(), 100);
        }

        // Close person modal
        function closePersonModal() {
            state.personModalOpen = false;
            state.editingPersonIndex = null;
            state.roleAutocompleteOpen = false;
            personModal.classList.add('hidden');
            personForm.reset();
            roleDropdown.classList.remove('open');
        }

        // Save person
        function savePerson(e) {
            e.preventDefault();

            const name = personNameInput.value.trim();
            if (!name) return;

            const roleName = personRoleInput.value.trim();
            const roleId = getOrCreateRole(roleName);

            if (state.editingPersonIndex !== null) {
                // Update existing person
                state.people[state.editingPersonIndex].name = name;
                state.people[state.editingPersonIndex].roleId = roleId;
            } else {
                // Create new person
                const newPerson = {
                    id: generateId(),
                    name: name,
                    roleId: roleId
                };
                state.people.push(newPerson);
            }

            closePersonModal();
            renderPeople();
        }

        // Open delete person modal
        function openDeletePersonModal(index) {
            state.deletePersonIndex = index;
            const person = state.people[index];
            deletePersonName.textContent = person.name;
            deletePersonModal.classList.remove('hidden');
        }

        // Close delete person modal
        function closeDeletePersonModal() {
            state.deletePersonIndex = null;
            deletePersonModal.classList.add('hidden');
        }

        // Confirm delete person
        function confirmDeletePerson() {
            if (state.deletePersonIndex !== null) {
                const personId = state.people[state.deletePersonIndex].id;

                // Remove person from array
                state.people.splice(state.deletePersonIndex, 1);

                // Update opportunities that referenced this person
                state.opportunities.forEach(opp => {
                    if (opp.contactId === personId) {
                        opp.contactId = null;
                        opp.contact = ''; // Clear the text contact as well
                    }
                });

                closeDeletePersonModal();
                renderPeople();
                renderOpportunities();
            }
        }

        // Clear person role input
        function clearPersonRole() {
            personRoleInput.value = '';
            personRoleClear.classList.remove('visible');
            roleDropdown.classList.remove('open');
            state.roleAutocompleteOpen = false;
        }

        // Filter roles based on search query
        function filterRoles(query) {
            if (!query || query.trim() === '') return [];
            const lowerQuery = query.toLowerCase().trim();
            return state.roles.filter(role =>
                role.name.toLowerCase().includes(lowerQuery)
            );
        }

        // Render role autocomplete dropdown
        function renderRoleDropdown(query) {
            const matches = filterRoles(query);
            roleDropdown.innerHTML = '';

            if (matches.length > 0) {
                matches.forEach((role, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.setAttribute('data-index', index);
                    item.setAttribute('data-id', role.id);
                    item.innerHTML = `<div class="autocomplete-item-name">${escapeHtml(role.name)}</div>`;
                    item.onclick = () => selectRole(role);
                    roleDropdown.appendChild(item);
                });
            } else if (query && query.trim() !== '') {
                // Show create option
                const createItem = document.createElement('div');
                createItem.className = 'autocomplete-item autocomplete-create';
                createItem.innerHTML = `
                    <div class="autocomplete-item-name">Create "${escapeHtml(query.trim())}"</div>
                `;
                createItem.onclick = () => {
                    personRoleInput.value = query.trim();
                    personRoleClear.classList.add('visible');
                    closeRoleDropdown();
                };
                roleDropdown.appendChild(createItem);
            }

            state.roleAutocompleteHighlightIndex = -1;
            updateRoleAutocompleteHighlight();
        }

        // Update role autocomplete highlight
        function updateRoleAutocompleteHighlight() {
            const items = roleDropdown.querySelectorAll('.autocomplete-item');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.roleAutocompleteHighlightIndex);
            });
        }

        // Select role from autocomplete
        function selectRole(role) {
            personRoleInput.value = role.name;
            personRoleClear.classList.add('visible');
            closeRoleDropdown();
        }

        // Open role dropdown
        function openRoleDropdown() {
            state.roleAutocompleteOpen = true;
            roleDropdown.classList.add('open');
        }

        // Close role dropdown
        function closeRoleDropdown() {
            state.roleAutocompleteOpen = false;
            roleDropdown.classList.remove('open');
            state.roleAutocompleteHighlightIndex = -1;
        }

        // Person role input event handlers
        personRoleInput.addEventListener('input', (e) => {
            const query = e.target.value;

            // Show/hide clear button
            personRoleClear.classList.toggle('visible', query.length > 0);

            // Render and open dropdown
            if (query.trim() !== '') {
                renderRoleDropdown(query);
                openRoleDropdown();
            } else {
                closeRoleDropdown();
            }
        });

        personRoleInput.addEventListener('focus', () => {
            const query = personRoleInput.value;
            if (query.trim() !== '') {
                renderRoleDropdown(query);
                openRoleDropdown();
            }
        });

        personRoleInput.addEventListener('keydown', (e) => {
            const items = roleDropdown.querySelectorAll('.autocomplete-item');
            const matches = filterRoles(personRoleInput.value);

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.roleAutocompleteOpen && items.length > 0) {
                    state.roleAutocompleteHighlightIndex = Math.min(state.roleAutocompleteHighlightIndex + 1, items.length - 1);
                    updateRoleAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.roleAutocompleteOpen && items.length > 0) {
                    state.roleAutocompleteHighlightIndex = Math.max(state.roleAutocompleteHighlightIndex - 1, 0);
                    updateRoleAutocompleteHighlight();
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();
                const query = personRoleInput.value.trim();

                if (state.roleAutocompleteOpen && state.roleAutocompleteHighlightIndex >= 0 && matches.length > 0) {
                    // Select highlighted item
                    selectRole(matches[state.roleAutocompleteHighlightIndex]);
                } else if (query) {
                    // Just accept the typed value
                    personRoleClear.classList.add('visible');
                    closeRoleDropdown();
                }
            } else if (e.key === 'Escape') {
                if (state.roleAutocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeRoleDropdown();
                }
            }
        });

        // =============================================
        // Contact Autocomplete Functions (Opportunity Modal)
        // =============================================

        // Filter people based on search query
        function filterPeople(query) {
            if (!query || query.trim() === '') return [];
            const lowerQuery = query.toLowerCase().trim();
            return state.people.filter(person =>
                person.name.toLowerCase().includes(lowerQuery)
            );
        }

        // Render contact autocomplete dropdown
        function renderContactDropdown(query) {
            const matches = filterPeople(query);
            contactDropdown.innerHTML = '';

            if (matches.length > 0) {
                matches.forEach((person, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.setAttribute('data-index', index);
                    item.setAttribute('data-id', person.id);
                    const roleName = person.roleId ? getRoleName(person.roleId) : '';
                    item.innerHTML = `
                        <div class="autocomplete-item-name">${escapeHtml(person.name)}</div>
                        ${roleName ? `<div class="autocomplete-item-contact">${escapeHtml(roleName)}</div>` : ''}
                    `;
                    item.onclick = () => selectContact(person);
                    contactDropdown.appendChild(item);
                });
            } else if (query && query.trim() !== '') {
                // Show create option
                const createItem = document.createElement('div');
                createItem.className = 'autocomplete-item autocomplete-create';
                createItem.innerHTML = `
                    <div class="autocomplete-item-name">Create "${escapeHtml(query.trim())}" - press Enter</div>
                `;
                createItem.onclick = () => openInlinePersonForm(query.trim());
                contactDropdown.appendChild(createItem);
            }

            state.contactAutocompleteHighlightIndex = -1;
            updateContactAutocompleteHighlight();
        }

        // Update contact autocomplete highlight
        function updateContactAutocompleteHighlight() {
            const items = contactDropdown.querySelectorAll('.autocomplete-item');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.contactAutocompleteHighlightIndex);
            });
        }

        // Select contact from autocomplete
        function selectContact(person) {
            state.selectedPersonId = person.id;
            state.pendingPerson = null;
            oppContactInput.value = person.name;
            oppContactClear.classList.add('visible');
            closeContactDropdown();
            closeInlinePersonForm();
        }

        // Open contact dropdown
        function openContactDropdown() {
            state.contactAutocompleteOpen = true;
            contactDropdown.classList.add('open');
        }

        // Close contact dropdown
        function closeContactDropdown() {
            state.contactAutocompleteOpen = false;
            contactDropdown.classList.remove('open');
            state.contactAutocompleteHighlightIndex = -1;
        }

        // Clear opportunity contact input
        function clearOppContact() {
            state.selectedPersonId = null;
            state.pendingPerson = null;
            oppContactInput.value = '';
            oppContactClear.classList.remove('visible');
            closeContactDropdown();
            closeInlinePersonForm();
        }

        // Open inline person form
        function openInlinePersonForm(name) {
            state.inlinePersonFormOpen = true;
            inlinePersonName.value = name;
            inlinePersonRole.value = '';
            inlinePersonForm.classList.add('open');
            closeContactDropdown();

            // Focus on role after animation
            setTimeout(() => inlinePersonRole.focus(), 350);
        }

        // Close inline person form
        function closeInlinePersonForm() {
            state.inlinePersonFormOpen = false;
            inlinePersonForm.classList.remove('open');
        }

        // Cancel inline person creation
        function cancelInlinePerson() {
            state.pendingPerson = null;
            oppContactInput.value = '';
            oppContactClear.classList.remove('visible');
            closeInlinePersonForm();
        }

        // Confirm inline person creation
        function confirmInlinePerson() {
            const name = inlinePersonName.value.trim();
            const role = inlinePersonRole.value.trim();

            if (!name) {
                inlinePersonName.focus();
                return;
            }

            // Store as pending person
            state.pendingPerson = { name, role };
            state.selectedPersonId = null;

            // Update the contact input to show the name
            oppContactInput.value = name;
            oppContactClear.classList.add('visible');

            closeInlinePersonForm();
        }

        // ============================================
        // Inline Person Creation within Inline Opportunity (Todo Modal)
        // ============================================

        // Render inline opp contact dropdown
        function renderInlineOppContactDropdown(query) {
            const matches = filterPeople(query);
            inlineOppContactDropdown.innerHTML = '';

            if (matches.length === 0) {
                const item = document.createElement('div');
                item.className = 'autocomplete-item autocomplete-no-match';
                item.textContent = `Press Enter to create "${query}"`;
                inlineOppContactDropdown.appendChild(item);
            } else {
                matches.forEach((person, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.dataset.index = index;

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'autocomplete-item-name';
                    nameSpan.textContent = person.name;
                    item.appendChild(nameSpan);

                    if (person.roleId) {
                        const role = state.roles.find(r => r.id === person.roleId);
                        if (role) {
                            const roleSpan = document.createElement('span');
                            roleSpan.className = 'autocomplete-item-role';
                            roleSpan.textContent = role.name;
                            item.appendChild(roleSpan);
                        }
                    }

                    item.addEventListener('click', () => selectInlineOppContact(person));
                    inlineOppContactDropdown.appendChild(item);
                });
            }
        }

        // Open inline opp contact dropdown
        function openInlineOppContactDropdown() {
            state.inlineOppContactAutocompleteOpen = true;
            state.inlineOppContactAutocompleteHighlightIndex = -1;
            inlineOppContactDropdown.classList.add('open');
        }

        // Close inline opp contact dropdown
        function closeInlineOppContactDropdown() {
            state.inlineOppContactAutocompleteOpen = false;
            state.inlineOppContactAutocompleteHighlightIndex = -1;
            inlineOppContactDropdown.classList.remove('open');
        }

        // Select contact for inline opportunity
        function selectInlineOppContact(person) {
            state.selectedInlineOppPersonId = person.id;
            state.pendingInlineOppPerson = null;
            inlineOppContact.value = person.name;
            inlineOppContactClear.classList.add('visible');
            closeInlineOppContactDropdown();
            closeInlineOppPersonForm();
        }

        // Clear inline opp contact selection
        function clearInlineOppContact() {
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;
            inlineOppContact.value = '';
            inlineOppContactClear.classList.remove('visible');
            closeInlineOppContactDropdown();
            closeInlineOppPersonForm();
        }

        // Open inline person form within inline opportunity
        function openInlineOppPersonForm(name) {
            state.inlineOppPersonFormOpen = true;
            inlineOppPersonName.value = name;
            inlineOppPersonRole.value = '';
            inlineOppPersonForm.classList.add('open');
            closeInlineOppContactDropdown();

            // Scroll to make the form visible
            setTimeout(() => {
                inlineOppPersonRole.focus();
                inlineOppPersonForm.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 350);
        }

        // Close inline person form within inline opportunity
        function closeInlineOppPersonForm() {
            state.inlineOppPersonFormOpen = false;
            inlineOppPersonForm.classList.remove('open');
        }

        // Cancel inline person creation within inline opportunity
        function cancelInlineOppPerson() {
            state.pendingInlineOppPerson = null;
            inlineOppContact.value = '';
            inlineOppContactClear.classList.remove('visible');
            closeInlineOppPersonForm();
        }

        // Confirm inline person creation within inline opportunity
        function confirmInlineOppPerson() {
            const name = inlineOppPersonName.value.trim();
            const role = inlineOppPersonRole.value.trim();

            if (!name) {
                inlineOppPersonName.focus();
                return;
            }

            // Store as pending person for inline opportunity
            state.pendingInlineOppPerson = { name, role };
            state.selectedInlineOppPersonId = null;

            // Update the contact input to show the name
            inlineOppContact.value = name;
            inlineOppContactClear.classList.add('visible');

            closeInlineOppPersonForm();
        }

        // Update autocomplete highlight for inline opp contact
        function updateInlineOppContactAutocompleteHighlight() {
            const items = inlineOppContactDropdown.querySelectorAll('.autocomplete-item:not(.autocomplete-no-match)');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.inlineOppContactAutocompleteHighlightIndex);
            });
        }

        // Inline opp contact input event handlers
        inlineOppContact.addEventListener('input', (e) => {
            const query = e.target.value;

            // Clear selected person if user types
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;

            // Show/hide clear button
            inlineOppContactClear.classList.toggle('visible', query.length > 0);

            // Close inline form if open
            if (state.inlineOppPersonFormOpen) {
                closeInlineOppPersonForm();
            }

            // Render and open dropdown
            if (query.trim() !== '') {
                renderInlineOppContactDropdown(query);
                openInlineOppContactDropdown();
            } else {
                closeInlineOppContactDropdown();
            }
        });

        inlineOppContact.addEventListener('focus', (e) => {
            const query = inlineOppContact.value;
            if (query.trim() !== '' && !state.selectedInlineOppPersonId && !state.pendingInlineOppPerson) {
                renderInlineOppContactDropdown(query);
                openInlineOppContactDropdown();
            }
            // Scroll to make contact field visible
            setTimeout(() => {
                inlineOppContact.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
        });

        inlineOppContact.addEventListener('keydown', (e) => {
            const items = inlineOppContactDropdown.querySelectorAll('.autocomplete-item:not(.autocomplete-no-match)');
            const matches = filterPeople(inlineOppContact.value);

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.inlineOppContactAutocompleteOpen && items.length > 0) {
                    state.inlineOppContactAutocompleteHighlightIndex = Math.min(state.inlineOppContactAutocompleteHighlightIndex + 1, items.length - 1);
                    updateInlineOppContactAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.inlineOppContactAutocompleteOpen && items.length > 0) {
                    state.inlineOppContactAutocompleteHighlightIndex = Math.max(state.inlineOppContactAutocompleteHighlightIndex - 1, 0);
                    updateInlineOppContactAutocompleteHighlight();
                }
            } else if (e.key === 'Tab') {
                // Tab key - if there's a query, open person form and focus role
                const query = inlineOppContact.value.trim();
                if (query && !state.inlineOppPersonFormOpen && !state.selectedInlineOppPersonId && !state.pendingInlineOppPerson) {
                    e.preventDefault();
                    openInlineOppPersonForm(query);
                }
                // If person form is already open, Tab will naturally move to role field
            } else if (e.key === 'Enter') {
                e.preventDefault();
                const query = inlineOppContact.value.trim();

                if (state.inlineOppContactAutocompleteOpen && state.inlineOppContactAutocompleteHighlightIndex >= 0 && matches.length > 0) {
                    // Select highlighted item
                    selectInlineOppContact(matches[state.inlineOppContactAutocompleteHighlightIndex]);
                } else if (query && !state.inlineOppPersonFormOpen && !state.selectedInlineOppPersonId && !state.pendingInlineOppPerson) {
                    // Has query but no selection - open inline creation form for new person
                    openInlineOppPersonForm(query);
                } else if (state.inlineOppContactAutocompleteOpen) {
                    // Just close dropdown
                    closeInlineOppContactDropdown();
                }
            } else if (e.key === 'Escape') {
                if (state.inlineOppContactAutocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeInlineOppContactDropdown();
                }
            }
        });

        // Handle inline opp person form Enter key - confirm person AND opportunity
        inlineOppPersonForm.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target.tagName === 'INPUT') {
                e.preventDefault();
                // First confirm the person
                confirmInlineOppPerson();
                // Then confirm the opportunity (which will include the person)
                confirmInlineOpportunity();
            }
        });

        // Contact input event handlers
        oppContactInput.addEventListener('input', (e) => {
            const query = e.target.value;

            // Clear selected person if user types
            state.selectedPersonId = null;
            state.pendingPerson = null;

            // Show/hide clear button
            oppContactClear.classList.toggle('visible', query.length > 0);

            // Close inline form if open
            if (state.inlinePersonFormOpen) {
                closeInlinePersonForm();
            }

            // Render and open dropdown
            if (query.trim() !== '') {
                renderContactDropdown(query);
                openContactDropdown();
            } else {
                closeContactDropdown();
            }
        });

        oppContactInput.addEventListener('focus', () => {
            const query = oppContactInput.value;
            if (query.trim() !== '' && !state.selectedPersonId && !state.pendingPerson) {
                renderContactDropdown(query);
                openContactDropdown();
            }
        });

        oppContactInput.addEventListener('keydown', (e) => {
            const items = contactDropdown.querySelectorAll('.autocomplete-item');
            const matches = filterPeople(oppContactInput.value);

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.contactAutocompleteOpen && items.length > 0) {
                    state.contactAutocompleteHighlightIndex = Math.min(state.contactAutocompleteHighlightIndex + 1, items.length - 1);
                    updateContactAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.contactAutocompleteOpen && items.length > 0) {
                    state.contactAutocompleteHighlightIndex = Math.max(state.contactAutocompleteHighlightIndex - 1, 0);
                    updateContactAutocompleteHighlight();
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();
                const query = oppContactInput.value.trim();

                if (state.contactAutocompleteOpen && state.contactAutocompleteHighlightIndex >= 0 && matches.length > 0) {
                    // Select highlighted item
                    selectContact(matches[state.contactAutocompleteHighlightIndex]);
                } else if (query && matches.length === 0 && !state.inlinePersonFormOpen) {
                    // No matches - open inline creation form
                    openInlinePersonForm(query);
                } else if (state.contactAutocompleteOpen && matches.length > 0 && state.contactAutocompleteHighlightIndex === -1) {
                    // Just close dropdown if there are matches but none selected
                    closeContactDropdown();
                }
            } else if (e.key === 'Escape') {
                if (state.contactAutocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeContactDropdown();
                }
            }
        });

        // Handle inline person form Enter key
        inlinePersonForm.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target.tagName === 'INPUT') {
                e.preventDefault();
                confirmInlinePerson();
            }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.autocomplete-wrapper') && state.autocompleteOpen) {
                closeAutocompleteDropdown();
            }
            if (!e.target.closest('.autocomplete-wrapper') && state.contactAutocompleteOpen) {
                closeContactDropdown();
            }
            if (!e.target.closest('.autocomplete-wrapper') && state.roleAutocompleteOpen) {
                closeRoleDropdown();
            }
            if (!e.target.closest('.autocomplete-wrapper') && state.inlineOppContactAutocompleteOpen) {
                closeInlineOppContactDropdown();
            }
        });

        // Add keyboard navigation (capture phase to intercept browser shortcuts)
        document.addEventListener('keydown', (e) => {
            // Skip if any modal is open and it's not Escape
            const anyModalOpen = state.modalOpen || state.opportunityModalOpen || state.personModalOpen;

            // Handle Shift+N to open todo modal (only on home tab)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'home' && !anyModalOpen) {
                e.preventDefault();
                openModal();
                return;
            }

            // Handle Shift+N to open opportunity modal (only on opportunities tab)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'opportunities' && !anyModalOpen) {
                e.preventDefault();
                openOpportunityModal();
                return;
            }

            // Handle Shift+N to open person modal (only on settings page with people section)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'settings' && state.settingsSection === 'people' && !anyModalOpen) {
                e.preventDefault();
                openPersonModal();
                return;
            }

            // Handle Escape key to close modals or side panel
            if (e.key === 'Escape') {
                if (state.cancelModalOpen) {
                    e.preventDefault();
                    closeCancelModal();
                    return;
                }
                if (state.confirmModalOpen) {
                    e.preventDefault();
                    closeConfirmModal();
                    return;
                }
                if (state.modalOpen) {
                    e.preventDefault();
                    closeModal();
                    return;
                }
                if (state.opportunityModalOpen) {
                    e.preventDefault();
                    closeOpportunityModal();
                    return;
                }
                if (state.personModalOpen) {
                    e.preventDefault();
                    closePersonModal();
                    return;
                }
                if (state.deletePersonIndex !== null) {
                    e.preventDefault();
                    closeDeletePersonModal();
                    return;
                }
                if (state.sidePanelOpen) {
                    e.preventDefault();
                    closeSidePanel();
                    return;
                }
            }

            // Landing page keyboard shortcuts
            if (state.currentPage === 'landing') {
                if (e.key === '1') {
                    startFromScratch();
                } else if (e.key === '2') {
                    continueWorking();
                }
            }
        }, true);  // Use capture phase to intercept before browser handles it

        // Migrate existing contacts to people
        function migrateContactsToPeople() {
            // Get all unique contacts from opportunities that don't have a contactId
            const contactsToMigrate = new Map();

            state.opportunities.forEach(opp => {
                if (opp.contact && !opp.contactId) {
                    const normalizedContact = opp.contact.trim().toLowerCase();
                    if (!contactsToMigrate.has(normalizedContact)) {
                        contactsToMigrate.set(normalizedContact, opp.contact.trim());
                    }
                }
            });

            // Create people for unique contacts
            contactsToMigrate.forEach((originalName, normalizedName) => {
                // Check if person already exists
                const existingPerson = state.people.find(p => p.name.toLowerCase() === normalizedName);
                if (!existingPerson) {
                    const newPerson = {
                        id: generateId(),
                        name: originalName,
                        roleId: null
                    };
                    state.people.push(newPerson);
                }
            });

            // Update opportunities to reference the person
            state.opportunities.forEach(opp => {
                if (opp.contact && !opp.contactId) {
                    const normalizedContact = opp.contact.trim().toLowerCase();
                    const person = state.people.find(p => p.name.toLowerCase() === normalizedContact);
                    if (person) {
                        opp.contactId = person.id;
                    }
                }
            });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Run migration on startup
            migrateContactsToPeople();
            navigateTo('landing');
        });
    </script>
</body>
</html>
