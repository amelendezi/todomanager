<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TodoManager - Manage Your Tasks Efficiently</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #F5F5F5 0%, #E8E8E8 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
            overflow-x: hidden;
        }

        .container {
            max-width: 600px;
            width: 100%;
            text-align: center;
            animation: fadeIn 0.6s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .logo-container {
            margin-bottom: 48px;
            animation: slideDown 0.8s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .logo {
            width: 120px;
            height: 120px;
            margin: 0 auto 24px;
            filter: drop-shadow(0 4px 12px rgba(255, 184, 0, 0.3));
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        .logo:hover {
            animation: float 3s ease-in-out infinite, pulse 0.6s ease;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        h1 {
            font-size: 48px;
            font-weight: 700;
            color: #1F1F1F;
            margin-bottom: 16px;
            letter-spacing: -1px;
        }

        .tagline {
            font-size: 18px;
            color: #6C757D;
            margin-bottom: 64px;
            font-weight: 400;
        }

        .options-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-bottom: 32px;
        }

        .option-card {
            background: white;
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid transparent;
            animation: slideUp 0.6s ease;
            animation-fill-mode: both;
        }

        .option-card:nth-child(1) {
            animation-delay: 0.2s;
        }

        .option-card:nth-child(2) {
            animation-delay: 0.3s;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .option-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            border-color: #FFB800;
        }

        .option-card:active {
            transform: translateY(-2px) scale(1.01);
        }

        .option-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            background: linear-gradient(135deg, #FFB800 0%, #FFA000 100%);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .option-card:hover .option-icon {
            transform: rotate(5deg) scale(1.1);
            box-shadow: 0 4px 16px rgba(255, 184, 0, 0.4);
        }

        .option-icon svg {
            width: 36px;
            height: 36px;
            color: #1F1F1F;
        }

        .option-title {
            font-size: 24px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 8px;
        }

        .option-description {
            font-size: 14px;
            color: #6C757D;
            line-height: 1.5;
        }

        .footer {
            margin-top: 48px;
            font-size: 14px;
            color: #ADB5BD;
            animation: fadeIn 0.8s ease 0.5s both;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 36px;
            }

            .tagline {
                font-size: 16px;
                margin-bottom: 48px;
            }

            .logo {
                width: 100px;
                height: 100px;
            }

            .option-card {
                padding: 24px;
            }

            .option-title {
                font-size: 20px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Page visibility */
        .hidden {
            display: none !important;
        }

        .page {
            min-height: 100vh;
            width: 100%;
        }

        /* Header styles */
        .header {
            height: 60px;
            background: #FFFFFF;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 24px;
        }

        .header-title {
            font-size: 16px;
            font-weight: 500;
            color: #1F1F1F;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: 4px;
        }

        .tab-btn {
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            color: #6C757D;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tab-btn:hover {
            color: #1F1F1F;
            background: #F8F9FA;
        }

        .tab-btn.active {
            color: #1F1F1F;
            background: #FFB800;
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .icon-button {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }

        .icon-button:hover {
            background: #F8F9FA;
        }

        .icon-button:active {
            transform: scale(0.95);
        }

        .icon-button svg {
            width: 24px;
            height: 24px;
            color: #6C757D;
            transition: color 0.2s ease, transform 0.3s ease;
        }

        .icon-button:hover svg {
            color: #1F1F1F;
        }

        /* Settings icon rotation on hover */
        .icon-button[title="Settings"]:hover svg {
            transform: rotate(90deg);
        }

        /* Main content area */
        .main-content {
            padding-top: 84px;
            padding-left: 24px;
            padding-right: 24px;
            padding-bottom: 24px;
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Todo list styles */
        .todo-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .todo-item {
            background: #FFFFFF;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s ease;
        }

        .todo-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translateY(-2px);
        }

        .todo-checkbox {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #E0E0E0;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.2s ease;
        }

        .todo-checkbox.checked {
            background: #00A86B;
            border-color: #00A86B;
        }

        .todo-content {
            flex: 1;
        }

        .todo-title {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
        }

        /* Empty state styles */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 64px 24px;
            animation: fadeIn 0.5s ease;
        }

        .empty-icon {
            width: 64px;
            height: 64px;
            color: #ADB5BD;
            margin-bottom: 16px;
        }

        .empty-text {
            font-size: 16px;
            font-weight: 500;
            color: #ADB5BD;
        }

        /* Keyboard shortcut hint text */
        .shortcut-hint {
            font-size: 13px;
            font-style: italic;
            color: #ADB5BD;
            margin-top: 12px;
        }

        .shortcut-hint-floating {
            font-size: 12px;
            font-style: italic;
            color: #ADB5BD;
            text-align: center;
            padding: 8px 0;
            margin-bottom: 8px;
        }

        /* Home page body override */
        #home-page {
            background: #F5F5F5;
        }

        /* Responsive styles for home page */
        @media (max-width: 768px) {
            .header {
                padding: 0 16px;
            }

            .main-content {
                padding-left: 16px;
                padding-right: 16px;
            }
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            position: relative;
            background: #FFFFFF;
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 480px;
            max-height: calc(100vh - 48px);
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            animation: modalSlideIn 0.3s ease;
            transform-origin: center center;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 24px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 8px;
        }

        .form-label .required {
            color: #DC3545;
        }

        .form-input {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .form-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .form-input::placeholder {
            color: #ADB5BD;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 24px;
        }

        .btn {
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .btn-primary {
            background: #FFB800;
            color: #1F1F1F;
        }

        .btn-primary:hover {
            background: #E5A600;
            transform: scale(1.02);
        }

        .btn-secondary {
            background: #F8F9FA;
            color: #6C757D;
        }

        .btn-secondary:hover {
            background: #E9ECEF;
        }

        /* Todo item with due date */
        .todo-due-date {
            font-size: 12px;
            color: #6C757D;
            margin-top: 4px;
        }

        .todo-due-date.overdue {
            color: #DC3545;
        }

        .todo-item.completed .todo-title {
            text-decoration: line-through;
            color: #ADB5BD;
        }

        /* Checkmark icon inside checkbox */
        .todo-checkbox.checked::after {
            content: '';
            display: block;
            width: 8px;
            height: 5px;
            border-left: 2px solid #FFFFFF;
            border-bottom: 2px solid #FFFFFF;
            transform: rotate(-45deg);
            margin: 6px auto;
        }

        /* Todo actions (edit button) */
        .todo-actions {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: auto;
        }

        .todo-edit-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
            flex-shrink: 0;
        }

        .todo-edit-btn:hover {
            background: #F0F0F0;
        }

        .todo-edit-btn svg {
            width: 18px;
            height: 18px;
            color: #6C757D;
            transition: color 0.2s ease;
        }

        .todo-edit-btn:hover svg {
            color: #1F1F1F;
        }

        /* Modal responsive */
        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                padding: 20px;
            }

            .modal-actions {
                flex-direction: column-reverse;
            }

            .btn {
                width: 100%;
            }
        }

        /* Opportunity list styles */
        .opportunity-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .opportunity-item {
            background: #FFFFFF;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            align-items: center;
            gap: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .opportunity-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translateY(-2px);
        }

        .opportunity-content {
            flex: 1;
            min-width: 0;
        }

        .opportunity-name {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 4px;
        }

        .opportunity-contact {
            font-size: 12px;
            color: #6C757D;
        }

        /* Status badges */
        .status-badge {
            padding: 4px 12px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 16px;
            white-space: nowrap;
        }

        .status-requested {
            background: #E3F2FD;
            color: #1976D2;
        }

        .status-open {
            background: #E8F5E9;
            color: #388E3C;
        }

        .status-paused {
            background: #FFF3E0;
            color: #F57C00;
        }

        .status-cancelled {
            background: #FFEBEE;
            color: #D32F2F;
        }

        .status-closed {
            background: #F3E5F5;
            color: #7B1FA2;
        }

        /* Side Panel */
        .side-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 400px;
            max-width: 100%;
            height: 100vh;
            background: #FFFFFF;
            box-shadow: -4px 0 24px rgba(0, 0, 0, 0.15);
            z-index: 200;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .side-panel.open {
            transform: translateX(0);
        }

        .side-panel-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 199;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .side-panel-backdrop.open {
            opacity: 1;
            visibility: visible;
        }

        .side-panel-header {
            padding: 20px 24px;
            border-bottom: 1px solid #E0E0E0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .side-panel-title {
            font-size: 18px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .side-panel-close {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }

        .side-panel-close:hover {
            background: #F8F9FA;
        }

        .side-panel-close svg {
            width: 20px;
            height: 20px;
            color: #6C757D;
        }

        .side-panel-body {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
        }

        .detail-group {
            margin-bottom: 20px;
        }

        .detail-label {
            font-size: 12px;
            font-weight: 500;
            color: #6C757D;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .detail-value {
            font-size: 14px;
            color: #1F1F1F;
        }

        .detail-select {
            width: 100%;
            height: 40px;
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            cursor: pointer;
            transition: border-color 0.2s ease;
        }

        .detail-select:focus {
            outline: none;
            border-color: #FFB800;
        }

        /* Responsive side panel */
        @media (max-width: 768px) {
            .side-panel {
                width: 100%;
            }
        }

        /* Autocomplete styles */
        .autocomplete-wrapper {
            position: relative;
        }

        .autocomplete-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .autocomplete-input {
            width: 100%;
            height: 48px;
            padding: 12px 40px 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .autocomplete-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .autocomplete-input::placeholder {
            color: #ADB5BD;
        }

        .autocomplete-clear {
            position: absolute;
            right: 12px;
            width: 20px;
            height: 20px;
            border: none;
            background: #E0E0E0;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease, background-color 0.2s ease;
        }

        .autocomplete-clear.visible {
            opacity: 1;
        }

        .autocomplete-clear:hover {
            background: #D0D0D0;
        }

        .autocomplete-clear svg {
            width: 12px;
            height: 12px;
            color: #6C757D;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 4px;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-height: 200px;
            overflow-y: auto;
            z-index: 10;
            display: none;
        }

        .autocomplete-dropdown.open {
            display: block;
        }

        .autocomplete-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.15s ease;
            font-size: 14px;
            color: #1F1F1F;
        }

        .autocomplete-item:hover,
        .autocomplete-item.highlighted {
            background: #F8F9FA;
        }

        .autocomplete-item-name {
            font-weight: 500;
        }

        .autocomplete-item-contact {
            font-size: 12px;
            color: #6C757D;
            margin-top: 2px;
        }

        .autocomplete-empty {
            padding: 12px 16px;
            font-size: 14px;
            color: #6C757D;
            font-style: italic;
        }

        .autocomplete-create-hint {
            padding: 8px 16px;
            font-size: 12px;
            color: #6C757D;
            background: #F8F9FA;
            border-top: 1px solid #E0E0E0;
        }

        /* Inline opportunity creation form */
        .inline-opp-form {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
            background: #F8F9FA;
            border-radius: 8px;
            margin-top: 0;
            padding: 0 16px;
        }

        .inline-opp-form.open {
            max-height: 300px;
            padding: 16px;
            margin-top: 12px;
        }

        .inline-opp-form .form-group {
            margin-bottom: 12px;
        }

        .inline-opp-form .form-group:last-child {
            margin-bottom: 0;
        }

        .inline-opp-form .form-label {
            font-size: 12px;
            margin-bottom: 4px;
        }

        .inline-opp-form .form-input {
            height: 40px;
            padding: 8px 12px;
            font-size: 13px;
        }

        .inline-opp-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .inline-opp-title {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .inline-opp-actions {
            display: flex;
            gap: 8px;
        }

        .inline-opp-actions .btn {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Todo opportunity badge */
        .todo-opportunity {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 500;
            color: #1976D2;
            background: #E3F2FD;
            border-radius: 12px;
            margin-top: 4px;
        }

        .todo-opportunity svg {
            width: 12px;
            height: 12px;
        }

        /* Opportunity action buttons */
        .opportunity-actions {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: 8px;
        }

        .opp-action-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease, opacity 0.2s ease;
            flex-shrink: 0;
        }

        .opp-action-btn:hover:not(:disabled) {
            background: #F0F0F0;
        }

        .opp-action-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .opp-action-btn svg {
            width: 18px;
            height: 18px;
            color: #6C757D;
            transition: color 0.2s ease;
        }

        .opp-action-btn:hover:not(:disabled) svg {
            color: #1F1F1F;
        }

        .opp-action-btn.close-btn:hover:not(:disabled) svg {
            color: #7B1FA2;
        }

        .opp-action-btn.delete-btn:hover:not(:disabled) svg {
            color: #D32F2F;
        }

        .opp-action-btn.cancel-btn:hover:not(:disabled) svg {
            color: #F57C00;
        }

        .opp-action-btn.archive-btn:hover:not(:disabled) svg {
            color: #5C6BC0;
        }

        /* Archived opportunity styling */
        .opportunity-item.archived {
            opacity: 0.6;
        }

        .opportunity-item.archived .opportunity-name {
            text-decoration: line-through;
        }

        /* Show Archived Toggle */
        .archive-toggle-container {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            margin-bottom: 16px;
            padding-right: 8px;
        }

        .archive-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 13px;
            color: #6C757D;
            user-select: none;
        }

        .archive-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #FFB800;
            cursor: pointer;
        }

        .archive-toggle:hover {
            color: #1F1F1F;
        }

        /* Confirmation modal */
        .confirm-modal-content {
            text-align: center;
        }

        .confirm-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            color: #D32F2F;
        }

        .confirm-title {
            font-size: 20px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 12px;
        }

        .confirm-message {
            font-size: 14px;
            color: #6C757D;
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .confirm-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .btn-danger {
            background: #D32F2F;
            color: #FFFFFF;
        }

        .btn-danger:hover {
            background: #B71C1C;
        }

        /* Comments section in side panel */
        .comments-section {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid #E0E0E0;
        }

        .comments-header {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 16px;
        }

        .comments-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .comment-item {
            padding: 12px;
            background: #F8F9FA;
            border-radius: 8px;
            border-left: 3px solid #E0E0E0;
        }

        .comment-item.cancellation {
            background: #FFF5F5;
            border-left-color: #D32F2F;
        }

        .comment-timestamp {
            font-size: 11px;
            color: #6C757D;
            margin-bottom: 4px;
        }

        .comment-item.cancellation .comment-timestamp {
            color: #D32F2F;
        }

        .comment-text {
            font-size: 13px;
            color: #1F1F1F;
            line-height: 1.5;
        }

        .comment-item.cancellation .comment-text {
            color: #B71C1C;
        }

        .comment-badge {
            display: inline-block;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
        }

        .comment-badge.cancellation {
            background: #FFEBEE;
            color: #D32F2F;
        }

        .no-comments {
            font-size: 13px;
            color: #ADB5BD;
            font-style: italic;
        }

        /* Comment input area */
        .comment-input-area {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #E0E0E0;
        }

        .comment-textarea {
            width: 100%;
            min-height: 80px;
            padding: 10px 12px;
            font-size: 13px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            resize: vertical;
        }

        .comment-textarea:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .comment-textarea::placeholder {
            color: #ADB5BD;
        }

        .comment-submit-btn {
            margin-top: 8px;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 500;
            background: #FFB800;
            color: #1F1F1F;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .comment-submit-btn:hover {
            background: #E5A600;
        }

        .comment-submit-btn:disabled {
            background: #E0E0E0;
            color: #ADB5BD;
            cursor: not-allowed;
        }

        /* Cancel modal with textarea */
        .cancel-modal-content {
            text-align: left;
        }

        .cancel-modal-content .modal-title {
            text-align: center;
        }

        .cancel-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            color: #F57C00;
            display: block;
        }

        .cancel-modal-content .form-group {
            margin-bottom: 20px;
        }

        .form-textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            resize: vertical;
        }

        .form-textarea:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .form-textarea::placeholder {
            color: #ADB5BD;
        }

        .btn-warning {
            background: #F57C00;
            color: #FFFFFF;
        }

        .btn-warning:hover {
            background: #E65100;
        }

        /* People page styles */
        .people-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .person-item {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .person-item:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
        }

        .person-info {
            flex: 1;
            min-width: 0;
        }

        .person-name {
            font-size: 15px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 4px;
        }

        .person-role {
            font-size: 13px;
            color: #6C757D;
        }

        .person-role-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 500;
            color: #6C757D;
            background: #F5F5F5;
            border-radius: 12px;
        }

        .person-actions {
            display: flex;
            gap: 4px;
        }

        /* Roles section */
        .roles-section {
            margin-top: 32px;
            padding-top: 24px;
            border-top: 1px solid #E0E0E0;
        }

        .roles-title {
            font-size: 14px;
            font-weight: 600;
            color: #6C757D;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .roles-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .role-tag {
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            font-size: 13px;
            color: #1F1F1F;
            background: #F5F5F5;
            border-radius: 16px;
        }

        /* Tags styles */
        .tags-section {
            margin-top: 32px;
            padding-top: 24px;
            border-top: 1px solid #E0E0E0;
        }

        .tags-title {
            font-size: 14px;
            font-weight: 600;
            color: #666;
            margin-bottom: 12px;
        }

        .tags-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .tag-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 12px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }

        .tag-item:hover {
            border-color: #BDBDBD;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .tag-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .tag-color-preview {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid rgba(0, 0, 0, 0.1);
        }

        .tag-name {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
        }

        .tag-actions {
            display: flex;
            gap: 4px;
        }

        /* Tag pill/chip for display in lists */
        .tag-pill {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            font-size: 11px;
            font-weight: 500;
            border-radius: 12px;
            margin-right: 4px;
            margin-bottom: 4px;
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            margin-top: 4px;
        }

        /* Color picker styles */
        .color-picker-wrapper {
            position: relative;
        }

        .color-picker-input {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #F5F5F5;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .color-picker-input:hover {
            border-color: #BDBDBD;
        }

        .color-picker-preview {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 2px solid rgba(0, 0, 0, 0.1);
        }

        .color-picker-value {
            font-size: 14px;
            color: #666;
            font-family: monospace;
        }

        .color-picker-native {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        /* Tag selector in modals */
        .tag-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px 0;
        }

        .tag-selector-item {
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            opacity: 0.6;
        }

        .tag-selector-item:hover {
            opacity: 0.8;
        }

        .tag-selector-item.selected {
            opacity: 1;
            border-color: rgba(0, 0, 0, 0.2);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .tag-selector-empty {
            font-size: 13px;
            color: #999;
            font-style: italic;
        }

        /* Tag input control for forms */
        .tag-input-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .selected-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .selected-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 12px;
            color: #fff;
        }

        .selected-tag .remove-tag {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            border: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            padding: 0;
            font-size: 10px;
            color: inherit;
            line-height: 1;
        }

        .selected-tag .remove-tag:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .tag-input-wrapper {
            position: relative;
        }

        .tag-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            font-size: 14px;
            background: #F5F5F5;
            transition: all 0.2s ease;
        }

        .tag-input:focus {
            outline: none;
            border-color: #F59E0B;
            background: #fff;
        }

        .tag-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #fff;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .tag-dropdown.open {
            display: block;
        }

        .tag-dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .tag-dropdown-item:hover,
        .tag-dropdown-item.highlighted {
            background: #F5F5F5;
        }

        .tag-dropdown-item .tag-color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .tag-dropdown-item.create-new {
            border-top: 1px solid #E0E0E0;
            color: #F59E0B;
            font-weight: 500;
        }

        .tag-dropdown-item.create-new .tag-color-dot {
            background: #F59E0B;
        }

        /* Inline person creation form */
        .inline-person-form {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
            background: #F8F9FA;
            border-radius: 8px;
            margin-top: 0;
            padding: 0 16px;
        }

        .inline-person-form.open {
            max-height: 200px;
            padding: 16px;
            margin-top: 12px;
        }

        .inline-person-form .form-group {
            margin-bottom: 12px;
        }

        .inline-person-form .form-group:last-child {
            margin-bottom: 0;
        }

        .inline-person-form .form-label {
            font-size: 12px;
            margin-bottom: 4px;
        }

        .inline-person-form .form-input {
            height: 40px;
            padding: 8px 12px;
            font-size: 13px;
        }

        .inline-person-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .inline-person-title {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .inline-person-actions {
            display: flex;
            gap: 8px;
        }

        .inline-person-actions .btn {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Contact badge in opportunity list */
        .opp-contact-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 500;
            color: #1976D2;
            background: #E3F2FD;
            border-radius: 12px;
        }

        /* Settings page layout */
        #settings-page {
            background: #F5F5F5;
        }

        .settings-container {
            display: flex;
            min-height: calc(100vh - 60px);
            margin-top: 60px;
        }

        .settings-menu {
            width: 20%;
            background: #FFFFFF;
            border-right: 1px solid #E0E0E0;
            padding: 24px 0;
        }

        .settings-menu-title {
            font-size: 14px;
            font-weight: 600;
            color: #6C757D;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 0 24px;
            margin-bottom: 16px;
        }

        .settings-menu-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .settings-menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 24px;
            font-size: 15px;
            font-weight: 500;
            color: #1F1F1F;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .settings-menu-item:hover {
            background: #F8F9FA;
        }

        .settings-menu-item.active {
            background: #FFF8E1;
            border-left-color: #FFB800;
            color: #1F1F1F;
        }

        .settings-menu-item svg {
            width: 24px;
            height: 24px;
            color: #6C757D;
            flex-shrink: 0;
        }

        .settings-menu-item.active svg {
            color: #FFB800;
        }

        .settings-content {
            width: 80%;
            position: relative;
            padding: 24px;
            overflow-y: auto;
        }

        .settings-close-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: #FFFFFF;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .settings-close-btn:hover {
            background: #F8F9FA;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .settings-close-btn svg {
            width: 24px;
            height: 24px;
            color: #6C757D;
        }

        .settings-close-btn:hover svg {
            color: #1F1F1F;
        }

        .settings-section-title {
            font-size: 24px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 24px;
        }

        /* Responsive settings */
        @media (max-width: 768px) {
            .settings-container {
                flex-direction: column;
            }

            .settings-menu {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #E0E0E0;
                padding: 16px 0;
            }

            .settings-content {
                width: 100%;
            }
        }

        /* ========================================
           RECOMMENDATION ENGINE STYLES
           ======================================== */

        /* Split-panel layout for Todos page */
        .home-split-container {
            display: flex;
            gap: 24px;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Recommendation Panel (Left) */
        .recommendation-panel {
            width: 450px;
            min-width: 450px;
            background: #FFFFFF;
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        /* Todo Panel (Right) */
        .todo-panel {
            flex: 1;
            min-width: 0;
        }

        /* Recommendation Header */
        .recommendation-header {
            position: relative;
            padding: 20px;
            border-bottom: 1px solid #E0E0E0;
            background: linear-gradient(135deg, #FFF8E1 0%, #FFFFFF 100%);
        }

        .recommendation-date {
            font-size: 18px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .recommendation-date-icon {
            font-size: 20px;
        }

        .recommendation-summary {
            font-size: 13px;
            color: #6C757D;
        }

        /* Recommendation Content */
        .recommendation-content {
            padding: 16px;
        }

        /* Recommendation Section */
        .recommendation-section {
            margin-bottom: 20px;
        }

        .recommendation-section:last-child {
            margin-bottom: 0;
        }

        .recommendation-section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #6C757D;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #F0F0F0;
        }

        .recommendation-section-icon {
            font-size: 14px;
        }

        .recommendation-section-count {
            background: #E9ECEF;
            color: #6C757D;
            font-size: 11px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: auto;
        }

        /* Section-specific colors */
        .recommendation-section.overdue .recommendation-section-header {
            color: #DC3545;
        }

        .recommendation-section.overdue .recommendation-section-count {
            background: #FFEBEE;
            color: #DC3545;
        }

        .recommendation-section.must-do .recommendation-section-header {
            color: #F57C00;
        }

        .recommendation-section.must-do .recommendation-section-count {
            background: #FFF3E0;
            color: #F57C00;
        }

        .recommendation-section.recommended .recommendation-section-header {
            color: #1976D2;
        }

        .recommendation-section.recommended .recommendation-section-count {
            background: #E3F2FD;
            color: #1976D2;
        }

        .recommendation-section.if-time .recommendation-section-header {
            color: #6C757D;
        }

        /* Recommendation Item */
        .recommendation-item {
            background: #F8F9FA;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .recommendation-item:last-child {
            margin-bottom: 0;
        }

        .recommendation-item:hover {
            background: #FFFFFF;
            border-color: #E0E0E0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .recommendation-item-header {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 8px;
        }

        .recommendation-item-checkbox {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #D0D0D0;
            flex-shrink: 0;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 2px;
        }

        .recommendation-item-checkbox:hover {
            border-color: #FFB800;
        }

        .recommendation-item-checkbox.checked {
            background: #00A86B;
            border-color: #00A86B;
        }

        .recommendation-item-title {
            flex: 1;
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            line-height: 1.4;
        }

        .recommendation-item.completed .recommendation-item-title {
            text-decoration: line-through;
            color: #ADB5BD;
        }

        .recommendation-item-meta {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 12px;
            color: #6C757D;
            margin-bottom: 8px;
            margin-left: 30px;
        }

        .recommendation-item-effort,
        .recommendation-item-deadline {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Tag pills in recommendation */
        .recommendation-item-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-left: 30px;
            margin-bottom: 8px;
        }

        /* Priority pill styling (distinct from user tags) */
        .priority-pill {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 10px;
            font-size: 11px;
            font-weight: 600;
            border-radius: 12px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .priority-pill.priority-urgent {
            background: #FFEBEE;
            color: #C62828;
        }

        .priority-pill.priority-high {
            background: #FFF3E0;
            color: #E65100;
        }

        .priority-pill.priority-normal {
            background: #E3F2FD;
            color: #1565C0;
        }

        .priority-pill.priority-low {
            background: #F5F5F5;
            color: #616161;
        }

        .priority-pill.priority-someday {
            background: #FAFAFA;
            color: #9E9E9E;
        }

        /* Reasoning text */
        .recommendation-item-reasoning {
            font-size: 12px;
            color: #6C757D;
            font-style: italic;
            margin-left: 30px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .recommendation-item-reasoning::before {
            content: '\2192';
            color: #ADB5BD;
        }

        /* Score display */
        .recommendation-item-score {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            margin-left: 30px;
            margin-top: 8px;
        }

        .score-badge {
            font-size: 11px;
            font-weight: 600;
            color: #6C757D;
            background: #E9ECEF;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .score-badge.critical {
            background: #FFEBEE;
            color: #C62828;
        }

        .score-badge.high {
            background: #FFF3E0;
            color: #E65100;
        }

        .score-badge.medium {
            background: #E3F2FD;
            color: #1565C0;
        }

        /* Warning Card */
        .warning-card {
            background: #FFF3E0;
            border: 1px solid #FFE0B2;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 12px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .warning-card.critical {
            background: #FFEBEE;
            border-color: #FFCDD2;
        }

        .warning-icon {
            font-size: 16px;
            flex-shrink: 0;
        }

        .warning-message {
            font-size: 13px;
            color: #5D4037;
            line-height: 1.4;
        }

        .warning-card.critical .warning-message {
            color: #B71C1C;
        }

        /* Insight Card */
        .insight-card {
            background: #E8F5E9;
            border: 1px solid #C8E6C9;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 12px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .insight-icon {
            font-size: 16px;
            flex-shrink: 0;
        }

        .insight-message {
            font-size: 13px;
            color: #2E7D32;
            line-height: 1.4;
        }

        /* Warnings section */
        .warnings-section {
            margin-bottom: 16px;
        }

        /* Insights section */
        .insights-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #E0E0E0;
        }

        .insights-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #2E7D32;
            margin-bottom: 12px;
        }

        /* Empty recommendation state */
        .recommendation-empty {
            text-align: center;
            padding: 40px 20px;
            color: #6C757D;
        }

        .recommendation-empty-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .recommendation-empty-text {
            font-size: 14px;
        }

        /* Effort dropdown styles */
        .effort-select {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            cursor: pointer;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236C757D' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 16px center;
        }

        .effort-select:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        /* Priority autocomplete styles */
        .priority-autocomplete-wrapper {
            position: relative;
        }

        .priority-input {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .priority-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .priority-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .priority-dropdown.open {
            display: block;
        }

        .priority-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }

        .priority-option:hover,
        .priority-option.highlighted {
            background: #F8F9FA;
        }

        .priority-option.selected {
            background: #FFF8E1;
        }

        .priority-option-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .priority-option-label {
            font-size: 14px;
            color: #1F1F1F;
        }

        .priority-option-desc {
            font-size: 12px;
            color: #6C757D;
            margin-left: auto;
        }

        /* Datetime input styles */
        .datetime-input {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .datetime-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        /* Description textarea */
        .form-textarea {
            width: 100%;
            min-height: 80px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            resize: vertical;
        }

        .form-textarea:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .form-textarea::placeholder {
            color: #ADB5BD;
        }

        /* Effort display in todo list */
        .todo-effort {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            color: #6C757D;
            background: #F5F5F5;
            padding: 2px 8px;
            border-radius: 10px;
            margin-right: 8px;
        }

        .todo-effort-icon {
            font-size: 10px;
        }

        /* Priority display in todo list */
        .todo-priority {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 10px;
            margin-right: 8px;
        }

        /* Planning settings section */
        .planning-settings-form {
            max-width: 500px;
        }

        .planning-settings-form .form-group {
            margin-bottom: 20px;
        }

        .planning-settings-form .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 6px;
        }

        .planning-settings-form .form-hint {
            font-size: 12px;
            color: #6C757D;
            margin-top: 4px;
        }

        .planning-settings-form .form-input {
            max-width: 200px;
        }

        .planning-settings-form .btn-save-settings {
            margin-top: 24px;
        }

        /* Responsive split-panel */
        @media (max-width: 1024px) {
            .home-split-container {
                flex-direction: column;
            }

            .recommendation-panel {
                width: 100%;
                min-width: 100%;
                margin-bottom: 24px;
            }

            .todo-panel {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- Landing Page -->
    <div id="landing-page" class="container">
        <div class="logo-container">
            <svg class="logo" viewBox="0 0 120 120" fill="none" xmlns="http://www.w3.org/2000/svg">
                <!-- Clipboard background -->
                <rect x="20" y="15" width="80" height="95" rx="8" fill="#FFB800"/>
                <rect x="25" y="20" width="70" height="85" rx="6" fill="#FFFFFF"/>

                <!-- Clipboard clip -->
                <path d="M45 10 H75 C78 10 80 12 80 15 V20 H40 V15 C40 12 42 10 45 10 Z" fill="#FFB800"/>
                <rect x="48" y="5" width="24" height="12" rx="3" fill="#1F1F1F"/>

                <!-- Checkmark items -->
                <g opacity="0.9">
                    <!-- First item - checked -->
                    <circle cx="35" cy="38" r="5" fill="#00A86B"/>
                    <path d="M33 38 L34.5 39.5 L37.5 36.5" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <rect x="45" y="36" width="45" height="4" rx="2" fill="#E0E0E0"/>

                    <!-- Second item - checked -->
                    <circle cx="35" cy="55" r="5" fill="#00A86B"/>
                    <path d="M33 55 L34.5 56.5 L37.5 53.5" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <rect x="45" y="53" width="35" height="4" rx="2" fill="#E0E0E0"/>

                    <!-- Third item - unchecked -->
                    <circle cx="35" cy="72" r="5" fill="#E0E0E0"/>
                    <rect x="45" y="70" width="40" height="4" rx="2" fill="#E0E0E0"/>

                    <!-- Fourth item - unchecked -->
                    <circle cx="35" cy="89" r="5" fill="#E0E0E0"/>
                    <rect x="45" y="87" width="30" height="4" rx="2" fill="#E0E0E0"/>
                </g>
            </svg>
            <h1>TodoManager</h1>
            <p class="tagline">Organize your tasks, achieve your goals</p>
        </div>

        <div class="options-container">
            <div class="option-card" onclick="startFromScratch()">
                <div class="option-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </div>
                <h2 class="option-title">Start from Scratch</h2>
                <p class="option-description">Begin fresh with a clean workspace and create your first task list</p>
            </div>

            <div class="option-card" onclick="continueWorking()">
                <div class="option-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 11l3 3L22 4"></path>
                        <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"></path>
                    </svg>
                </div>
                <h2 class="option-title">Continue Working</h2>
                <p class="option-description">Pick up where you left off and manage your existing tasks</p>
            </div>
        </div>

        <div class="footer">
            <p>&copy; 2025 TodoManager. Built with care.</p>
        </div>
    </div>

    <!-- Hidden file input for importing state -->
    <input type="file" id="import-file-input" accept=".json" style="display: none;" onchange="importData(event)">

    <!-- App Header (shared across pages) -->
    <header id="app-header" class="header hidden">
        <div class="header-left">
            <nav class="tab-nav">
                <button id="tab-home" class="tab-btn active" onclick="switchTab('home')">Todo's</button>
                <button id="tab-opportunities" class="tab-btn" onclick="switchTab('opportunities')">Opportunities</button>
            </nav>
        </div>
        <div class="header-actions">
            <button class="icon-button" onclick="openSettings()" title="Settings">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="3"></circle>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                </svg>
            </button>
            <button class="icon-button" onclick="exportData()" title="Export">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
            </button>
        </div>
    </header>

    <!-- Home Page -->
    <div id="home-page" class="page hidden">

        <!-- Main Content -->
        <main class="main-content">
            <!-- Split Container -->
            <div class="home-split-container">
                <!-- Recommendation Panel (Left) -->
                <div id="recommendation-panel" class="recommendation-panel">
                    <!-- Panel Header -->
                    <div class="recommendation-header">
                        <div class="recommendation-date">
                            <span class="recommendation-date-icon"></span>
                            <span id="recommendation-date-text">Daily Plan</span>
                        </div>
                        <div id="recommendation-summary" class="recommendation-summary"></div>
                    </div>

                    <!-- Panel Content -->
                    <div class="recommendation-content">
                        <!-- Warnings Section -->
                        <div id="warnings-section" class="warnings-section hidden"></div>

                        <!-- Overdue Section -->
                        <div id="overdue-section" class="recommendation-section overdue hidden">
                            <div class="recommendation-section-header">
                                <span class="recommendation-section-icon"></span>
                                <span>Overdue</span>
                                <span id="overdue-count" class="recommendation-section-count">0</span>
                            </div>
                            <div id="overdue-items" class="recommendation-items"></div>
                        </div>

                        <!-- Must Complete Today Section -->
                        <div id="must-do-section" class="recommendation-section must-do hidden">
                            <div class="recommendation-section-header">
                                <span class="recommendation-section-icon"></span>
                                <span>Must Complete Today</span>
                                <span id="must-do-count" class="recommendation-section-count">0</span>
                            </div>
                            <div id="must-do-items" class="recommendation-items"></div>
                        </div>

                        <!-- Recommended Section -->
                        <div id="recommended-section" class="recommendation-section recommended hidden">
                            <div class="recommendation-section-header">
                                <span class="recommendation-section-icon"></span>
                                <span>Recommended</span>
                                <span id="recommended-count" class="recommendation-section-count">0</span>
                            </div>
                            <div id="recommended-items" class="recommendation-items"></div>
                        </div>

                        <!-- If Time Permits Section -->
                        <div id="if-time-section" class="recommendation-section if-time hidden">
                            <div class="recommendation-section-header">
                                <span class="recommendation-section-icon"></span>
                                <span>If Time Permits</span>
                                <span id="if-time-count" class="recommendation-section-count">0</span>
                            </div>
                            <div id="if-time-items" class="recommendation-items"></div>
                        </div>

                        <!-- Insights Section -->
                        <div id="insights-section" class="insights-section hidden">
                            <div class="insights-header">
                                <span></span>
                                <span>Insights</span>
                            </div>
                            <div id="insights-items"></div>
                        </div>

                        <!-- Empty State -->
                        <div id="recommendation-empty" class="recommendation-empty">
                            <div class="recommendation-empty-icon"></div>
                            <p class="recommendation-empty-text">No tasks to recommend.<br>Add some todos to get started!</p>
                        </div>
                    </div>
                </div>

                <!-- Todo Panel (Right) -->
                <div class="todo-panel">
                    <!-- Floating shortcut hint (shown when items exist) -->
                    <p id="todo-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

                    <!-- Todo List Container -->
                    <div id="todo-list" class="todo-list">
                        <!-- Todos will be rendered here -->
                    </div>

                    <!-- Empty State -->
                    <div id="empty-state" class="empty-state">
                        <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"></path>
                            <rect x="9" y="3" width="6" height="4" rx="1"></rect>
                            <line x1="9" y1="12" x2="15" y2="12"></line>
                            <line x1="9" y1="16" x2="13" y2="16"></line>
                        </svg>
                        <p class="empty-text">No Todos</p>
                        <p class="shortcut-hint">Press Shift + N to create new items</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Opportunities Page -->
    <div id="opportunities-page" class="page hidden">
        <!-- Main Content -->
        <main class="main-content">
            <!-- Archive Toggle -->
            <div class="archive-toggle-container">
                <label class="archive-toggle">
                    <input type="checkbox" id="show-archived-toggle" onchange="toggleShowArchived()">
                    <span>Show Archived</span>
                </label>
            </div>
            <!-- Floating shortcut hint (shown when items exist) -->
            <p id="opp-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

            <!-- Opportunity List Container -->
            <div id="opportunity-list" class="opportunity-list">
                <!-- Opportunities will be rendered here -->
            </div>

            <!-- Empty State -->
            <div id="opportunity-empty-state" class="empty-state">
                <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                </svg>
                <p class="empty-text">No Opportunities</p>
                <p class="shortcut-hint">Press Shift + N to create new items</p>
            </div>
        </main>
    </div>

    <!-- Settings Page -->
    <div id="settings-page" class="page hidden">
        <div class="settings-container">
            <!-- Left Menu -->
            <nav class="settings-menu">
                <h2 class="settings-menu-title">Settings</h2>
                <ul class="settings-menu-list">
                    <li class="settings-menu-item active" data-section="people" onclick="switchSettingsSection('people')">
                        <!-- Multi-user icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                        <span>People</span>
                    </li>
                    <li class="settings-menu-item" data-section="tags" onclick="switchSettingsSection('tags')">
                        <!-- Tag icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                            <line x1="7" y1="7" x2="7.01" y2="7"></line>
                        </svg>
                        <span>Tags</span>
                    </li>
                    <li class="settings-menu-item" data-section="planning" onclick="switchSettingsSection('planning')">
                        <!-- Calendar/Clock icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                            <line x1="16" y1="2" x2="16" y2="6"></line>
                            <line x1="8" y1="2" x2="8" y2="6"></line>
                            <line x1="3" y1="10" x2="21" y2="10"></line>
                            <circle cx="12" cy="15" r="2"></circle>
                        </svg>
                        <span>Planning</span>
                    </li>
                </ul>
            </nav>

            <!-- Content Area -->
            <div class="settings-content">
                <!-- Close Button -->
                <button class="settings-close-btn" onclick="closeSettings()" title="Close Settings">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>

                <!-- People Section -->
                <div id="settings-section-people" class="settings-section">
                    <h2 class="settings-section-title">People</h2>

                    <!-- Floating shortcut hint (shown when items exist) -->
                    <p id="people-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

                    <!-- People List Container -->
                    <div id="people-list" class="people-list">
                        <!-- People will be rendered here -->
                    </div>

                    <!-- Empty State -->
                    <div id="people-empty-state" class="empty-state">
                        <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                        <p class="empty-text">No People</p>
                        <p class="shortcut-hint">Press Shift + N to create new items</p>
                    </div>

                    <!-- Roles Section -->
                    <div id="roles-section" class="roles-section hidden">
                        <h3 class="roles-title">Roles</h3>
                        <div id="roles-list" class="roles-list">
                            <!-- Roles will be rendered here -->
                        </div>
                    </div>
                </div>

                <!-- Tags Section -->
                <div id="settings-section-tags" class="settings-section hidden">
                    <h2 class="settings-section-title">Tags</h2>

                    <!-- Floating shortcut hint (shown when items exist) -->
                    <p id="tags-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

                    <!-- Tags List Container -->
                    <div id="tags-list" class="tags-list-container">
                        <!-- Tags will be rendered here -->
                    </div>

                    <!-- Empty State -->
                    <div id="tags-empty-state" class="empty-state">
                        <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                            <line x1="7" y1="7" x2="7.01" y2="7"></line>
                        </svg>
                        <p class="empty-text">No Tags</p>
                        <p class="shortcut-hint">Press Shift + N to create new items</p>
                    </div>
                </div>

                <!-- Planning Section -->
                <div id="settings-section-planning" class="settings-section hidden">
                    <h2 class="settings-section-title">Planning</h2>
                    <p style="color: #6C757D; margin-bottom: 24px;">Configure how the daily recommendation engine calculates and displays your task priorities.</p>

                    <form class="planning-settings-form" onsubmit="savePlanningSettings(event)">
                        <div class="form-group">
                            <label for="workday-minutes" class="form-label">Workday Length (minutes)</label>
                            <input type="number" id="workday-minutes" class="form-input" min="60" max="1440" value="480">
                            <p class="form-hint">How many minutes you plan to work each day (default: 480 = 8 hours)</p>
                        </div>

                        <div class="form-group">
                            <label for="buffer-percentage" class="form-label">Buffer Percentage (%)</label>
                            <input type="number" id="buffer-percentage" class="form-input" min="0" max="50" value="15">
                            <p class="form-hint">Reserve time for interruptions and context switching (default: 15%)</p>
                        </div>

                        <div class="form-group">
                            <label for="max-overdue" class="form-label">Max Overdue Items to Show</label>
                            <input type="number" id="max-overdue" class="form-input" min="1" max="20" value="5">
                            <p class="form-hint">Limit how many overdue items appear in recommendations (default: 5)</p>
                        </div>

                        <div class="form-group">
                            <label for="planning-horizon" class="form-label">Planning Horizon (days)</label>
                            <input type="number" id="planning-horizon" class="form-input" min="1" max="30" value="14">
                            <p class="form-hint">How far ahead to look when recommending tasks (default: 14 days)</p>
                        </div>

                        <button type="submit" class="btn btn-primary btn-save-settings">Save Settings</button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- Tag Modal -->
    <div id="tag-modal" class="modal hidden">
        <div class="modal-content">
            <h2 id="tag-modal-title">New Tag</h2>
            <form id="tag-form" onsubmit="saveTag(event)">
                <div class="form-group">
                    <label for="tag-name" class="form-label">Name *</label>
                    <input type="text" id="tag-name" class="form-input" placeholder="Tag name" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Color *</label>
                    <div class="color-picker-wrapper">
                        <div class="color-picker-input">
                            <div id="tag-color-preview" class="color-picker-preview" style="background-color: #F59E0B;"></div>
                            <span id="tag-color-value" class="color-picker-value">#F59E0B</span>
                        </div>
                        <input type="color" id="tag-color" class="color-picker-native" value="#F59E0B" onchange="updateColorPreview(this.value)">
                    </div>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeTagModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Side Panel for Opportunity Details -->
    <div id="side-panel-backdrop" class="side-panel-backdrop" onclick="closeSidePanel()"></div>
    <div id="side-panel" class="side-panel">
        <div class="side-panel-header">
            <h2 class="side-panel-title">Opportunity Details</h2>
            <button class="side-panel-close" onclick="closeSidePanel()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="side-panel-body">
            <div class="detail-group">
                <div class="detail-label">Name</div>
                <div id="panel-opp-name" class="detail-value"></div>
            </div>
            <div class="detail-group">
                <div class="detail-label">Description</div>
                <div id="panel-opp-description" class="detail-value"></div>
            </div>
            <div class="detail-group">
                <div class="detail-label">Start Date</div>
                <div id="panel-opp-date" class="detail-value"></div>
            </div>
            <div class="detail-group">
                <div class="detail-label">Contact</div>
                <div id="panel-opp-contact" class="detail-value"></div>
            </div>
            <div class="detail-group">
                <div class="detail-label">Status</div>
                <span id="panel-opp-status" class="status-badge"></span>
            </div>
            <!-- Comments Section -->
            <div class="comments-section">
                <div class="comments-header">Comments</div>
                <div id="panel-comments" class="comments-list">
                    <!-- Comments will be rendered here -->
                </div>
                <!-- Comment Input Area -->
                <div class="comment-input-area">
                    <textarea id="comment-input" class="comment-textarea" placeholder="Add a comment..."></textarea>
                    <button type="button" class="comment-submit-btn" onclick="addComment()">Add Comment</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Create Todo Modal -->
    <div id="todo-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeModal()"></div>
        <div class="modal-content">
            <h2 id="modal-title" class="modal-title">New Todo</h2>
            <form id="todo-form" onsubmit="saveTodo(event)">
                <div class="form-group">
                    <label for="todo-title" class="form-label">Title <span class="required">*</span></label>
                    <input type="text" id="todo-title" class="form-input" placeholder="What needs to be done?" required autofocus>
                </div>
                <div class="form-group">
                    <label for="todo-description" class="form-label">Description</label>
                    <textarea id="todo-description" class="form-textarea" placeholder="Additional details (optional)"></textarea>
                </div>
                <div class="form-group">
                    <label for="todo-deadline" class="form-label">Deadline <span class="required">*</span></label>
                    <input type="datetime-local" id="todo-deadline" class="datetime-input" required>
                </div>
                <div class="form-group">
                    <label for="todo-effort" class="form-label">Effort Level <span class="required">*</span></label>
                    <select id="todo-effort" class="effort-select" required>
                        <option value="very_low">Very Low (30 min)</option>
                        <option value="low">Low (2 hours)</option>
                        <option value="average" selected>Average (4 hours)</option>
                        <option value="high">High (6 hours)</option>
                        <option value="very_high">Very High (8 hours)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="todo-priority" class="form-label">Priority <span class="required">*</span></label>
                    <div class="priority-autocomplete-wrapper">
                        <input type="text" id="todo-priority" class="priority-input" placeholder="Type to select priority..." autocomplete="off" required>
                        <div id="priority-dropdown" class="priority-dropdown">
                            <!-- Priority options will be rendered here -->
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label for="todo-opportunity" class="form-label">Linked Opportunity</label>
                    <div class="autocomplete-wrapper">
                        <div class="autocomplete-input-wrapper">
                            <input type="text" id="todo-opportunity" class="autocomplete-input" placeholder="Type to search or create..." autocomplete="off">
                            <button type="button" id="todo-opportunity-clear" class="autocomplete-clear" onclick="clearOpportunitySelection()">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="18" y1="6" x2="6" y2="18"></line>
                                    <line x1="6" y1="6" x2="18" y2="18"></line>
                                </svg>
                            </button>
                        </div>
                        <div id="opportunity-dropdown" class="autocomplete-dropdown">
                            <!-- Dropdown items will be rendered here -->
                        </div>
                    </div>
                    <!-- Inline Opportunity Creation Form -->
                    <div id="inline-opp-form" class="inline-opp-form">
                        <div class="inline-opp-header">
                            <span class="inline-opp-title">Create New Opportunity</span>
                            <div class="inline-opp-actions">
                                <button type="button" class="btn btn-secondary" onclick="cancelInlineOpportunity()">Cancel</button>
                                <button type="button" class="btn btn-primary" onclick="confirmInlineOpportunity()">Add</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="inline-opp-name" class="form-label">Name</label>
                            <input type="text" id="inline-opp-name" class="form-input" placeholder="Opportunity name" readonly>
                        </div>
                        <div class="form-group">
                            <label for="inline-opp-description" class="form-label">Description</label>
                            <input type="text" id="inline-opp-description" class="form-input" placeholder="Brief description">
                        </div>
                        <div class="form-group">
                            <label for="inline-opp-start-date" class="form-label">Start Date</label>
                            <input type="date" id="inline-opp-start-date" class="form-input">
                        </div>
                        <div class="form-group">
                            <label for="inline-opp-contact" class="form-label">Contact</label>
                            <div class="autocomplete-wrapper">
                                <input type="text" id="inline-opp-contact" class="form-input" placeholder="Type to search or create person..." autocomplete="off">
                                <button type="button" id="inline-opp-contact-clear" class="autocomplete-clear" onclick="clearInlineOppContact()"></button>
                                <div id="inline-opp-contact-dropdown" class="autocomplete-dropdown">
                                    <!-- Contact dropdown items will be rendered here -->
                                </div>
                            </div>
                            <!-- Inline Person Creation Form (within inline opportunity) -->
                            <div id="inline-opp-person-form" class="inline-person-form">
                                <div class="inline-person-header">
                                    <span class="inline-person-title">Create New Person</span>
                                    <div class="inline-person-actions">
                                        <button type="button" class="btn btn-secondary" onclick="cancelInlineOppPerson()">Cancel</button>
                                        <button type="button" class="btn btn-primary" onclick="confirmInlineOppPerson()">Add</button>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label for="inline-opp-person-name" class="form-label">Name</label>
                                    <input type="text" id="inline-opp-person-name" class="form-input" placeholder="Person's name" readonly>
                                </div>
                                <div class="form-group">
                                    <label for="inline-opp-person-role" class="form-label">Role</label>
                                    <input type="text" id="inline-opp-person-role" class="form-input" placeholder="Person's role">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Tags Section -->
                <div class="form-group">
                    <label class="form-label">Tags</label>
                    <div class="tag-input-container" id="todo-tag-container">
                        <div class="selected-tags" id="todo-selected-tags">
                            <!-- Selected tags will be rendered here -->
                        </div>
                        <div class="tag-input-wrapper">
                            <input type="text" id="todo-tag-input" class="tag-input" placeholder="Type to add tags..." autocomplete="off">
                            <div id="todo-tag-dropdown" class="tag-dropdown">
                                <!-- Tag suggestions will be rendered here -->
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Create Opportunity Modal -->
    <div id="opportunity-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeOpportunityModal()"></div>
        <div class="modal-content">
            <h2 class="modal-title">New Opportunity</h2>
            <form id="opportunity-form" onsubmit="saveOpportunity(event)">
                <div class="form-group">
                    <label for="opp-name" class="form-label">Name <span class="required">*</span></label>
                    <input type="text" id="opp-name" class="form-input" placeholder="Opportunity name" required autofocus>
                </div>
                <div class="form-group">
                    <label for="opp-description" class="form-label">Description</label>
                    <input type="text" id="opp-description" class="form-input" placeholder="Brief description">
                </div>
                <div class="form-group">
                    <label for="opp-start-date" class="form-label">Start Date</label>
                    <input type="date" id="opp-start-date" class="form-input">
                </div>
                <div class="form-group">
                    <label for="opp-contact" class="form-label">Contact</label>
                    <div class="autocomplete-wrapper">
                        <input type="text" id="opp-contact" class="form-input" placeholder="Type to search or create person..." autocomplete="off">
                        <button type="button" id="opp-contact-clear" class="autocomplete-clear" onclick="clearOppContact()"></button>
                        <div id="contact-dropdown" class="autocomplete-dropdown">
                            <!-- Contact dropdown items will be rendered here -->
                        </div>
                    </div>
                    <!-- Inline Person Creation Form -->
                    <div id="inline-person-form" class="inline-person-form">
                        <div class="inline-person-header">
                            <span class="inline-person-title">Create New Person</span>
                            <div class="inline-person-actions">
                                <button type="button" class="btn btn-secondary" onclick="cancelInlinePerson()">Cancel</button>
                                <button type="button" class="btn btn-primary" onclick="confirmInlinePerson()">Add</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="inline-person-name" class="form-label">Name</label>
                            <input type="text" id="inline-person-name" class="form-input" placeholder="Person's name">
                        </div>
                        <div class="form-group">
                            <label for="inline-person-role" class="form-label">Role</label>
                            <input type="text" id="inline-person-role" class="form-input" placeholder="Person's role">
                        </div>
                    </div>
                </div>
                <!-- Tags Section -->
                <div class="form-group">
                    <label class="form-label">Tags</label>
                    <div class="tag-input-container" id="opp-tag-container">
                        <div class="selected-tags" id="opp-selected-tags">
                            <!-- Selected tags will be rendered here -->
                        </div>
                        <div class="tag-input-wrapper">
                            <input type="text" id="opp-tag-input" class="tag-input" placeholder="Type to add tags..." autocomplete="off">
                            <div id="opp-tag-dropdown" class="tag-dropdown">
                                <!-- Tag suggestions will be rendered here -->
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeOpportunityModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="confirm-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeConfirmModal()"></div>
        <div class="modal-content confirm-modal-content">
            <svg class="confirm-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
            <h2 class="confirm-title">Delete Opportunity?</h2>
            <p id="confirm-message" class="confirm-message">Are you sure you want to delete this opportunity? This action cannot be undone.</p>
            <div class="confirm-actions">
                <button type="button" class="btn btn-secondary" onclick="closeConfirmModal()">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="confirmDeleteOpportunity()">Delete</button>
            </div>
        </div>
    </div>

    <!-- Cancel Opportunity Modal -->
    <div id="cancel-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeCancelModal()"></div>
        <div class="modal-content cancel-modal-content">
            <svg class="cancel-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="15" y1="9" x2="9" y2="15"></line>
                <line x1="9" y1="9" x2="15" y2="15"></line>
            </svg>
            <h2 class="modal-title">Cancel Opportunity</h2>
            <p id="cancel-opp-name" style="text-align: center; color: #6C757D; margin-bottom: 20px;"></p>
            <div class="form-group">
                <label for="cancel-reason" class="form-label">Reason for Cancellation <span class="required">*</span></label>
                <textarea id="cancel-reason" class="form-textarea" placeholder="Please provide a reason for cancelling this opportunity..." required></textarea>
            </div>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeCancelModal()">Back</button>
                <button type="button" class="btn btn-warning" onclick="confirmCancelOpportunity()">Cancel Opportunity</button>
            </div>
        </div>
    </div>

    <!-- Person Modal -->
    <div id="person-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closePersonModal()"></div>
        <div class="modal-content">
            <h2 id="person-modal-title" class="modal-title">New Person</h2>
            <form id="person-form" onsubmit="savePerson(event)">
                <div class="form-group">
                    <label for="person-name" class="form-label">Name <span class="required">*</span></label>
                    <input type="text" id="person-name" class="form-input" placeholder="Person's name" required>
                </div>
                <div class="form-group">
                    <label for="person-role" class="form-label">Role</label>
                    <div class="autocomplete-wrapper">
                        <input type="text" id="person-role" class="form-input" placeholder="Type to search or create role..." autocomplete="off">
                        <button type="button" id="person-role-clear" class="autocomplete-clear" onclick="clearPersonRole()"></button>
                        <div id="role-dropdown" class="autocomplete-dropdown">
                            <!-- Role dropdown items will be rendered here -->
                        </div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closePersonModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Delete Person Confirmation Modal -->
    <div id="delete-person-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeDeletePersonModal()"></div>
        <div class="modal-content confirm-modal-content">
            <svg class="confirm-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
            <h2 class="modal-title">Delete Person</h2>
            <p id="delete-person-name" style="text-align: center; color: #6C757D; margin-bottom: 20px;"></p>
            <p style="text-align: center; margin-bottom: 20px;">Are you sure you want to delete this person? This will remove them from any linked opportunities.</p>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeDeletePersonModal()">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="confirmDeletePerson()">Delete</button>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // PRIORITY TAGS - System-defined constants
        // ========================================
        const PRIORITY_TAGS = Object.freeze({
            urgent: {
                id: "priority-urgent",
                name: "urgent",
                label: "Urgent",
                color: "#ef4444",
                weight: 100,
                description: "Must be addressed immediately"
            },
            high: {
                id: "priority-high",
                name: "high",
                label: "High Priority",
                color: "#f97316",
                weight: 75,
                description: "Important, should be done soon"
            },
            normal: {
                id: "priority-normal",
                name: "normal",
                label: "Normal",
                color: "#3b82f6",
                weight: 50,
                description: "Standard priority"
            },
            low: {
                id: "priority-low",
                name: "low",
                label: "Low Priority",
                color: "#6b7280",
                weight: 25,
                description: "Can wait, do when time permits"
            },
            someday: {
                id: "priority-someday",
                name: "someday",
                label: "Someday",
                color: "#9ca3af",
                weight: 10,
                description: "No urgency, backlog item"
            }
        });

        const DEFAULT_PRIORITY = "normal";

        // ========================================
        // EFFORT LEVELS - Configuration
        // ========================================
        const EFFORT_CONFIG = Object.freeze({
            very_low:  { label: "Very Low",  minutes: 30,  icon: "" },
            low:       { label: "Low",       minutes: 120, icon: "" },
            average:   { label: "Average",   minutes: 240, icon: "" },
            high:      { label: "High",      minutes: 360, icon: "" },
            very_high: { label: "Very High", minutes: 480, icon: "" }
        });

        const DEFAULT_EFFORT = "average";

        // ========================================
        // PLANNING SETTINGS - Defaults
        // ========================================
        const DEFAULT_SETTINGS = Object.freeze({
            workdayMinutes: 480,        // 8-hour workday
            bufferPercentage: 15,       // 15% buffer for interruptions
            maxOverdueToShow: 5,        // Limit overdue display
            planningHorizonDays: 14     // Look-ahead window
        });

        // Application state
        const state = {
            todos: [],
            opportunities: [],
            people: [],
            roles: [],
            tags: [],
            currentPage: 'landing',
            currentTab: 'home',  // 'home', 'opportunities', or 'settings'
            previousTab: 'home',  // Track previous tab for settings return navigation
            settingsSection: 'people',  // Current settings section
            modalOpen: false,
            opportunityModalOpen: false,
            personModalOpen: false,
            confirmModalOpen: false,
            cancelModalOpen: false,
            sidePanelOpen: false,
            editingTodoIndex: null,  // Track which todo is being edited (null = create mode)
            editingPersonIndex: null,  // Track which person is being edited (null = create mode)
            editingTagIndex: null,  // Track which tag is being edited (null = create mode)
            tagModalOpen: false,
            selectedOpportunityIndex: null,  // Track which opportunity is open in side panel
            deleteOpportunityIndex: null,  // Track which opportunity is pending deletion
            deletePersonIndex: null,  // Track which person is pending deletion
            cancelOpportunityIndex: null,  // Track which opportunity is pending cancellation
            // Autocomplete state
            selectedOpportunityId: null,  // ID of selected opportunity for todo linking
            selectedPersonId: null,  // ID of selected person for opportunity contact
            pendingOpportunity: null,  // New opportunity to create when saving todo
            pendingPerson: null,  // New person to create when saving opportunity
            autocompleteOpen: false,
            autocompleteHighlightIndex: -1,
            roleAutocompleteOpen: false,
            roleAutocompleteHighlightIndex: -1,
            contactAutocompleteOpen: false,
            contactAutocompleteHighlightIndex: -1,
            inlineOppFormOpen: false,
            inlinePersonFormOpen: false,
            // Inline person form within inline opportunity (in Todo modal)
            inlineOppContactAutocompleteOpen: false,
            inlineOppContactAutocompleteHighlightIndex: -1,
            inlineOppPersonFormOpen: false,
            selectedInlineOppPersonId: null,
            pendingInlineOppPerson: null,
            showArchived: false,
            // Tag assignment state
            selectedTodoTagIds: [],  // Tag IDs selected for current todo
            selectedOppTagIds: [],   // Tag IDs selected for current opportunity
            todoTagDropdownOpen: false,
            todoTagHighlightIndex: -1,
            oppTagDropdownOpen: false,
            oppTagHighlightIndex: -1,
            // Planning settings
            settings: { ...DEFAULT_SETTINGS },
            // Priority autocomplete state
            selectedPriority: DEFAULT_PRIORITY,
            priorityDropdownOpen: false,
            priorityHighlightIndex: -1
        };

        // DOM Elements - Landing and Home
        const landingPage = document.getElementById('landing-page');
        const homePage = document.getElementById('home-page');
        const todoList = document.getElementById('todo-list');
        const emptyState = document.getElementById('empty-state');
        const todoShortcutHintFloating = document.getElementById('todo-shortcut-hint-floating');
        const todoModal = document.getElementById('todo-modal');
        const todoForm = document.getElementById('todo-form');
        const todoTitleInput = document.getElementById('todo-title');
        const todoDescriptionInput = document.getElementById('todo-description');
        const todoDeadlineInput = document.getElementById('todo-deadline');
        const todoEffortSelect = document.getElementById('todo-effort');
        const todoPriorityInput = document.getElementById('todo-priority');
        const priorityDropdown = document.getElementById('priority-dropdown');
        const modalTitle = document.getElementById('modal-title');

        // DOM Elements - Recommendation Panel
        const recommendationPanel = document.getElementById('recommendation-panel');
        const recommendationDateText = document.getElementById('recommendation-date-text');
        const recommendationSummary = document.getElementById('recommendation-summary');
        const warningsSection = document.getElementById('warnings-section');
        const overdueSection = document.getElementById('overdue-section');
        const overdueItems = document.getElementById('overdue-items');
        const overdueCount = document.getElementById('overdue-count');
        const mustDoSection = document.getElementById('must-do-section');
        const mustDoItems = document.getElementById('must-do-items');
        const mustDoCount = document.getElementById('must-do-count');
        const recommendedSection = document.getElementById('recommended-section');
        const recommendedItems = document.getElementById('recommended-items');
        const recommendedCount = document.getElementById('recommended-count');
        const ifTimeSection = document.getElementById('if-time-section');
        const ifTimeItems = document.getElementById('if-time-items');
        const ifTimeCount = document.getElementById('if-time-count');
        const insightsSection = document.getElementById('insights-section');
        const insightsItems = document.getElementById('insights-items');
        const recommendationEmpty = document.getElementById('recommendation-empty');

        // DOM Elements - Autocomplete
        const todoOpportunityInput = document.getElementById('todo-opportunity');
        const todoOpportunityClear = document.getElementById('todo-opportunity-clear');
        const opportunityDropdown = document.getElementById('opportunity-dropdown');
        const inlineOppForm = document.getElementById('inline-opp-form');
        const inlineOppName = document.getElementById('inline-opp-name');
        const inlineOppDescription = document.getElementById('inline-opp-description');
        const inlineOppStartDate = document.getElementById('inline-opp-start-date');
        const inlineOppContact = document.getElementById('inline-opp-contact');
        const inlineOppContactClear = document.getElementById('inline-opp-contact-clear');
        const inlineOppContactDropdown = document.getElementById('inline-opp-contact-dropdown');
        const inlineOppPersonForm = document.getElementById('inline-opp-person-form');
        const inlineOppPersonName = document.getElementById('inline-opp-person-name');
        const inlineOppPersonRole = document.getElementById('inline-opp-person-role');

        // DOM Elements - Opportunities
        const opportunitiesPage = document.getElementById('opportunities-page');
        const opportunityList = document.getElementById('opportunity-list');
        const opportunityEmptyState = document.getElementById('opportunity-empty-state');
        const oppShortcutHintFloating = document.getElementById('opp-shortcut-hint-floating');
        const opportunityModal = document.getElementById('opportunity-modal');
        const opportunityForm = document.getElementById('opportunity-form');
        const oppNameInput = document.getElementById('opp-name');
        const oppDescriptionInput = document.getElementById('opp-description');
        const oppStartDateInput = document.getElementById('opp-start-date');
        const oppContactInput = document.getElementById('opp-contact');
        const oppContactClear = document.getElementById('opp-contact-clear');
        const contactDropdown = document.getElementById('contact-dropdown');
        const inlinePersonForm = document.getElementById('inline-person-form');
        const inlinePersonName = document.getElementById('inline-person-name');
        const inlinePersonRole = document.getElementById('inline-person-role');

        // DOM Elements - Side Panel
        const sidePanel = document.getElementById('side-panel');
        const sidePanelBackdrop = document.getElementById('side-panel-backdrop');
        const panelOppName = document.getElementById('panel-opp-name');
        const panelOppDescription = document.getElementById('panel-opp-description');
        const panelOppDate = document.getElementById('panel-opp-date');
        const panelOppContact = document.getElementById('panel-opp-contact');
        const panelOppStatus = document.getElementById('panel-opp-status');

        // DOM Elements - Header and Tabs
        const appHeader = document.getElementById('app-header');
        const tabHome = document.getElementById('tab-home');
        const tabOpportunities = document.getElementById('tab-opportunities');

        // DOM Elements - Confirmation Modal
        const confirmModal = document.getElementById('confirm-modal');
        const confirmMessage = document.getElementById('confirm-message');

        // DOM Elements - Cancel Modal
        const cancelModal = document.getElementById('cancel-modal');
        const cancelOppName = document.getElementById('cancel-opp-name');
        const cancelReason = document.getElementById('cancel-reason');

        // DOM Elements - Comments
        const panelComments = document.getElementById('panel-comments');
        const commentInput = document.getElementById('comment-input');

        // DOM Elements - Archive Toggle
        const showArchivedToggle = document.getElementById('show-archived-toggle');

        // DOM Elements - Settings
        const settingsPage = document.getElementById('settings-page');
        const peopleList = document.getElementById('people-list');
        const peopleEmptyState = document.getElementById('people-empty-state');
        const peopleShortcutHintFloating = document.getElementById('people-shortcut-hint-floating');
        const rolesSection = document.getElementById('roles-section');
        const rolesList = document.getElementById('roles-list');

        // DOM Elements - Tags
        const tagsList = document.getElementById('tags-list');
        const tagsEmptyState = document.getElementById('tags-empty-state');
        const tagsShortcutHintFloating = document.getElementById('tags-shortcut-hint-floating');
        const settingsSectionPeople = document.getElementById('settings-section-people');
        const settingsSectionTags = document.getElementById('settings-section-tags');

        // DOM Elements - Tag Modal
        const tagModal = document.getElementById('tag-modal');
        const tagModalTitle = document.getElementById('tag-modal-title');
        const tagForm = document.getElementById('tag-form');
        const tagNameInput = document.getElementById('tag-name');
        const tagColorInput = document.getElementById('tag-color');
        const tagColorPreview = document.getElementById('tag-color-preview');
        const tagColorValue = document.getElementById('tag-color-value');

        // DOM Elements - Tag Input (Todo form)
        const todoTagInput = document.getElementById('todo-tag-input');
        const todoTagDropdown = document.getElementById('todo-tag-dropdown');
        const todoSelectedTags = document.getElementById('todo-selected-tags');

        // DOM Elements - Tag Input (Opportunity form)
        const oppTagInput = document.getElementById('opp-tag-input');
        const oppTagDropdown = document.getElementById('opp-tag-dropdown');
        const oppSelectedTags = document.getElementById('opp-selected-tags');

        // DOM Elements - Person Modal
        const personModal = document.getElementById('person-modal');
        const personModalTitle = document.getElementById('person-modal-title');
        const personForm = document.getElementById('person-form');
        const personNameInput = document.getElementById('person-name');
        const personRoleInput = document.getElementById('person-role');
        const personRoleClear = document.getElementById('person-role-clear');
        const roleDropdown = document.getElementById('role-dropdown');

        // DOM Elements - Delete Person Modal
        const deletePersonModal = document.getElementById('delete-person-modal');
        const deletePersonName = document.getElementById('delete-person-name');

        // Navigation functions
        function navigateTo(page) {
            // Hide all pages
            landingPage.classList.add('hidden');
            landingPage.classList.remove('container');
            homePage.classList.add('hidden');
            opportunitiesPage.classList.add('hidden');
            settingsPage.classList.add('hidden');
            appHeader.classList.add('hidden');

            // Show requested page
            if (page === 'landing') {
                landingPage.classList.remove('hidden');
                landingPage.classList.add('container');
                document.body.style.display = 'flex';
                document.body.style.alignItems = 'center';
                document.body.style.justifyContent = 'center';
            } else if (page === 'app') {
                // Show app with header and current tab
                appHeader.classList.remove('hidden');
                document.body.style.display = 'block';
                document.body.style.alignItems = '';
                document.body.style.justifyContent = '';
                switchTab(state.currentTab);
            }

            state.currentPage = page;
        }

        // Tab switching function
        function switchTab(tab) {
            state.currentTab = tab;

            // Update tab buttons (settings doesn't have a tab button)
            tabHome.classList.toggle('active', tab === 'home');
            tabOpportunities.classList.toggle('active', tab === 'opportunities');

            // Show/hide pages
            homePage.classList.toggle('hidden', tab !== 'home');
            opportunitiesPage.classList.toggle('hidden', tab !== 'opportunities');
            settingsPage.classList.toggle('hidden', tab !== 'settings');

            // Render content
            if (tab === 'home') {
                renderTodos();
            } else if (tab === 'opportunities') {
                renderOpportunities();
            } else if (tab === 'settings') {
                renderPeople();
            }
        }

        // Open Settings page
        function openSettings() {
            // Save current tab before navigating to settings
            if (state.currentTab !== 'settings') {
                state.previousTab = state.currentTab;
            }
            switchTab('settings');
        }

        // Close Settings and return to previous page
        function closeSettings() {
            switchTab(state.previousTab);
        }

        // Switch settings section
        function switchSettingsSection(section) {
            state.settingsSection = section;

            // Update menu item active state
            const menuItems = document.querySelectorAll('.settings-menu-item');
            menuItems.forEach(item => {
                item.classList.toggle('active', item.dataset.section === section);
            });

            // Toggle section visibility
            const peopleSection = document.getElementById('settings-section-people');
            const tagsSection = document.getElementById('settings-section-tags');
            const planningSection = document.getElementById('settings-section-planning');

            // Hide all sections
            peopleSection.classList.add('hidden');
            tagsSection.classList.add('hidden');
            planningSection.classList.add('hidden');

            if (section === 'people') {
                peopleSection.classList.remove('hidden');
                renderPeople();
            } else if (section === 'tags') {
                tagsSection.classList.remove('hidden');
                renderTags();
            } else if (section === 'planning') {
                planningSection.classList.remove('hidden');
                renderPlanningSettings();
            }
        }

        function startFromScratch() {
            // Clear data and navigate to app
            state.todos = [];
            state.opportunities = [];
            state.currentTab = 'home';
            navigateTo('app');
        }

        function continueWorking() {
            // Trigger file input to load previous state
            document.getElementById('import-file-input').click();
        }

        // Export app state to JSON file
        function exportData() {
            // Collect all data entities from state
            const exportableData = {
                version: '1.0',
                lastModified: new Date().toISOString(),
                settings: state.settings,
                userTags: state.tags,  // Renamed for spec compliance
                todos: state.todos,
                opportunities: state.opportunities,
                people: state.people,
                roles: state.roles,
                tags: state.tags,  // Keep for backward compatibility
                exportedAt: new Date().toISOString()
            };

            // Create JSON blob
            const jsonString = JSON.stringify(exportableData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });

            // Generate filename with timestamp
            const now = new Date();
            const timestamp = now.toISOString()
                .replace(/T/, '_')
                .replace(/:/g, '-')
                .replace(/\..+/, '');
            const filename = `todoApp_${timestamp}.json`;

            // Create download link and trigger download
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Import app state from JSON file
        function importData(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);

                    // Validate required data structure
                    if (!importedData || typeof importedData !== 'object') {
                        throw new Error('Invalid file format');
                    }

                    // Restore state data entities (with fallbacks for missing fields)
                    state.todos = Array.isArray(importedData.todos) ? importedData.todos : [];
                    state.opportunities = Array.isArray(importedData.opportunities) ? importedData.opportunities : [];
                    state.people = Array.isArray(importedData.people) ? importedData.people : [];
                    state.roles = Array.isArray(importedData.roles) ? importedData.roles : [];
                    // Support both old 'tags' and new 'userTags' format
                    state.tags = Array.isArray(importedData.userTags) ? importedData.userTags :
                                 Array.isArray(importedData.tags) ? importedData.tags : [];

                    // Restore planning settings (merge with defaults)
                    if (importedData.settings && typeof importedData.settings === 'object') {
                        state.settings = { ...DEFAULT_SETTINGS, ...importedData.settings };
                    } else {
                        state.settings = { ...DEFAULT_SETTINGS };
                    }

                    // Ensure all todos have required new fields with defaults
                    state.todos = state.todos.map(todo => ({
                        ...todo,
                        title: todo.title || todo.description || 'Untitled',
                        description: todo.description || null,
                        deadline: todo.deadline || (todo.dueDate ? new Date(todo.dueDate).toISOString() : null),
                        effort: todo.effort || DEFAULT_EFFORT,
                        priority: PRIORITY_TAGS[todo.priority] ? todo.priority : DEFAULT_PRIORITY,
                        completedAt: todo.completedAt || null,
                        createdAt: todo.createdAt || new Date().toISOString(),
                        updatedAt: todo.updatedAt || new Date().toISOString()
                    }));

                    // Navigate to app and render
                    navigateTo('app');
                    renderTodos();
                    renderOpportunities();
                    renderPeople();
                    renderTags();
                    loadPlanningSettings();

                } catch (error) {
                    alert('Error importing file: ' + error.message + '\n\nPlease ensure you selected a valid TodoApp export file.');
                }

                // Reset file input for future imports
                event.target.value = '';
            };

            reader.onerror = function() {
                alert('Error reading file. Please try again.');
                event.target.value = '';
            };

            reader.readAsText(file);
        }

        // Placeholder for data persistence
        function saveData() {
            // Data persistence not implemented yet - data lives in memory
        }

        // Modal functions
        function openModal(todoIndex = null) {
            todoModal.classList.remove('hidden');
            state.modalOpen = true;
            state.editingTodoIndex = todoIndex;

            // Reset form
            todoForm.reset();

            // Reset autocomplete state
            state.selectedOpportunityId = null;
            state.pendingOpportunity = null;
            state.autocompleteOpen = false;
            state.autocompleteHighlightIndex = -1;
            state.inlineOppFormOpen = false;
            // Reset inline opp person state
            state.inlineOppContactAutocompleteOpen = false;
            state.inlineOppContactAutocompleteHighlightIndex = -1;
            state.inlineOppPersonFormOpen = false;
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;
            todoOpportunityInput.value = '';
            todoOpportunityClear.classList.remove('visible');
            opportunityDropdown.classList.remove('open');
            inlineOppForm.classList.remove('open');
            // Reset inline opp contact fields
            inlineOppContact.value = '';
            inlineOppContactClear.classList.remove('visible');
            inlineOppContactDropdown.classList.remove('open');
            inlineOppPersonForm.classList.remove('open');

            // Reset tag input state
            state.selectedTodoTagIds = [];
            state.todoTagDropdownOpen = false;
            state.todoTagHighlightIndex = -1;
            todoTagInput.value = '';
            closeTodoTagDropdown();

            // Reset priority state
            state.selectedPriority = DEFAULT_PRIORITY;
            state.priorityDropdownOpen = false;
            state.priorityHighlightIndex = -1;
            closePriorityDropdown();

            if (todoIndex !== null) {
                // Edit mode - populate with existing todo data
                const todo = state.todos[todoIndex];
                modalTitle.textContent = 'Edit Todo';
                todoTitleInput.value = todo.title || '';
                todoDescriptionInput.value = todo.description || '';

                // Handle deadline (support both new deadline and old dueDate)
                if (todo.deadline) {
                    todoDeadlineInput.value = formatDateTimeLocal(new Date(todo.deadline));
                } else if (todo.dueDate) {
                    // Convert old dueDate to deadline with default time
                    const oldDate = new Date(todo.dueDate);
                    oldDate.setHours(17, 0, 0, 0);
                    todoDeadlineInput.value = formatDateTimeLocal(oldDate);
                } else {
                    todoDeadlineInput.value = getDefaultDeadline();
                }

                // Set effort
                todoEffortSelect.value = todo.effort || DEFAULT_EFFORT;

                // Set priority
                state.selectedPriority = todo.priority || DEFAULT_PRIORITY;
                todoPriorityInput.value = PRIORITY_TAGS[state.selectedPriority].label;

                // Pre-populate linked opportunity
                if (todo.opportunityId) {
                    const opp = state.opportunities.find(o => o.id === todo.opportunityId);
                    if (opp) {
                        state.selectedOpportunityId = opp.id;
                        todoOpportunityInput.value = opp.name;
                        todoOpportunityClear.classList.add('visible');
                    }
                }

                // Pre-populate tags
                if (todo.tagIds && Array.isArray(todo.tagIds)) {
                    state.selectedTodoTagIds = [...todo.tagIds];
                }
            } else {
                // Create mode
                modalTitle.textContent = 'New Todo';
                // Set default deadline to 5 PM today
                todoDeadlineInput.value = getDefaultDeadline();
                // Set default effort
                todoEffortSelect.value = DEFAULT_EFFORT;
                // Set default priority
                state.selectedPriority = DEFAULT_PRIORITY;
                todoPriorityInput.value = PRIORITY_TAGS[DEFAULT_PRIORITY].label;
            }

            // Render selected tags
            renderTodoSelectedTags();

            // Focus on title input
            setTimeout(() => todoTitleInput.focus(), 100);
        }

        // Edit a todo - opens modal in edit mode
        function editTodo(index) {
            openModal(index);
        }

        // Get today's date in YYYY-MM-DD format for date input
        function getTodayDate() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function closeModal() {
            todoModal.classList.add('hidden');
            state.modalOpen = false;
            state.editingTodoIndex = null;
            state.selectedOpportunityId = null;
            state.pendingOpportunity = null;
            state.autocompleteOpen = false;
            state.inlineOppFormOpen = false;
            todoForm.reset();
            opportunityDropdown.classList.remove('open');
            inlineOppForm.classList.remove('open');
        }

        // Generate unique ID
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
        }

        // Save todo (handles both create and update)
        function saveTodo(event) {
            event.preventDefault();

            const title = todoTitleInput.value.trim();
            const description = todoDescriptionInput.value.trim();
            const deadline = todoDeadlineInput.value;
            const effort = todoEffortSelect.value;
            const priority = state.selectedPriority;

            if (!title) return;
            if (!deadline) return;

            // Handle pending opportunity creation
            let opportunityId = state.selectedOpportunityId;
            if (state.pendingOpportunity) {
                // First, handle person creation if needed
                let contactPersonId = state.pendingOpportunity.contactPersonId;

                // Check for pending person from inline opp form (may be set after opportunity was confirmed)
                const pendingPersonData = state.pendingOpportunity.pendingPerson || state.pendingInlineOppPerson;

                if (pendingPersonData) {
                    // Create the new person (use the combined pending person data)
                    const pendingPerson = pendingPersonData;

                    // Handle role creation if needed
                    let roleId = null;
                    if (pendingPerson.role) {
                        // Check if role exists
                        const existingRole = state.roles.find(r => r.name.toLowerCase() === pendingPerson.role.toLowerCase());
                        if (existingRole) {
                            roleId = existingRole.id;
                        } else {
                            // Create new role
                            const newRole = {
                                id: generateId(),
                                name: pendingPerson.role,
                                createdAt: new Date().toISOString()
                            };
                            state.roles.push(newRole);
                            roleId = newRole.id;
                        }
                    }

                    // Create the person
                    const newPerson = {
                        id: generateId(),
                        name: pendingPerson.name,
                        roleId: roleId,
                        createdAt: new Date().toISOString()
                    };
                    state.people.push(newPerson);
                    contactPersonId = newPerson.id;
                }

                // Create the new opportunity
                const newOpp = {
                    id: generateId(),
                    name: state.pendingOpportunity.name,
                    description: state.pendingOpportunity.description || null,
                    startDate: state.pendingOpportunity.startDate || getTodayDate(),
                    contactPersonId: contactPersonId || null,
                    status: 'requested',
                    comments: [],
                    archived: false,
                    createdAt: new Date().toISOString()
                };
                state.opportunities.push(newOpp);
                opportunityId = newOpp.id;
            }

            if (state.editingTodoIndex !== null) {
                // Update existing todo
                const todo = state.todos[state.editingTodoIndex];
                todo.title = title;
                todo.description = description || null;
                todo.deadline = new Date(deadline).toISOString();
                todo.effort = effort;
                todo.priority = priority;
                todo.opportunityId = opportunityId;
                todo.tagIds = [...state.selectedTodoTagIds];
                todo.updatedAt = new Date().toISOString();
                // Preserve id, completed, completedAt, and createdAt
            } else {
                // Create new todo
                const now = new Date().toISOString();
                const newTodo = {
                    id: generateId(),
                    title: title,
                    description: description || null,
                    deadline: new Date(deadline).toISOString(),
                    effort: effort,
                    priority: priority,
                    opportunityId: opportunityId,
                    tagIds: [...state.selectedTodoTagIds],
                    completed: false,
                    completedAt: null,
                    createdAt: now,
                    updatedAt: now
                };
                state.todos.push(newTodo);
            }

            // Auto-update opportunity status to Open if todo is linked and not completed
            if (opportunityId) {
                updateOpportunityAutoStatus(opportunityId);
            }

            closeModal();
            renderTodos();
            // Also re-render opportunities if on that tab
            if (state.currentTab === 'opportunities') {
                renderOpportunities();
            }
        }

        // Auto-update opportunity status based on linked todos
        // Status Flow: Requested  Open (when todo linked)  Paused (all todos complete)  Closed
        function updateOpportunityAutoStatus(opportunityId) {
            const opp = state.opportunities.find(o => o.id === opportunityId);
            if (!opp) return;

            // Don't change closed or cancelled opportunities
            if (opp.status === 'closed' || opp.status === 'cancelled') return;

            // Get all todos linked to this opportunity
            const linkedTodos = state.todos.filter(t => t.opportunityId === opportunityId);

            // Check if any linked todo is not completed
            const hasActiveTodo = linkedTodos.some(t => !t.completed);
            const hasAnyTodo = linkedTodos.length > 0;

            if (hasActiveTodo) {
                // Has non-completed todos  Open
                if (opp.status !== 'open') {
                    opp.status = 'open';
                }
            } else if (hasAnyTodo) {
                // All todos are completed  Paused
                if (opp.status !== 'paused') {
                    opp.status = 'paused';
                }
            }
            // If no todos linked, keep current status
        }

        // Render functions
        function renderTodos() {
            if (state.currentPage !== 'app' || state.currentTab !== 'home') return;

            // Clear current list
            todoList.innerHTML = '';

            // Also render recommendation panel
            renderRecommendationPanel();

            if (state.todos.length === 0) {
                // Show empty state
                todoList.classList.add('hidden');
                emptyState.classList.remove('hidden');
                todoShortcutHintFloating.classList.add('hidden');
            } else {
                // Show todo list
                todoList.classList.remove('hidden');
                emptyState.classList.add('hidden');
                todoShortcutHintFloating.classList.remove('hidden');

                // Create sorted array with original indices preserved
                const sortedTodos = state.todos
                    .map((todo, index) => ({ todo, originalIndex: index }))
                    .sort((a, b) => {
                        // Incomplete todos first, then completed
                        if (a.todo.completed !== b.todo.completed) {
                            return a.todo.completed ? 1 : -1;
                        }

                        if (a.todo.completed) {
                            // Both completed: sort by completedAt (most recent first)
                            const aTime = a.todo.completedAt ? new Date(a.todo.completedAt).getTime() : 0;
                            const bTime = b.todo.completedAt ? new Date(b.todo.completedAt).getTime() : 0;
                            return bTime - aTime;
                        } else {
                            // Both incomplete: sort by dueDate (earliest first)
                            const aDate = a.todo.dueDate ? new Date(a.todo.dueDate).getTime() : Infinity;
                            const bDate = b.todo.dueDate ? new Date(b.todo.dueDate).getTime() : Infinity;
                            return aDate - bDate;
                        }
                    });

                sortedTodos.forEach(({ todo, originalIndex: index }) => {
                    const todoItem = document.createElement('div');
                    todoItem.className = `todo-item ${todo.completed ? 'completed' : ''}`;

                    // Format deadline (supports both old dueDate and new deadline)
                    let dueDateHtml = '';
                    const deadlineValue = todo.deadline || todo.dueDate;
                    if (deadlineValue) {
                        const dueDate = new Date(deadlineValue);
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);
                        const isOverdue = dueDate < today && !todo.completed;
                        dueDateHtml = `<div class="todo-due-date ${isOverdue ? 'overdue' : ''}"> ${formatDeadlineDisplay(deadlineValue)}</div>`;
                    }

                    // Format effort
                    let effortHtml = '';
                    const effort = todo.effort || DEFAULT_EFFORT;
                    const effortConfig = EFFORT_CONFIG[effort];
                    if (effortConfig) {
                        effortHtml = `<span class="todo-effort"><span class="todo-effort-icon">${effortConfig.icon}</span> ${formatEffortDisplay(effort)}</span>`;
                    }

                    // Format priority
                    let priorityHtml = '';
                    const priority = todo.priority || DEFAULT_PRIORITY;
                    if (priority && priority !== 'normal') {
                        const priorityTag = PRIORITY_TAGS[priority];
                        if (priorityTag) {
                            priorityHtml = `<span class="priority-pill priority-${priority}">${priorityTag.label}</span>`;
                        }
                    }

                    // Format linked opportunity
                    let opportunityHtml = '';
                    if (todo.opportunityId) {
                        const opp = state.opportunities.find(o => o.id === todo.opportunityId);
                        if (opp) {
                            opportunityHtml = `
                                <div class="todo-opportunity">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <circle cx="12" cy="12" r="10"></circle>
                                        <polyline points="12 6 12 12 16 14"></polyline>
                                    </svg>
                                    ${escapeHtml(opp.name)}
                                </div>
                            `;
                        }
                    }

                    // Format tags (combine priority pill with user tags)
                    let tagsHtml = '';
                    const tagPills = [];

                    // Add priority pill first (if not normal)
                    if (priorityHtml) {
                        tagPills.push(priorityHtml);
                    }

                    // Add effort badge
                    if (effortHtml) {
                        tagPills.push(effortHtml);
                    }

                    // Add user tags
                    if (todo.tagIds && todo.tagIds.length > 0) {
                        todo.tagIds.forEach(tagId => {
                            const tag = getTagById(tagId);
                            if (tag) {
                                tagPills.push(`<span class="tag-pill" style="background-color: ${tag.color}; color: #fff;">${escapeHtml(tag.name)}</span>`);
                            }
                        });
                    }

                    if (tagPills.length > 0) {
                        tagsHtml = `<div class="tags-container">${tagPills.join('')}</div>`;
                    }

                    todoItem.innerHTML = `
                        <div class="todo-checkbox ${todo.completed ? 'checked' : ''}" onclick="toggleTodo(${index})"></div>
                        <div class="todo-content">
                            <div class="todo-title">${escapeHtml(todo.title)}</div>
                            ${dueDateHtml}
                            ${opportunityHtml}
                            ${tagsHtml}
                        </div>
                        <div class="todo-actions">
                            <button class="todo-edit-btn" onclick="editTodo(${index})" title="Edit">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                        </div>
                    `;
                    todoList.appendChild(todoItem);
                });
            }
        }

        function toggleTodo(index) {
            const todo = state.todos[index];
            todo.completed = !todo.completed;
            todo.completedAt = todo.completed ? new Date().toISOString() : null;
            todo.updatedAt = new Date().toISOString();

            // Track completion timestamp
            if (todo.completed) {
                todo.completedAt = new Date().toISOString();
            } else {
                todo.completedAt = null;
            }

            // Check and update opportunity status if linked
            if (todo.opportunityId) {
                updateOpportunityAutoStatus(todo.opportunityId);
            }

            renderTodos();
            // Re-render opportunities if on that tab to update status badges
            if (state.currentTab === 'opportunities') {
                renderOpportunities();
            }
        }

        // Utility function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Format date for display
        function formatDate(dateString) {
            const date = new Date(dateString);
            const options = { year: 'numeric', month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        // Opportunity Modal functions
        function openOpportunityModal() {
            opportunityModal.classList.remove('hidden');
            state.opportunityModalOpen = true;

            // Reset form
            opportunityForm.reset();
            // Set default start date to today
            oppStartDateInput.value = getTodayDate();

            // Reset contact autocomplete state
            state.selectedPersonId = null;
            state.pendingPerson = null;
            state.contactAutocompleteOpen = false;
            state.contactAutocompleteHighlightIndex = -1;
            state.inlinePersonFormOpen = false;
            oppContactClear.classList.remove('visible');
            contactDropdown.classList.remove('open');
            inlinePersonForm.classList.remove('open');

            // Reset tag input state
            state.selectedOppTagIds = [];
            state.oppTagDropdownOpen = false;
            state.oppTagHighlightIndex = -1;
            oppTagInput.value = '';
            closeOppTagDropdown();
            renderOppSelectedTags();

            // Focus on name input
            setTimeout(() => oppNameInput.focus(), 100);
        }

        function closeOpportunityModal() {
            opportunityModal.classList.add('hidden');
            state.opportunityModalOpen = false;
            state.selectedPersonId = null;
            state.pendingPerson = null;
            state.contactAutocompleteOpen = false;
            state.inlinePersonFormOpen = false;
            opportunityForm.reset();
            contactDropdown.classList.remove('open');
            inlinePersonForm.classList.remove('open');
        }

        // Save opportunity
        function saveOpportunity(event) {
            event.preventDefault();

            const name = oppNameInput.value.trim();
            const description = oppDescriptionInput.value.trim();
            const startDate = oppStartDateInput.value;
            const contactName = oppContactInput.value.trim();

            if (!name) return;

            // Handle pending person creation
            let contactId = state.selectedPersonId;
            if (state.pendingPerson) {
                // Create the pending person
                const roleId = getOrCreateRole(state.pendingPerson.role);
                const newPerson = {
                    id: generateId(),
                    name: state.pendingPerson.name,
                    roleId: roleId
                };
                state.people.push(newPerson);
                contactId = newPerson.id;
            }

            const newOpportunity = {
                id: generateId(),
                name: name,
                description: description || null,
                startDate: startDate || getTodayDate(),
                contact: contactName || null,  // Keep text for display
                contactId: contactId || null,  // Link to person
                tagIds: [...state.selectedOppTagIds],
                status: 'requested',  // Default status
                comments: [],
                archived: false,
                createdAt: new Date().toISOString()
            };

            state.opportunities.push(newOpportunity);
            closeOpportunityModal();
            renderOpportunities();
            renderPeople();  // Refresh people list if new person was created
        }

        // Toggle show archived opportunities
        function toggleShowArchived() {
            state.showArchived = showArchivedToggle.checked;
            renderOpportunities();
        }

        // Render opportunities list
        function renderOpportunities() {
            if (state.currentPage !== 'app' || state.currentTab !== 'opportunities') return;

            // Clear current list
            opportunityList.innerHTML = '';

            // Filter opportunities based on archived state
            const filteredOpportunities = state.opportunities.filter(opp => {
                if (state.showArchived) return true;
                return !opp.archived;
            });

            if (filteredOpportunities.length === 0) {
                // Show empty state
                opportunityList.classList.add('hidden');
                opportunityEmptyState.classList.remove('hidden');
                oppShortcutHintFloating.classList.add('hidden');
            } else {
                // Show opportunity list
                opportunityList.classList.remove('hidden');
                opportunityEmptyState.classList.add('hidden');
                oppShortcutHintFloating.classList.remove('hidden');

                filteredOpportunities.forEach((opp) => {
                    // Find original index in state.opportunities
                    const index = state.opportunities.indexOf(opp);
                    const oppItem = document.createElement('div');
                    oppItem.className = 'opportunity-item' + (opp.archived ? ' archived' : '');

                    const statusClass = `status-${opp.status}`;
                    const canClose = opp.status === 'paused';
                    const isClosedOrCancelled = opp.status === 'closed' || opp.status === 'cancelled';

                    // Build action buttons based on status
                    let actionButtons = '';
                    if (isClosedOrCancelled && !opp.archived) {
                        // Only show Archive button for closed/cancelled (not yet archived)
                        actionButtons = `
                            <button class="opp-action-btn archive-btn" onclick="event.stopPropagation(); archiveOpportunity(${index})" title="Archive Opportunity">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="21 8 21 21 3 21 3 8"></polyline>
                                    <rect x="1" y="3" width="22" height="5"></rect>
                                    <line x1="10" y1="12" x2="14" y2="12"></line>
                                </svg>
                            </button>
                        `;
                    } else if (!opp.archived) {
                        // Show normal action buttons for non-archived, non-closed/cancelled
                        actionButtons = `
                            <button class="opp-action-btn close-btn" onclick="event.stopPropagation(); closeOpportunityAction(${index})" title="${canClose ? 'Close Opportunity' : 'Only Paused opportunities can be closed'}" ${canClose ? '' : 'disabled'}>
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                            </button>
                            <button class="opp-action-btn cancel-btn" onclick="event.stopPropagation(); openCancelConfirmation(${index})" title="Cancel Opportunity">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="15" y1="9" x2="9" y2="15"></line>
                                    <line x1="9" y1="9" x2="15" y2="15"></line>
                                </svg>
                            </button>
                            <button class="opp-action-btn delete-btn" onclick="event.stopPropagation(); openDeleteConfirmation(${index})" title="Delete Opportunity">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                    <line x1="10" y1="11" x2="10" y2="17"></line>
                                    <line x1="14" y1="11" x2="14" y2="17"></line>
                                </svg>
                            </button>
                        `;
                    }
                    // No buttons for archived opportunities

                    // Format tags for opportunity
                    let oppTagsHtml = '';
                    if (opp.tagIds && opp.tagIds.length > 0) {
                        const tagPills = opp.tagIds.map(tagId => {
                            const tag = getTagById(tagId);
                            if (tag) {
                                return `<span class="tag-pill" style="background-color: ${tag.color}; color: #fff;">${escapeHtml(tag.name)}</span>`;
                            }
                            return '';
                        }).filter(Boolean).join('');
                        if (tagPills) {
                            oppTagsHtml = `<div class="tags-container">${tagPills}</div>`;
                        }
                    }

                    oppItem.innerHTML = `
                        <div class="opportunity-content" onclick="openSidePanel(${index})">
                            <div class="opportunity-name">${escapeHtml(opp.name)}</div>
                            ${opp.contact ? `<div class="opportunity-contact">${escapeHtml(opp.contact)}</div>` : ''}
                            ${oppTagsHtml}
                        </div>
                        <span class="status-badge ${statusClass}">${capitalizeFirst(opp.status)}</span>
                        <div class="opportunity-actions">
                            ${actionButtons}
                        </div>
                    `;
                    opportunityList.appendChild(oppItem);
                });
            }
        }

        // Capitalize first letter
        function capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        // Side Panel functions
        function openSidePanel(index) {
            state.selectedOpportunityIndex = index;
            state.sidePanelOpen = true;

            const opp = state.opportunities[index];

            // Populate panel
            panelOppName.textContent = opp.name;
            panelOppDescription.textContent = opp.description || 'No description';
            panelOppDate.textContent = opp.startDate ? formatDate(opp.startDate) : 'Not set';
            // Get contact name - either from contactPersonId or legacy contact field
            let contactDisplay = 'Not set';
            if (opp.contactPersonId) {
                const person = state.people.find(p => p.id === opp.contactPersonId);
                if (person) {
                    contactDisplay = person.name;
                }
            } else if (opp.contact) {
                contactDisplay = opp.contact;
            }
            panelOppContact.textContent = contactDisplay;

            // Update status badge
            updatePanelStatusBadge(opp.status);

            // Render comments
            renderCommentsInPanel(opp);

            // Show panel
            sidePanel.classList.add('open');
            sidePanelBackdrop.classList.add('open');
        }

        function closeSidePanel() {
            state.sidePanelOpen = false;
            state.selectedOpportunityIndex = null;

            sidePanel.classList.remove('open');
            sidePanelBackdrop.classList.remove('open');
        }

        // Update status badge in side panel
        function updatePanelStatusBadge(status) {
            panelOppStatus.textContent = capitalizeFirst(status);
            panelOppStatus.className = `status-badge status-${status}`;
        }

        // Archive opportunity (for closed/cancelled opportunities)
        function archiveOpportunity(index) {
            const opp = state.opportunities[index];
            if (opp.status !== 'closed' && opp.status !== 'cancelled') return;

            opp.archived = true;

            // Close side panel if this opportunity was open
            if (state.sidePanelOpen && state.selectedOpportunityIndex === index) {
                closeSidePanel();
            }

            // Re-render opportunities list
            renderOpportunities();
        }

        // Close opportunity action (set status to Closed)
        function closeOpportunityAction(index) {
            const opp = state.opportunities[index];
            if (opp.status !== 'paused') return; // Only paused can be closed

            opp.status = 'closed';
            renderOpportunities();

            // Also update side panel if open
            if (state.sidePanelOpen && state.selectedOpportunityIndex === index) {
                updatePanelStatusBadge('closed');
            }
        }

        // Open delete confirmation modal
        function openDeleteConfirmation(index) {
            state.deleteOpportunityIndex = index;
            state.confirmModalOpen = true;

            const opp = state.opportunities[index];
            confirmMessage.textContent = `Are you sure you want to delete "${opp.name}"? This action cannot be undone.`;

            confirmModal.classList.remove('hidden');
        }

        // Close confirmation modal
        function closeConfirmModal() {
            confirmModal.classList.add('hidden');
            state.confirmModalOpen = false;
            state.deleteOpportunityIndex = null;
        }

        // Confirm and execute opportunity deletion
        function confirmDeleteOpportunity() {
            if (state.deleteOpportunityIndex === null) return;

            const oppId = state.opportunities[state.deleteOpportunityIndex].id;

            // Remove opportunity link from all associated todos
            state.todos.forEach(todo => {
                if (todo.opportunityId === oppId) {
                    todo.opportunityId = null;
                }
            });

            // Remove the opportunity
            state.opportunities.splice(state.deleteOpportunityIndex, 1);

            // Close side panel if the deleted opportunity was open
            if (state.sidePanelOpen && state.selectedOpportunityIndex === state.deleteOpportunityIndex) {
                closeSidePanel();
            } else if (state.sidePanelOpen && state.selectedOpportunityIndex > state.deleteOpportunityIndex) {
                // Adjust index if needed
                state.selectedOpportunityIndex--;
            }

            // Close confirmation modal
            closeConfirmModal();

            // Re-render both lists
            renderOpportunities();
            renderTodos();
        }

        // =============================================
        // Cancel Opportunity Functions
        // =============================================

        // Open cancel confirmation modal
        function openCancelConfirmation(index) {
            state.cancelOpportunityIndex = index;
            state.cancelModalOpen = true;

            const opp = state.opportunities[index];
            cancelOppName.textContent = `"${opp.name}"`;
            cancelReason.value = '';

            cancelModal.classList.remove('hidden');
            setTimeout(() => cancelReason.focus(), 100);
        }

        // Close cancel modal
        function closeCancelModal() {
            cancelModal.classList.add('hidden');
            state.cancelModalOpen = false;
            state.cancelOpportunityIndex = null;
            cancelReason.value = '';
        }

        // Confirm and execute opportunity cancellation
        function confirmCancelOpportunity() {
            if (state.cancelOpportunityIndex === null) return;

            const reason = cancelReason.value.trim();
            if (!reason) {
                cancelReason.focus();
                return;
            }

            const opp = state.opportunities[state.cancelOpportunityIndex];

            // Initialize comments array if not exists (for backwards compatibility)
            if (!opp.comments) {
                opp.comments = [];
            }

            // Add cancellation comment
            opp.comments.push({
                text: reason,
                timestamp: new Date().toISOString(),
                type: 'cancellation'
            });

            // Set status to cancelled
            opp.status = 'cancelled';

            // Update side panel if this opportunity is open
            if (state.sidePanelOpen && state.selectedOpportunityIndex === state.cancelOpportunityIndex) {
                updatePanelStatusBadge('cancelled');
                renderCommentsInPanel(opp);
            }

            // Close cancel modal
            closeCancelModal();

            // Re-render opportunities list
            renderOpportunities();
        }

        // Format datetime for display
        function formatDateTime(isoString) {
            const date = new Date(isoString);
            const options = {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            };
            return date.toLocaleString('en-US', options);
        }

        // Render comments in side panel
        function renderCommentsInPanel(opp) {
            // Initialize comments array if not exists
            const comments = opp.comments || [];

            if (comments.length === 0) {
                panelComments.innerHTML = '<p class="no-comments">No comments yet</p>';
                return;
            }

            panelComments.innerHTML = comments.map(comment => {
                const isCancellation = comment.type === 'cancellation';
                const badge = isCancellation ? '<span class="comment-badge cancellation">Cancellation</span>' : '';
                return `
                    <div class="comment-item ${isCancellation ? 'cancellation' : ''}">
                        <div class="comment-timestamp">${formatDateTime(comment.timestamp)}${badge}</div>
                        <div class="comment-text">${escapeHtml(comment.text)}</div>
                    </div>
                `;
            }).join('');
        }

        // Add a new comment to the current opportunity
        function addComment() {
            if (state.selectedOpportunityIndex === null) return;

            const text = commentInput.value.trim();
            if (!text) return;

            const opp = state.opportunities[state.selectedOpportunityIndex];

            // Initialize comments array if not exists
            if (!opp.comments) {
                opp.comments = [];
            }

            // Add new standard comment
            opp.comments.push({
                text: text,
                timestamp: new Date().toISOString(),
                type: 'standard'
            });

            // Clear input
            commentInput.value = '';

            // Re-render comments
            renderCommentsInPanel(opp);
        }

        // =============================================
        // Autocomplete Functions for Todo-Opportunity Linking
        // =============================================

        // Filter opportunities based on search query
        function filterOpportunities(query) {
            if (!query || query.trim() === '') return [];
            const lowerQuery = query.toLowerCase().trim();
            return state.opportunities.filter(opp =>
                opp.name.toLowerCase().includes(lowerQuery)
            );
        }

        // Render autocomplete dropdown
        function renderAutocompleteDropdown(query) {
            const matches = filterOpportunities(query);
            opportunityDropdown.innerHTML = '';

            if (matches.length > 0) {
                matches.forEach((opp, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.setAttribute('data-index', index);
                    item.setAttribute('data-id', opp.id);
                    item.innerHTML = `
                        <div class="autocomplete-item-name">${escapeHtml(opp.name)}</div>
                        ${opp.contact ? `<div class="autocomplete-item-contact">${escapeHtml(opp.contact)}</div>` : ''}
                    `;
                    item.onclick = () => selectOpportunity(opp);
                    opportunityDropdown.appendChild(item);
                });
            } else if (query && query.trim() !== '') {
                // Show hint to create new
                const hint = document.createElement('div');
                hint.className = 'autocomplete-empty';
                hint.textContent = 'No matches found';
                opportunityDropdown.appendChild(hint);

                const createHint = document.createElement('div');
                createHint.className = 'autocomplete-create-hint';
                createHint.textContent = 'Press Enter to create new opportunity';
                opportunityDropdown.appendChild(createHint);
            }

            // Update highlight
            state.autocompleteHighlightIndex = -1;
            updateAutocompleteHighlight();
        }

        // Update autocomplete item highlight
        function updateAutocompleteHighlight() {
            const items = opportunityDropdown.querySelectorAll('.autocomplete-item');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.autocompleteHighlightIndex);
            });
        }

        // Select an opportunity from dropdown
        function selectOpportunity(opp) {
            state.selectedOpportunityId = opp.id;
            state.pendingOpportunity = null;
            todoOpportunityInput.value = opp.name;
            todoOpportunityClear.classList.add('visible');
            closeAutocompleteDropdown();
            closeInlineOppForm();
        }

        // Clear opportunity selection
        function clearOpportunitySelection() {
            state.selectedOpportunityId = null;
            state.pendingOpportunity = null;
            todoOpportunityInput.value = '';
            todoOpportunityClear.classList.remove('visible');
            closeAutocompleteDropdown();
            closeInlineOppForm();
        }

        // Open autocomplete dropdown
        function openAutocompleteDropdown() {
            state.autocompleteOpen = true;
            opportunityDropdown.classList.add('open');
        }

        // Close autocomplete dropdown
        function closeAutocompleteDropdown() {
            state.autocompleteOpen = false;
            state.autocompleteHighlightIndex = -1;
            opportunityDropdown.classList.remove('open');
        }

        // Open inline opportunity form with slide animation
        function openInlineOppForm(name) {
            state.inlineOppFormOpen = true;
            inlineOppName.value = name;
            inlineOppDescription.value = '';
            inlineOppStartDate.value = getTodayDate();
            inlineOppContact.value = '';
            inlineOppForm.classList.add('open');
            closeAutocompleteDropdown();

            // Focus on description after animation
            setTimeout(() => inlineOppDescription.focus(), 350);
        }

        // Close inline opportunity form
        function closeInlineOppForm() {
            state.inlineOppFormOpen = false;
            inlineOppForm.classList.remove('open');
        }

        // Cancel inline opportunity creation
        function cancelInlineOpportunity() {
            state.pendingOpportunity = null;
            todoOpportunityInput.value = '';
            todoOpportunityClear.classList.remove('visible');
            closeInlineOppForm();
        }

        // Confirm inline opportunity creation
        function confirmInlineOpportunity() {
            const name = inlineOppName.value.trim();
            if (!name) return;

            // Store pending opportunity data (will be created when todo is saved)
            state.pendingOpportunity = {
                name: name,
                description: inlineOppDescription.value.trim(),
                startDate: inlineOppStartDate.value,
                contact: inlineOppContact.value.trim(),
                // Include person data for the contact
                contactPersonId: state.selectedInlineOppPersonId,
                pendingPerson: state.pendingInlineOppPerson
            };

            // Update UI to show it's selected
            todoOpportunityInput.value = name + ' (new)';
            todoOpportunityClear.classList.add('visible');
            closeInlineOppForm();
        }

        // Handle autocomplete input events
        todoOpportunityInput.addEventListener('input', (e) => {
            const query = e.target.value;

            // Reset selection when typing
            state.selectedOpportunityId = null;
            state.pendingOpportunity = null;

            // Show/hide clear button
            todoOpportunityClear.classList.toggle('visible', query.length > 0);

            // Close inline form if open
            if (state.inlineOppFormOpen) {
                closeInlineOppForm();
            }

            // Render and open dropdown
            if (query.trim() !== '') {
                renderAutocompleteDropdown(query);
                openAutocompleteDropdown();
            } else {
                closeAutocompleteDropdown();
            }
        });

        // Handle autocomplete keyboard navigation
        todoOpportunityInput.addEventListener('keydown', (e) => {
            const items = opportunityDropdown.querySelectorAll('.autocomplete-item');
            const matches = filterOpportunities(todoOpportunityInput.value);

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.autocompleteOpen && items.length > 0) {
                    state.autocompleteHighlightIndex = Math.min(state.autocompleteHighlightIndex + 1, items.length - 1);
                    updateAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.autocompleteOpen && items.length > 0) {
                    state.autocompleteHighlightIndex = Math.max(state.autocompleteHighlightIndex - 1, 0);
                    updateAutocompleteHighlight();
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();

                const query = todoOpportunityInput.value.trim();

                if (state.autocompleteOpen && state.autocompleteHighlightIndex >= 0 && matches.length > 0) {
                    // Select highlighted item
                    selectOpportunity(matches[state.autocompleteHighlightIndex]);
                } else if (query && matches.length === 0 && !state.inlineOppFormOpen) {
                    // No matches - open inline creation form
                    openInlineOppForm(query);
                } else if (state.autocompleteOpen && matches.length > 0 && state.autocompleteHighlightIndex === -1) {
                    // Just close dropdown if there are matches but none selected
                    closeAutocompleteDropdown();
                }
            } else if (e.key === 'Escape') {
                if (state.autocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeAutocompleteDropdown();
                }
            }
        });

        // Handle inline opportunity description Enter key - move to Contact field
        inlineOppDescription.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                // Move focus to Contact field and scroll
                inlineOppContact.focus();
                setTimeout(() => {
                    inlineOppContact.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        });

        // Handle inline opportunity name Enter key - move to Description field
        inlineOppName.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                inlineOppDescription.focus();
            }
        });

        // Handle inline opportunity start date Enter key - move to Contact field
        inlineOppStartDate.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                inlineOppContact.focus();
                setTimeout(() => {
                    inlineOppContact.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        });

        // =============================================
        // People Management Functions
        // =============================================

        // Render people list
        function renderPeople() {
            peopleList.innerHTML = '';

            if (state.people.length === 0) {
                // Show empty state
                peopleList.classList.add('hidden');
                peopleEmptyState.classList.remove('hidden');
                peopleShortcutHintFloating.classList.add('hidden');
                rolesSection.classList.add('hidden');
            } else {
                // Show people list
                peopleList.classList.remove('hidden');
                peopleEmptyState.classList.add('hidden');
                peopleShortcutHintFloating.classList.remove('hidden');

                state.people.forEach((person, index) => {
                    const personItem = document.createElement('div');
                    personItem.className = 'person-item';

                    const roleName = person.roleId ? getRoleName(person.roleId) : '';

                    personItem.innerHTML = `
                        <div class="person-info">
                            <div class="person-name">${escapeHtml(person.name)}</div>
                            ${roleName ? `<span class="person-role-badge">${escapeHtml(roleName)}</span>` : ''}
                        </div>
                        <div class="person-actions">
                            <button class="action-btn" onclick="event.stopPropagation(); openPersonModal(${index})" title="Edit">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                            <button class="action-btn action-btn-danger" onclick="event.stopPropagation(); openDeletePersonModal(${index})" title="Delete">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                            </button>
                        </div>
                    `;

                    peopleList.appendChild(personItem);
                });

                // Show roles section if there are roles
                if (state.roles.length > 0) {
                    rolesSection.classList.remove('hidden');
                    renderRoles();
                } else {
                    rolesSection.classList.add('hidden');
                }
            }

            saveData();
        }

        // Render roles list
        function renderRoles() {
            rolesList.innerHTML = '';
            state.roles.forEach(role => {
                const roleTag = document.createElement('span');
                roleTag.className = 'role-tag';
                roleTag.textContent = role.name;
                rolesList.appendChild(roleTag);
            });
        }

        // Render tags list in Settings
        function renderTags() {
            tagsList.innerHTML = '';

            if (state.tags.length === 0) {
                // Show empty state
                tagsList.classList.add('hidden');
                tagsEmptyState.classList.remove('hidden');
                tagsShortcutHintFloating.classList.add('hidden');
            } else {
                // Show tags list
                tagsList.classList.remove('hidden');
                tagsEmptyState.classList.add('hidden');
                tagsShortcutHintFloating.classList.remove('hidden');

                state.tags.forEach((tag, index) => {
                    const tagItem = document.createElement('div');
                    tagItem.className = 'tag-item';

                    tagItem.innerHTML = `
                        <div class="tag-info">
                            <div class="tag-color-preview" style="background-color: ${tag.color}"></div>
                            <div class="tag-name">${escapeHtml(tag.name)}</div>
                        </div>
                        <div class="tag-actions">
                            <button class="action-btn" onclick="event.stopPropagation(); openTagModal(${index})" title="Edit">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                            <button class="action-btn action-btn-danger" onclick="event.stopPropagation(); deleteTag(${index})" title="Delete">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                            </button>
                        </div>
                    `;

                    tagsList.appendChild(tagItem);
                });
            }

            saveData();
        }

        // Open tag modal
        function openTagModal(tagIndex = null) {
            state.tagModalOpen = true;
            state.editingTagIndex = tagIndex;

            if (tagIndex !== null) {
                // Edit mode
                const tag = state.tags[tagIndex];
                tagModalTitle.textContent = 'Edit Tag';
                tagNameInput.value = tag.name;
                tagColorInput.value = tag.color;
                updateColorPreview(tag.color);
            } else {
                // Create mode
                tagModalTitle.textContent = 'New Tag';
                tagNameInput.value = '';
                tagColorInput.value = '#F59E0B';
                updateColorPreview('#F59E0B');
            }

            tagModal.classList.remove('hidden');
            setTimeout(() => tagNameInput.focus(), 100);
        }

        // Close tag modal
        function closeTagModal() {
            state.tagModalOpen = false;
            state.editingTagIndex = null;
            tagModal.classList.add('hidden');
            tagForm.reset();
        }

        // Update color preview
        function updateColorPreview(color) {
            tagColorPreview.style.backgroundColor = color;
            tagColorValue.textContent = color.toUpperCase();
        }

        // Save tag
        function saveTag(e) {
            e.preventDefault();

            const name = tagNameInput.value.trim();
            if (!name) return;

            const color = tagColorInput.value;

            if (state.editingTagIndex !== null) {
                // Update existing tag
                state.tags[state.editingTagIndex].name = name;
                state.tags[state.editingTagIndex].color = color;
            } else {
                // Create new tag
                const newTag = {
                    id: generateId(),
                    name: name,
                    color: color,
                    createdAt: new Date().toISOString()
                };
                state.tags.push(newTag);
            }

            closeTagModal();
            renderTags();
        }

        // Delete tag
        function deleteTag(index) {
            const tag = state.tags[index];

            // Remove tag from all todos and opportunities
            state.todos.forEach(todo => {
                if (todo.tagIds) {
                    todo.tagIds = todo.tagIds.filter(id => id !== tag.id);
                }
            });
            state.opportunities.forEach(opp => {
                if (opp.tagIds) {
                    opp.tagIds = opp.tagIds.filter(id => id !== tag.id);
                }
            });

            // Remove tag from array
            state.tags.splice(index, 1);
            renderTags();
        }

        // Get tag by ID
        function getTagById(tagId) {
            return state.tags.find(t => t.id === tagId);
        }

        // Get or create tag by name (for inline creation)
        function getOrCreateTag(tagName) {
            if (!tagName || tagName.trim() === '') return null;
            const trimmedName = tagName.trim();
            const existingTag = state.tags.find(t => t.name.toLowerCase() === trimmedName.toLowerCase());
            if (existingTag) return existingTag.id;

            // Create new tag with default color
            const defaultColors = ['#F59E0B', '#10B981', '#3B82F6', '#8B5CF6', '#EC4899', '#EF4444'];
            const colorIndex = state.tags.length % defaultColors.length;
            const newTag = {
                id: generateId(),
                name: trimmedName,
                color: defaultColors[colorIndex],
                createdAt: new Date().toISOString()
            };
            state.tags.push(newTag);
            return newTag.id;
        }

        // ==================== Tag Input Functions ====================

        // Render selected tags for Todo form
        function renderTodoSelectedTags() {
            todoSelectedTags.innerHTML = '';
            state.selectedTodoTagIds.forEach(tagId => {
                const tag = getTagById(tagId);
                if (tag) {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'selected-tag';
                    tagEl.style.backgroundColor = tag.color;
                    tagEl.innerHTML = `
                        ${escapeHtml(tag.name)}
                        <button type="button" class="remove-tag" onclick="removeTodoTag('${tagId}')"></button>
                    `;
                    todoSelectedTags.appendChild(tagEl);
                }
            });
        }

        // Render selected tags for Opportunity form
        function renderOppSelectedTags() {
            oppSelectedTags.innerHTML = '';
            state.selectedOppTagIds.forEach(tagId => {
                const tag = getTagById(tagId);
                if (tag) {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'selected-tag';
                    tagEl.style.backgroundColor = tag.color;
                    tagEl.innerHTML = `
                        ${escapeHtml(tag.name)}
                        <button type="button" class="remove-tag" onclick="removeOppTag('${tagId}')"></button>
                    `;
                    oppSelectedTags.appendChild(tagEl);
                }
            });
        }

        // Remove tag from Todo
        function removeTodoTag(tagId) {
            state.selectedTodoTagIds = state.selectedTodoTagIds.filter(id => id !== tagId);
            renderTodoSelectedTags();
        }

        // Remove tag from Opportunity
        function removeOppTag(tagId) {
            state.selectedOppTagIds = state.selectedOppTagIds.filter(id => id !== tagId);
            renderOppSelectedTags();
        }

        // Render tag dropdown for Todo
        function renderTodoTagDropdown(filter = '') {
            todoTagDropdown.innerHTML = '';
            const filterLower = filter.toLowerCase();

            // Filter tags not already selected and matching the filter
            const availableTags = state.tags.filter(tag =>
                !state.selectedTodoTagIds.includes(tag.id) &&
                tag.name.toLowerCase().includes(filterLower)
            );

            availableTags.forEach((tag, index) => {
                const item = document.createElement('div');
                item.className = 'tag-dropdown-item' + (index === state.todoTagHighlightIndex ? ' highlighted' : '');
                item.innerHTML = `
                    <span class="tag-color-dot" style="background-color: ${tag.color}"></span>
                    ${escapeHtml(tag.name)}
                `;
                item.onclick = () => selectTodoTag(tag.id);
                todoTagDropdown.appendChild(item);
            });

            // Show "create new" option if filter doesn't match existing tag exactly
            if (filter.trim() && !state.tags.some(t => t.name.toLowerCase() === filterLower)) {
                const createItem = document.createElement('div');
                createItem.className = 'tag-dropdown-item create-new' + (availableTags.length === state.todoTagHighlightIndex ? ' highlighted' : '');
                createItem.innerHTML = `
                    <span class="tag-color-dot"></span>
                    Create "${escapeHtml(filter.trim())}"
                `;
                createItem.onclick = () => createAndSelectTodoTag(filter.trim());
                todoTagDropdown.appendChild(createItem);
            }

            if (todoTagDropdown.children.length > 0) {
                todoTagDropdown.classList.add('open');
                state.todoTagDropdownOpen = true;
            } else {
                todoTagDropdown.classList.remove('open');
                state.todoTagDropdownOpen = false;
            }
        }

        // Render tag dropdown for Opportunity
        function renderOppTagDropdown(filter = '') {
            oppTagDropdown.innerHTML = '';
            const filterLower = filter.toLowerCase();

            // Filter tags not already selected and matching the filter
            const availableTags = state.tags.filter(tag =>
                !state.selectedOppTagIds.includes(tag.id) &&
                tag.name.toLowerCase().includes(filterLower)
            );

            availableTags.forEach((tag, index) => {
                const item = document.createElement('div');
                item.className = 'tag-dropdown-item' + (index === state.oppTagHighlightIndex ? ' highlighted' : '');
                item.innerHTML = `
                    <span class="tag-color-dot" style="background-color: ${tag.color}"></span>
                    ${escapeHtml(tag.name)}
                `;
                item.onclick = () => selectOppTag(tag.id);
                oppTagDropdown.appendChild(item);
            });

            // Show "create new" option if filter doesn't match existing tag exactly
            if (filter.trim() && !state.tags.some(t => t.name.toLowerCase() === filterLower)) {
                const createItem = document.createElement('div');
                createItem.className = 'tag-dropdown-item create-new' + (availableTags.length === state.oppTagHighlightIndex ? ' highlighted' : '');
                createItem.innerHTML = `
                    <span class="tag-color-dot"></span>
                    Create "${escapeHtml(filter.trim())}"
                `;
                createItem.onclick = () => createAndSelectOppTag(filter.trim());
                oppTagDropdown.appendChild(createItem);
            }

            if (oppTagDropdown.children.length > 0) {
                oppTagDropdown.classList.add('open');
                state.oppTagDropdownOpen = true;
            } else {
                oppTagDropdown.classList.remove('open');
                state.oppTagDropdownOpen = false;
            }
        }

        // Select existing tag for Todo
        function selectTodoTag(tagId) {
            if (!state.selectedTodoTagIds.includes(tagId)) {
                state.selectedTodoTagIds.push(tagId);
                renderTodoSelectedTags();
            }
            todoTagInput.value = '';
            closeTodoTagDropdown();
        }

        // Select existing tag for Opportunity
        function selectOppTag(tagId) {
            if (!state.selectedOppTagIds.includes(tagId)) {
                state.selectedOppTagIds.push(tagId);
                renderOppSelectedTags();
            }
            oppTagInput.value = '';
            closeOppTagDropdown();
        }

        // Create new tag and select it for Todo
        function createAndSelectTodoTag(name) {
            const tagId = getOrCreateTag(name);
            if (tagId) {
                selectTodoTag(tagId);
            }
        }

        // Create new tag and select it for Opportunity
        function createAndSelectOppTag(name) {
            const tagId = getOrCreateTag(name);
            if (tagId) {
                selectOppTag(tagId);
            }
        }

        // Close Todo tag dropdown
        function closeTodoTagDropdown() {
            todoTagDropdown.classList.remove('open');
            state.todoTagDropdownOpen = false;
            state.todoTagHighlightIndex = -1;
        }

        // Close Opportunity tag dropdown
        function closeOppTagDropdown() {
            oppTagDropdown.classList.remove('open');
            state.oppTagDropdownOpen = false;
            state.oppTagHighlightIndex = -1;
        }

        // Setup tag input event listeners
        function setupTagInputListeners() {
            // Todo tag input
            todoTagInput.addEventListener('input', (e) => {
                state.todoTagHighlightIndex = -1;
                renderTodoTagDropdown(e.target.value);
            });

            todoTagInput.addEventListener('focus', () => {
                renderTodoTagDropdown(todoTagInput.value);
            });

            todoTagInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    e.stopPropagation();
                    closeTodoTagDropdown();
                    todoTagInput.value = '';
                    return;
                }

                if (e.key === 'Enter') {
                    e.preventDefault();
                    const items = todoTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (state.todoTagHighlightIndex >= 0 && state.todoTagHighlightIndex < items.length) {
                        items[state.todoTagHighlightIndex].click();
                    } else if (todoTagInput.value.trim()) {
                        createAndSelectTodoTag(todoTagInput.value.trim());
                    }
                    return;
                }

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const items = todoTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (items.length > 0) {
                        state.todoTagHighlightIndex = Math.min(state.todoTagHighlightIndex + 1, items.length - 1);
                        renderTodoTagDropdown(todoTagInput.value);
                    }
                    return;
                }

                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (state.todoTagHighlightIndex > 0) {
                        state.todoTagHighlightIndex--;
                        renderTodoTagDropdown(todoTagInput.value);
                    }
                    return;
                }
            });

            // Opportunity tag input
            oppTagInput.addEventListener('input', (e) => {
                state.oppTagHighlightIndex = -1;
                renderOppTagDropdown(e.target.value);
            });

            oppTagInput.addEventListener('focus', () => {
                renderOppTagDropdown(oppTagInput.value);
            });

            oppTagInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    e.stopPropagation();
                    closeOppTagDropdown();
                    oppTagInput.value = '';
                    return;
                }

                if (e.key === 'Enter') {
                    e.preventDefault();
                    const items = oppTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (state.oppTagHighlightIndex >= 0 && state.oppTagHighlightIndex < items.length) {
                        items[state.oppTagHighlightIndex].click();
                    } else if (oppTagInput.value.trim()) {
                        createAndSelectOppTag(oppTagInput.value.trim());
                    }
                    return;
                }

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const items = oppTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (items.length > 0) {
                        state.oppTagHighlightIndex = Math.min(state.oppTagHighlightIndex + 1, items.length - 1);
                        renderOppTagDropdown(oppTagInput.value);
                    }
                    return;
                }

                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (state.oppTagHighlightIndex > 0) {
                        state.oppTagHighlightIndex--;
                        renderOppTagDropdown(oppTagInput.value);
                    }
                    return;
                }
            });

            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#todo-tag-container')) {
                    closeTodoTagDropdown();
                }
                if (!e.target.closest('#opp-tag-container')) {
                    closeOppTagDropdown();
                }
            });
        }

        // Initialize tag input listeners
        setupTagInputListeners();

        // ==================== End Tag Input Functions ====================

        // Get role name by ID
        function getRoleName(roleId) {
            const role = state.roles.find(r => r.id === roleId);
            return role ? role.name : '';
        }

        // Get or create role by name
        function getOrCreateRole(roleName) {
            if (!roleName || roleName.trim() === '') return null;
            const trimmedName = roleName.trim();
            const existingRole = state.roles.find(r => r.name.toLowerCase() === trimmedName.toLowerCase());
            if (existingRole) return existingRole.id;

            // Create new role
            const newRole = {
                id: generateId(),
                name: trimmedName
            };
            state.roles.push(newRole);
            return newRole.id;
        }

        // Open person modal
        function openPersonModal(personIndex = null) {
            state.personModalOpen = true;
            state.editingPersonIndex = personIndex;
            state.roleAutocompleteOpen = false;
            state.roleAutocompleteHighlightIndex = -1;

            personRoleInput.value = '';
            personRoleClear.classList.remove('visible');
            roleDropdown.classList.remove('open');

            if (personIndex !== null) {
                // Edit mode
                const person = state.people[personIndex];
                personModalTitle.textContent = 'Edit Person';
                personNameInput.value = person.name;
                if (person.roleId) {
                    personRoleInput.value = getRoleName(person.roleId);
                    personRoleClear.classList.add('visible');
                }
            } else {
                // Create mode
                personModalTitle.textContent = 'New Person';
                personNameInput.value = '';
            }

            personModal.classList.remove('hidden');
            setTimeout(() => personNameInput.focus(), 100);
        }

        // Close person modal
        function closePersonModal() {
            state.personModalOpen = false;
            state.editingPersonIndex = null;
            state.roleAutocompleteOpen = false;
            personModal.classList.add('hidden');
            personForm.reset();
            roleDropdown.classList.remove('open');
        }

        // Save person
        function savePerson(e) {
            e.preventDefault();

            const name = personNameInput.value.trim();
            if (!name) return;

            const roleName = personRoleInput.value.trim();
            const roleId = getOrCreateRole(roleName);

            if (state.editingPersonIndex !== null) {
                // Update existing person
                state.people[state.editingPersonIndex].name = name;
                state.people[state.editingPersonIndex].roleId = roleId;
            } else {
                // Create new person
                const newPerson = {
                    id: generateId(),
                    name: name,
                    roleId: roleId
                };
                state.people.push(newPerson);
            }

            closePersonModal();
            renderPeople();
        }

        // Open delete person modal
        function openDeletePersonModal(index) {
            state.deletePersonIndex = index;
            const person = state.people[index];
            deletePersonName.textContent = person.name;
            deletePersonModal.classList.remove('hidden');
        }

        // Close delete person modal
        function closeDeletePersonModal() {
            state.deletePersonIndex = null;
            deletePersonModal.classList.add('hidden');
        }

        // Confirm delete person
        function confirmDeletePerson() {
            if (state.deletePersonIndex !== null) {
                const personId = state.people[state.deletePersonIndex].id;

                // Remove person from array
                state.people.splice(state.deletePersonIndex, 1);

                // Update opportunities that referenced this person
                state.opportunities.forEach(opp => {
                    if (opp.contactId === personId) {
                        opp.contactId = null;
                        opp.contact = ''; // Clear the text contact as well
                    }
                });

                closeDeletePersonModal();
                renderPeople();
                renderOpportunities();
            }
        }

        // Clear person role input
        function clearPersonRole() {
            personRoleInput.value = '';
            personRoleClear.classList.remove('visible');
            roleDropdown.classList.remove('open');
            state.roleAutocompleteOpen = false;
        }

        // Filter roles based on search query
        function filterRoles(query) {
            if (!query || query.trim() === '') return [];
            const lowerQuery = query.toLowerCase().trim();
            return state.roles.filter(role =>
                role.name.toLowerCase().includes(lowerQuery)
            );
        }

        // Render role autocomplete dropdown
        function renderRoleDropdown(query) {
            const matches = filterRoles(query);
            roleDropdown.innerHTML = '';

            if (matches.length > 0) {
                matches.forEach((role, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.setAttribute('data-index', index);
                    item.setAttribute('data-id', role.id);
                    item.innerHTML = `<div class="autocomplete-item-name">${escapeHtml(role.name)}</div>`;
                    item.onclick = () => selectRole(role);
                    roleDropdown.appendChild(item);
                });
            } else if (query && query.trim() !== '') {
                // Show create option
                const createItem = document.createElement('div');
                createItem.className = 'autocomplete-item autocomplete-create';
                createItem.innerHTML = `
                    <div class="autocomplete-item-name">Create "${escapeHtml(query.trim())}"</div>
                `;
                createItem.onclick = () => {
                    personRoleInput.value = query.trim();
                    personRoleClear.classList.add('visible');
                    closeRoleDropdown();
                };
                roleDropdown.appendChild(createItem);
            }

            state.roleAutocompleteHighlightIndex = -1;
            updateRoleAutocompleteHighlight();
        }

        // Update role autocomplete highlight
        function updateRoleAutocompleteHighlight() {
            const items = roleDropdown.querySelectorAll('.autocomplete-item');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.roleAutocompleteHighlightIndex);
            });
        }

        // Select role from autocomplete
        function selectRole(role) {
            personRoleInput.value = role.name;
            personRoleClear.classList.add('visible');
            closeRoleDropdown();
        }

        // Open role dropdown
        function openRoleDropdown() {
            state.roleAutocompleteOpen = true;
            roleDropdown.classList.add('open');
        }

        // Close role dropdown
        function closeRoleDropdown() {
            state.roleAutocompleteOpen = false;
            roleDropdown.classList.remove('open');
            state.roleAutocompleteHighlightIndex = -1;
        }

        // Person role input event handlers
        personRoleInput.addEventListener('input', (e) => {
            const query = e.target.value;

            // Show/hide clear button
            personRoleClear.classList.toggle('visible', query.length > 0);

            // Render and open dropdown
            if (query.trim() !== '') {
                renderRoleDropdown(query);
                openRoleDropdown();
            } else {
                closeRoleDropdown();
            }
        });

        personRoleInput.addEventListener('focus', () => {
            const query = personRoleInput.value;
            if (query.trim() !== '') {
                renderRoleDropdown(query);
                openRoleDropdown();
            }
        });

        personRoleInput.addEventListener('keydown', (e) => {
            const items = roleDropdown.querySelectorAll('.autocomplete-item');
            const matches = filterRoles(personRoleInput.value);

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.roleAutocompleteOpen && items.length > 0) {
                    state.roleAutocompleteHighlightIndex = Math.min(state.roleAutocompleteHighlightIndex + 1, items.length - 1);
                    updateRoleAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.roleAutocompleteOpen && items.length > 0) {
                    state.roleAutocompleteHighlightIndex = Math.max(state.roleAutocompleteHighlightIndex - 1, 0);
                    updateRoleAutocompleteHighlight();
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();
                const query = personRoleInput.value.trim();

                if (state.roleAutocompleteOpen && state.roleAutocompleteHighlightIndex >= 0 && matches.length > 0) {
                    // Select highlighted item
                    selectRole(matches[state.roleAutocompleteHighlightIndex]);
                } else if (query) {
                    // Just accept the typed value
                    personRoleClear.classList.add('visible');
                    closeRoleDropdown();
                }
            } else if (e.key === 'Escape') {
                if (state.roleAutocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeRoleDropdown();
                }
            }
        });

        // =============================================
        // Contact Autocomplete Functions (Opportunity Modal)
        // =============================================

        // Filter people based on search query
        function filterPeople(query) {
            if (!query || query.trim() === '') return [];
            const lowerQuery = query.toLowerCase().trim();
            return state.people.filter(person =>
                person.name.toLowerCase().includes(lowerQuery)
            );
        }

        // Render contact autocomplete dropdown
        function renderContactDropdown(query) {
            const matches = filterPeople(query);
            contactDropdown.innerHTML = '';

            if (matches.length > 0) {
                matches.forEach((person, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.setAttribute('data-index', index);
                    item.setAttribute('data-id', person.id);
                    const roleName = person.roleId ? getRoleName(person.roleId) : '';
                    item.innerHTML = `
                        <div class="autocomplete-item-name">${escapeHtml(person.name)}</div>
                        ${roleName ? `<div class="autocomplete-item-contact">${escapeHtml(roleName)}</div>` : ''}
                    `;
                    item.onclick = () => selectContact(person);
                    contactDropdown.appendChild(item);
                });
            } else if (query && query.trim() !== '') {
                // Show create option
                const createItem = document.createElement('div');
                createItem.className = 'autocomplete-item autocomplete-create';
                createItem.innerHTML = `
                    <div class="autocomplete-item-name">Create "${escapeHtml(query.trim())}" - press Enter</div>
                `;
                createItem.onclick = () => openInlinePersonForm(query.trim());
                contactDropdown.appendChild(createItem);
            }

            state.contactAutocompleteHighlightIndex = -1;
            updateContactAutocompleteHighlight();
        }

        // Update contact autocomplete highlight
        function updateContactAutocompleteHighlight() {
            const items = contactDropdown.querySelectorAll('.autocomplete-item');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.contactAutocompleteHighlightIndex);
            });
        }

        // Select contact from autocomplete
        function selectContact(person) {
            state.selectedPersonId = person.id;
            state.pendingPerson = null;
            oppContactInput.value = person.name;
            oppContactClear.classList.add('visible');
            closeContactDropdown();
            closeInlinePersonForm();
        }

        // Open contact dropdown
        function openContactDropdown() {
            state.contactAutocompleteOpen = true;
            contactDropdown.classList.add('open');
        }

        // Close contact dropdown
        function closeContactDropdown() {
            state.contactAutocompleteOpen = false;
            contactDropdown.classList.remove('open');
            state.contactAutocompleteHighlightIndex = -1;
        }

        // Clear opportunity contact input
        function clearOppContact() {
            state.selectedPersonId = null;
            state.pendingPerson = null;
            oppContactInput.value = '';
            oppContactClear.classList.remove('visible');
            closeContactDropdown();
            closeInlinePersonForm();
        }

        // Open inline person form
        function openInlinePersonForm(name) {
            state.inlinePersonFormOpen = true;
            inlinePersonName.value = name;
            inlinePersonRole.value = '';
            inlinePersonForm.classList.add('open');
            closeContactDropdown();

            // Focus on role after animation
            setTimeout(() => inlinePersonRole.focus(), 350);
        }

        // Close inline person form
        function closeInlinePersonForm() {
            state.inlinePersonFormOpen = false;
            inlinePersonForm.classList.remove('open');
        }

        // Cancel inline person creation
        function cancelInlinePerson() {
            state.pendingPerson = null;
            oppContactInput.value = '';
            oppContactClear.classList.remove('visible');
            closeInlinePersonForm();
        }

        // Confirm inline person creation
        function confirmInlinePerson() {
            const name = inlinePersonName.value.trim();
            const role = inlinePersonRole.value.trim();

            if (!name) {
                inlinePersonName.focus();
                return;
            }

            // Store as pending person
            state.pendingPerson = { name, role };
            state.selectedPersonId = null;

            // Update the contact input to show the name
            oppContactInput.value = name;
            oppContactClear.classList.add('visible');

            closeInlinePersonForm();
        }

        // ============================================
        // Inline Person Creation within Inline Opportunity (Todo Modal)
        // ============================================

        // Render inline opp contact dropdown
        function renderInlineOppContactDropdown(query) {
            const matches = filterPeople(query);
            inlineOppContactDropdown.innerHTML = '';

            if (matches.length === 0) {
                const item = document.createElement('div');
                item.className = 'autocomplete-item autocomplete-no-match';
                item.textContent = `Press Enter to create "${query}"`;
                inlineOppContactDropdown.appendChild(item);
            } else {
                matches.forEach((person, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.dataset.index = index;

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'autocomplete-item-name';
                    nameSpan.textContent = person.name;
                    item.appendChild(nameSpan);

                    if (person.roleId) {
                        const role = state.roles.find(r => r.id === person.roleId);
                        if (role) {
                            const roleSpan = document.createElement('span');
                            roleSpan.className = 'autocomplete-item-role';
                            roleSpan.textContent = role.name;
                            item.appendChild(roleSpan);
                        }
                    }

                    item.addEventListener('click', () => selectInlineOppContact(person));
                    inlineOppContactDropdown.appendChild(item);
                });
            }
        }

        // Open inline opp contact dropdown
        function openInlineOppContactDropdown() {
            state.inlineOppContactAutocompleteOpen = true;
            state.inlineOppContactAutocompleteHighlightIndex = -1;
            inlineOppContactDropdown.classList.add('open');
        }

        // Close inline opp contact dropdown
        function closeInlineOppContactDropdown() {
            state.inlineOppContactAutocompleteOpen = false;
            state.inlineOppContactAutocompleteHighlightIndex = -1;
            inlineOppContactDropdown.classList.remove('open');
        }

        // Select contact for inline opportunity
        function selectInlineOppContact(person) {
            state.selectedInlineOppPersonId = person.id;
            state.pendingInlineOppPerson = null;
            inlineOppContact.value = person.name;
            inlineOppContactClear.classList.add('visible');
            closeInlineOppContactDropdown();
            closeInlineOppPersonForm();
        }

        // Clear inline opp contact selection
        function clearInlineOppContact() {
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;
            inlineOppContact.value = '';
            inlineOppContactClear.classList.remove('visible');
            closeInlineOppContactDropdown();
            closeInlineOppPersonForm();
        }

        // Open inline person form within inline opportunity
        function openInlineOppPersonForm(name) {
            state.inlineOppPersonFormOpen = true;
            inlineOppPersonName.value = name;
            inlineOppPersonRole.value = '';
            inlineOppPersonForm.classList.add('open');
            closeInlineOppContactDropdown();

            // Scroll to make the form visible
            setTimeout(() => {
                inlineOppPersonRole.focus();
                inlineOppPersonForm.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 350);
        }

        // Close inline person form within inline opportunity
        function closeInlineOppPersonForm() {
            state.inlineOppPersonFormOpen = false;
            inlineOppPersonForm.classList.remove('open');
        }

        // Cancel inline person creation within inline opportunity
        function cancelInlineOppPerson() {
            state.pendingInlineOppPerson = null;
            inlineOppContact.value = '';
            inlineOppContactClear.classList.remove('visible');
            closeInlineOppPersonForm();
        }

        // Confirm inline person creation within inline opportunity
        function confirmInlineOppPerson() {
            const name = inlineOppPersonName.value.trim();
            const role = inlineOppPersonRole.value.trim();

            if (!name) {
                inlineOppPersonName.focus();
                return;
            }

            // Store as pending person for inline opportunity
            state.pendingInlineOppPerson = { name, role };
            state.selectedInlineOppPersonId = null;

            // Update the contact input to show the name
            inlineOppContact.value = name;
            inlineOppContactClear.classList.add('visible');

            closeInlineOppPersonForm();
        }

        // Update autocomplete highlight for inline opp contact
        function updateInlineOppContactAutocompleteHighlight() {
            const items = inlineOppContactDropdown.querySelectorAll('.autocomplete-item:not(.autocomplete-no-match)');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.inlineOppContactAutocompleteHighlightIndex);
            });
        }

        // Inline opp contact input event handlers
        inlineOppContact.addEventListener('input', (e) => {
            const query = e.target.value;

            // Clear selected person if user types
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;

            // Show/hide clear button
            inlineOppContactClear.classList.toggle('visible', query.length > 0);

            // Close inline form if open
            if (state.inlineOppPersonFormOpen) {
                closeInlineOppPersonForm();
            }

            // Render and open dropdown
            if (query.trim() !== '') {
                renderInlineOppContactDropdown(query);
                openInlineOppContactDropdown();
            } else {
                closeInlineOppContactDropdown();
            }
        });

        inlineOppContact.addEventListener('focus', (e) => {
            const query = inlineOppContact.value;
            if (query.trim() !== '' && !state.selectedInlineOppPersonId && !state.pendingInlineOppPerson) {
                renderInlineOppContactDropdown(query);
                openInlineOppContactDropdown();
            }
            // Scroll to make contact field visible
            setTimeout(() => {
                inlineOppContact.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
        });

        inlineOppContact.addEventListener('keydown', (e) => {
            const items = inlineOppContactDropdown.querySelectorAll('.autocomplete-item:not(.autocomplete-no-match)');
            const matches = filterPeople(inlineOppContact.value);

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.inlineOppContactAutocompleteOpen && items.length > 0) {
                    state.inlineOppContactAutocompleteHighlightIndex = Math.min(state.inlineOppContactAutocompleteHighlightIndex + 1, items.length - 1);
                    updateInlineOppContactAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.inlineOppContactAutocompleteOpen && items.length > 0) {
                    state.inlineOppContactAutocompleteHighlightIndex = Math.max(state.inlineOppContactAutocompleteHighlightIndex - 1, 0);
                    updateInlineOppContactAutocompleteHighlight();
                }
            } else if (e.key === 'Tab') {
                // Tab key - if there's a query, open person form and focus role
                const query = inlineOppContact.value.trim();
                if (query && !state.inlineOppPersonFormOpen && !state.selectedInlineOppPersonId && !state.pendingInlineOppPerson) {
                    e.preventDefault();
                    openInlineOppPersonForm(query);
                }
                // If person form is already open, Tab will naturally move to role field
            } else if (e.key === 'Enter') {
                e.preventDefault();
                const query = inlineOppContact.value.trim();

                if (state.inlineOppContactAutocompleteOpen && state.inlineOppContactAutocompleteHighlightIndex >= 0 && matches.length > 0) {
                    // Select highlighted item
                    selectInlineOppContact(matches[state.inlineOppContactAutocompleteHighlightIndex]);
                } else if (query && !state.inlineOppPersonFormOpen && !state.selectedInlineOppPersonId && !state.pendingInlineOppPerson) {
                    // Has query but no selection - open inline creation form for new person
                    openInlineOppPersonForm(query);
                } else if (state.inlineOppContactAutocompleteOpen) {
                    // Just close dropdown
                    closeInlineOppContactDropdown();
                }
            } else if (e.key === 'Escape') {
                if (state.inlineOppContactAutocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeInlineOppContactDropdown();
                }
            }
        });

        // Handle inline opp person form Enter key - confirm person AND opportunity
        inlineOppPersonForm.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target.tagName === 'INPUT') {
                e.preventDefault();
                // First confirm the person
                confirmInlineOppPerson();
                // Then confirm the opportunity (which will include the person)
                confirmInlineOpportunity();
            }
        });

        // Contact input event handlers
        oppContactInput.addEventListener('input', (e) => {
            const query = e.target.value;

            // Clear selected person if user types
            state.selectedPersonId = null;
            state.pendingPerson = null;

            // Show/hide clear button
            oppContactClear.classList.toggle('visible', query.length > 0);

            // Close inline form if open
            if (state.inlinePersonFormOpen) {
                closeInlinePersonForm();
            }

            // Render and open dropdown
            if (query.trim() !== '') {
                renderContactDropdown(query);
                openContactDropdown();
            } else {
                closeContactDropdown();
            }
        });

        oppContactInput.addEventListener('focus', () => {
            const query = oppContactInput.value;
            if (query.trim() !== '' && !state.selectedPersonId && !state.pendingPerson) {
                renderContactDropdown(query);
                openContactDropdown();
            }
        });

        oppContactInput.addEventListener('keydown', (e) => {
            const items = contactDropdown.querySelectorAll('.autocomplete-item');
            const matches = filterPeople(oppContactInput.value);

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.contactAutocompleteOpen && items.length > 0) {
                    state.contactAutocompleteHighlightIndex = Math.min(state.contactAutocompleteHighlightIndex + 1, items.length - 1);
                    updateContactAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.contactAutocompleteOpen && items.length > 0) {
                    state.contactAutocompleteHighlightIndex = Math.max(state.contactAutocompleteHighlightIndex - 1, 0);
                    updateContactAutocompleteHighlight();
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();
                const query = oppContactInput.value.trim();

                if (state.contactAutocompleteOpen && state.contactAutocompleteHighlightIndex >= 0 && matches.length > 0) {
                    // Select highlighted item
                    selectContact(matches[state.contactAutocompleteHighlightIndex]);
                } else if (query && matches.length === 0 && !state.inlinePersonFormOpen) {
                    // No matches - open inline creation form
                    openInlinePersonForm(query);
                } else if (state.contactAutocompleteOpen && matches.length > 0 && state.contactAutocompleteHighlightIndex === -1) {
                    // Just close dropdown if there are matches but none selected
                    closeContactDropdown();
                }
            } else if (e.key === 'Escape') {
                if (state.contactAutocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeContactDropdown();
                }
            }
        });

        // Handle inline person form Enter key
        inlinePersonForm.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target.tagName === 'INPUT') {
                e.preventDefault();
                confirmInlinePerson();
            }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.autocomplete-wrapper') && state.autocompleteOpen) {
                closeAutocompleteDropdown();
            }
            if (!e.target.closest('.autocomplete-wrapper') && state.contactAutocompleteOpen) {
                closeContactDropdown();
            }
            if (!e.target.closest('.autocomplete-wrapper') && state.roleAutocompleteOpen) {
                closeRoleDropdown();
            }
            if (!e.target.closest('.autocomplete-wrapper') && state.inlineOppContactAutocompleteOpen) {
                closeInlineOppContactDropdown();
            }
        });

        // Add keyboard navigation (capture phase to intercept browser shortcuts)
        document.addEventListener('keydown', (e) => {
            // Skip if any modal is open and it's not Escape
            const anyModalOpen = state.modalOpen || state.opportunityModalOpen || state.personModalOpen;

            // Handle Shift+N to open todo modal (only on home tab)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'home' && !anyModalOpen) {
                e.preventDefault();
                openModal();
                return;
            }

            // Handle Shift+N to open opportunity modal (only on opportunities tab)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'opportunities' && !anyModalOpen) {
                e.preventDefault();
                openOpportunityModal();
                return;
            }

            // Handle Shift+N to open person modal (only on settings page with people section)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'settings' && state.settingsSection === 'people' && !anyModalOpen) {
                e.preventDefault();
                openPersonModal();
                return;
            }

            // Handle Shift+N to open tag modal (only on settings page with tags section)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'settings' && state.settingsSection === 'tags' && !anyModalOpen) {
                e.preventDefault();
                openTagModal();
                return;
            }

            // Handle Escape key to close modals or side panel
            if (e.key === 'Escape') {
                if (state.cancelModalOpen) {
                    e.preventDefault();
                    closeCancelModal();
                    return;
                }
                if (state.confirmModalOpen) {
                    e.preventDefault();
                    closeConfirmModal();
                    return;
                }
                if (state.modalOpen) {
                    e.preventDefault();
                    closeModal();
                    return;
                }
                if (state.opportunityModalOpen) {
                    e.preventDefault();
                    closeOpportunityModal();
                    return;
                }
                if (state.personModalOpen) {
                    e.preventDefault();
                    closePersonModal();
                    return;
                }
                if (state.tagModalOpen) {
                    e.preventDefault();
                    closeTagModal();
                    return;
                }
                if (state.deletePersonIndex !== null) {
                    e.preventDefault();
                    closeDeletePersonModal();
                    return;
                }
                if (state.sidePanelOpen) {
                    e.preventDefault();
                    closeSidePanel();
                    return;
                }
            }

            // Landing page keyboard shortcuts
            if (state.currentPage === 'landing') {
                if (e.key === '1') {
                    startFromScratch();
                } else if (e.key === '2') {
                    continueWorking();
                }
            }
        }, true);  // Use capture phase to intercept before browser handles it

        // Migrate existing contacts to people
        function migrateContactsToPeople() {
            // Get all unique contacts from opportunities that don't have a contactId
            const contactsToMigrate = new Map();

            state.opportunities.forEach(opp => {
                if (opp.contact && !opp.contactId) {
                    const normalizedContact = opp.contact.trim().toLowerCase();
                    if (!contactsToMigrate.has(normalizedContact)) {
                        contactsToMigrate.set(normalizedContact, opp.contact.trim());
                    }
                }
            });

            // Create people for unique contacts
            contactsToMigrate.forEach((originalName, normalizedName) => {
                // Check if person already exists
                const existingPerson = state.people.find(p => p.name.toLowerCase() === normalizedName);
                if (!existingPerson) {
                    const newPerson = {
                        id: generateId(),
                        name: originalName,
                        roleId: null
                    };
                    state.people.push(newPerson);
                }
            });

            // Update opportunities to reference the person
            state.opportunities.forEach(opp => {
                if (opp.contact && !opp.contactId) {
                    const normalizedContact = opp.contact.trim().toLowerCase();
                    const person = state.people.find(p => p.name.toLowerCase() === normalizedContact);
                    if (person) {
                        opp.contactId = person.id;
                    }
                }
            });
        }

        // ========================================
        // SCORING ALGORITHM FUNCTIONS
        // ========================================

        function getDaysUntilDeadline(deadline, currentDate = new Date()) {
            const deadlineDate = new Date(deadline);
            const today = new Date(currentDate);

            // Reset to start of day for comparison
            today.setHours(0, 0, 0, 0);
            const deadlineDay = new Date(deadlineDate);
            deadlineDay.setHours(0, 0, 0, 0);

            const msPerDay = 24 * 60 * 60 * 1000;
            return Math.floor((deadlineDay - today) / msPerDay);
        }

        function calculateDeadlineScore(todo, currentDate = new Date()) {
            if (!todo.deadline) return 0;

            const daysUntilDue = getDaysUntilDeadline(todo.deadline, currentDate);

            if (daysUntilDue < 0) {
                // OVERDUE: 150 base + 10 per day overdue, max 200
                return Math.min(200, 150 + (Math.abs(daysUntilDue) * 10));
            }

            if (daysUntilDue === 0) return 140;  // Due today
            if (daysUntilDue === 1) return 120;  // Due tomorrow
            if (daysUntilDue <= 3) return 100 - (daysUntilDue * 10);  // 70-90
            if (daysUntilDue <= 7) return 70 - (daysUntilDue * 5);    // 35-55
            if (daysUntilDue <= 14) return 30 - (daysUntilDue - 7);   // 23-30

            return Math.max(0, 20 - (daysUntilDue - 14));  // Distant future
        }

        function calculatePriorityScore(todo) {
            const priority = todo.priority || DEFAULT_PRIORITY;
            const weight = PRIORITY_TAGS[priority]?.weight;
            return weight ?? PRIORITY_TAGS[DEFAULT_PRIORITY].weight;
        }

        function calculateStalenessBonus(todo, currentDate = new Date()) {
            if (!todo.createdAt) return 0;

            const created = new Date(todo.createdAt);
            const today = new Date(currentDate);
            const msPerDay = 24 * 60 * 60 * 1000;
            const daysOld = Math.floor((today - created) / msPerDay);

            if (daysOld <= 7) return 0;
            if (daysOld <= 14) return 10;
            if (daysOld <= 30) return 20;
            return 30;
        }

        function calculateUrgencyScore(todo, currentDate = new Date()) {
            const deadline = calculateDeadlineScore(todo, currentDate);
            const priority = calculatePriorityScore(todo);
            const staleness = calculateStalenessBonus(todo, currentDate);

            return {
                total: deadline + priority + staleness,
                breakdown: { deadline, priority, staleness }
            };
        }

        function getScoreClassification(score) {
            if (score >= 250) return { label: 'Critical', class: 'critical' };
            if (score >= 200) return { label: 'Must Do Today', class: 'high' };
            if (score >= 150) return { label: 'High Priority', class: 'high' };
            if (score >= 100) return { label: 'Should Do Soon', class: 'medium' };
            if (score >= 50) return { label: 'Plan Ahead', class: '' };
            return { label: 'Backlog', class: '' };
        }

        // ========================================
        // DAILY PLAN GENERATION
        // ========================================

        function classifyTodos(scored, currentDate = new Date()) {
            const today = new Date(currentDate);
            today.setHours(0, 0, 0, 0);

            return {
                overdue: scored.filter(s => {
                    if (!s.todo.deadline) return false;
                    const d = new Date(s.todo.deadline);
                    d.setHours(0, 0, 0, 0);
                    return d < today;
                }),
                dueToday: scored.filter(s => {
                    if (!s.todo.deadline) return false;
                    const d = new Date(s.todo.deadline);
                    d.setHours(0, 0, 0, 0);
                    return d.getTime() === today.getTime();
                }),
                upcoming: scored.filter(s => {
                    if (!s.todo.deadline) return true; // Include todos without deadlines
                    const d = new Date(s.todo.deadline);
                    d.setHours(0, 0, 0, 0);
                    return d > today;
                })
            };
        }

        function buildPlan(classified, effectiveMinutes, config) {
            const plan = {
                date: new Date(),
                availableMinutes: effectiveMinutes,
                allocatedMinutes: 0,
                sections: {
                    overdue: [],
                    mustDoToday: [],
                    recommended: [],
                    ifTimePermits: []
                },
                warnings: [],
                insights: []
            };

            let remainingMinutes = effectiveMinutes;

            // Add overdue (capped, always shown)
            const overdueToShow = classified.overdue.slice(0, config.maxOverdueToShow);
            for (const item of overdueToShow) {
                plan.sections.overdue.push(formatScheduledItem(item));
                plan.allocatedMinutes += item.minutes;
            }

            // Add due today (always shown)
            for (const item of classified.dueToday) {
                plan.sections.mustDoToday.push(formatScheduledItem(item));
                plan.allocatedMinutes += item.minutes;
            }

            // Calculate remaining capacity
            remainingMinutes = effectiveMinutes - plan.allocatedMinutes;

            // Fill recommended from upcoming, respecting capacity
            for (const item of classified.upcoming) {
                if (remainingMinutes >= item.minutes) {
                    plan.sections.recommended.push(formatScheduledItem(item));
                    remainingMinutes -= item.minutes;
                    plan.allocatedMinutes += item.minutes;
                } else if (item.score.total >= 100) {
                    // High priority but doesn't fit
                    plan.sections.ifTimePermits.push(formatScheduledItem(item));
                }
            }

            return plan;
        }

        function formatScheduledItem(item) {
            return {
                todo: item.todo,
                urgencyScore: item.score.total,
                scoreBreakdown: item.score.breakdown,
                estimatedMinutes: item.minutes,
                reasoning: generateReasoning(item)
            };
        }

        function generateReasoning(item) {
            const parts = [];
            const daysUntil = getDaysUntilDeadline(item.todo.deadline);

            // Deadline reasoning
            if (daysUntil < 0) {
                parts.push(`Overdue by ${Math.abs(daysUntil)} day(s)`);
            } else if (daysUntil === 0) {
                parts.push("Due today");
            } else if (daysUntil === 1) {
                parts.push("Due tomorrow");
            } else if (daysUntil <= 7) {
                parts.push(`Due in ${daysUntil} days`);
            }

            // Priority reasoning (only mention if not normal)
            const priority = item.todo.priority || DEFAULT_PRIORITY;
            if (priority && priority !== "normal") {
                const priorityTag = PRIORITY_TAGS[priority];
                if (priorityTag) {
                    parts.push(priorityTag.label);
                }
            }

            // Effort reasoning
            const effort = item.todo.effort || DEFAULT_EFFORT;
            if (effort === "very_low") {
                parts.push("Quick win");
            } else if (effort === "very_high") {
                parts.push("Requires full day");
            }

            return parts.join("  ") || "Scheduled based on priority";
        }

        function generateDailyPlan(currentDate = new Date()) {
            const config = { ...DEFAULT_SETTINGS, ...state.settings };

            // Calculate effective work time
            const effectiveMinutes = Math.floor(
                config.workdayMinutes * (1 - config.bufferPercentage / 100)
            );

            // 1. Filter incomplete todos
            const incomplete = state.todos.filter(t => !t.completed);

            // 2. Score and sort
            const scored = incomplete
                .map(todo => ({
                    todo,
                    score: calculateUrgencyScore(todo, currentDate),
                    minutes: EFFORT_CONFIG[todo.effort || DEFAULT_EFFORT]?.minutes || 240
                }))
                .sort((a, b) => b.score.total - a.score.total);

            // 3. Classify by deadline status
            const classified = classifyTodos(scored, currentDate);

            // 4. Build the plan with time constraints
            const plan = buildPlan(classified, effectiveMinutes, config);

            // 5. Generate warnings and insights
            plan.warnings = generateWarnings(plan, scored, currentDate, config);
            plan.insights = generateInsights(plan, scored, currentDate);

            return plan;
        }

        // ========================================
        // WARNINGS AND INSIGHTS
        // ========================================

        function generateWarnings(plan, allScored, currentDate, config) {
            const warnings = [];

            // Check for overloaded day
            if (plan.allocatedMinutes > plan.availableMinutes) {
                const overloadHours = ((plan.allocatedMinutes - plan.availableMinutes) / 60).toFixed(1);
                warnings.push({
                    type: "overloaded",
                    severity: "critical",
                    message: `Today's critical items exceed available time by ${overloadHours} hours. Consider renegotiating deadlines or delegating.`
                });
            }

            // Check for large overdue backlog
            const totalOverdue = allScored.filter(s => getDaysUntilDeadline(s.todo.deadline) < 0).length;
            if (totalOverdue > config.maxOverdueToShow) {
                warnings.push({
                    type: "overdue_backlog",
                    severity: "warning",
                    message: `You have ${totalOverdue} overdue items total. Consider a backlog review session.`
                });
            }

            // Check for deadline cluster
            const next3Days = allScored.filter(s => {
                const d = getDaysUntilDeadline(s.todo.deadline);
                return d >= 0 && d <= 3;
            });
            const clusterMinutes = next3Days.reduce((sum, s) => sum + s.minutes, 0);

            if (clusterMinutes > config.workdayMinutes * 2) {
                const clusterHours = Math.round(clusterMinutes / 60);
                warnings.push({
                    type: "deadline_cluster",
                    severity: "warning",
                    message: `Heavy deadline cluster ahead: ${clusterHours} hours of work due in the next 3 days.`
                });
            }

            // Check for impossible single task
            const impossibleTask = allScored.find(s =>
                s.minutes > config.workdayMinutes && getDaysUntilDeadline(s.todo.deadline) <= 1
            );
            if (impossibleTask) {
                warnings.push({
                    type: "impossible_task",
                    severity: "critical",
                    message: `"${impossibleTask.todo.title}" requires ${(impossibleTask.minutes / 60).toFixed(1)} hours but is due very soon. Consider breaking it down.`
                });
            }

            return warnings;
        }

        function generateInsights(plan, allScored, currentDate) {
            const insights = [];

            // Light day opportunity
            const utilization = plan.availableMinutes > 0
                ? (plan.allocatedMinutes / plan.availableMinutes) * 100
                : 0;
            if (utilization < 50 && allScored.length > 0) {
                insights.push({
                    type: "light_day",
                    message: "Light day ahead! Good opportunity to get ahead on upcoming tasks or clear some backlog."
                });
            }

            // Quick wins available
            const quickWins = allScored.filter(s =>
                (s.todo.effort === "very_low") && s.score.total >= 50
            );
            if (quickWins.length >= 3) {
                insights.push({
                    type: "quick_wins",
                    message: `${quickWins.length} quick-win tasks available. Consider batching them to build momentum.`
                });
            }

            // All caught up
            if (plan.sections.overdue.length === 0 && plan.sections.mustDoToday.length === 0) {
                insights.push({
                    type: "caught_up",
                    message: "No overdue or urgent items! Great time to work on important-but-not-urgent tasks."
                });
            }

            // High effort concentration
            const highEffortToday = [...plan.sections.mustDoToday, ...plan.sections.recommended]
                .filter(s => s.todo.effort === "high" || s.todo.effort === "very_high");
            if (highEffortToday.length >= 2) {
                insights.push({
                    type: "high_effort",
                    message: "Multiple high-effort tasks today. Consider tackling the hardest one during your peak energy hours."
                });
            }

            return insights;
        }

        // ========================================
        // FORMATTING HELPERS
        // ========================================

        function formatDeadlineDisplay(deadline, currentDate = new Date()) {
            if (!deadline) return 'No deadline';

            const days = getDaysUntilDeadline(deadline, currentDate);

            if (days < -1) return `${Math.abs(days)} days overdue`;
            if (days === -1) return "Yesterday";
            if (days === 0) return "Today";
            if (days === 1) return "Tomorrow";
            if (days <= 7) return `In ${days} days`;

            return new Date(deadline).toLocaleDateString("en-US", {
                month: "short",
                day: "numeric"
            });
        }

        function formatEffortDisplay(effort) {
            const config = EFFORT_CONFIG[effort || DEFAULT_EFFORT];
            if (!config) return '4 hrs';
            if (config.minutes < 60) {
                return `${config.minutes} min`;
            }
            return `${config.minutes / 60} hrs`;
        }

        function formatPlanSummary(plan) {
            const overdueCount = plan.sections.overdue.length;
            const todayCount = plan.sections.mustDoToday.length;
            const totalHours = (plan.allocatedMinutes / 60).toFixed(1);

            const parts = [];
            if (overdueCount > 0) parts.push(`${overdueCount} overdue`);
            if (todayCount > 0) parts.push(`${todayCount} due today`);
            parts.push(`${totalHours} hrs planned`);

            return parts.join("  ");
        }

        function formatDateHeader(date = new Date()) {
            return date.toLocaleDateString("en-US", {
                weekday: "long",
                month: "long",
                day: "numeric",
                year: "numeric"
            });
        }

        // ========================================
        // RECOMMENDATION PANEL RENDERING
        // ========================================

        function renderRecommendationPanel() {
            const plan = generateDailyPlan();

            // Update header
            recommendationDateText.textContent = `Daily Plan  ${formatDateHeader()}`;
            recommendationSummary.textContent = formatPlanSummary(plan);

            // Render warnings
            renderWarnings(plan.warnings);

            // Render sections
            renderRecommendationSection(overdueSection, overdueItems, overdueCount, plan.sections.overdue);
            renderRecommendationSection(mustDoSection, mustDoItems, mustDoCount, plan.sections.mustDoToday);
            renderRecommendationSection(recommendedSection, recommendedItems, recommendedCount, plan.sections.recommended);
            renderRecommendationSection(ifTimeSection, ifTimeItems, ifTimeCount, plan.sections.ifTimePermits);

            // Render insights
            renderInsights(plan.insights);

            // Show/hide empty state
            const hasItems = plan.sections.overdue.length > 0 ||
                           plan.sections.mustDoToday.length > 0 ||
                           plan.sections.recommended.length > 0 ||
                           plan.sections.ifTimePermits.length > 0;
            recommendationEmpty.classList.toggle('hidden', hasItems);
        }

        function renderRecommendationSection(sectionEl, itemsEl, countEl, items) {
            sectionEl.classList.toggle('hidden', items.length === 0);
            countEl.textContent = items.length;
            itemsEl.innerHTML = '';

            items.forEach((item, index) => {
                const itemEl = createRecommendationItemElement(item, index);
                itemsEl.appendChild(itemEl);
            });
        }

        function createRecommendationItemElement(item, index) {
            const div = document.createElement('div');
            div.className = `recommendation-item ${item.todo.completed ? 'completed' : ''}`;

            const priority = item.todo.priority || DEFAULT_PRIORITY;
            const effort = item.todo.effort || DEFAULT_EFFORT;
            const scoreClass = getScoreClassification(item.urgencyScore);

            // Build tags HTML
            let tagsHtml = '';
            if (priority !== 'normal') {
                const priorityTag = PRIORITY_TAGS[priority];
                tagsHtml += `<span class="priority-pill priority-${priority}">${priorityTag.label}</span>`;
            }

            // Add user tags
            if (item.todo.tagIds && item.todo.tagIds.length > 0) {
                item.todo.tagIds.forEach(tagId => {
                    const tag = state.tags.find(t => t.id === tagId);
                    if (tag) {
                        tagsHtml += `<span class="tag-pill" style="background-color: ${tag.color}20; color: ${tag.color}; border: 1px solid ${tag.color}40;">${escapeHtml(tag.name)}</span>`;
                    }
                });
            }

            div.innerHTML = `
                <div class="recommendation-item-header">
                    <div class="recommendation-item-checkbox ${item.todo.completed ? 'checked' : ''}"
                         onclick="toggleTodoFromRecommendation('${item.todo.id}')"></div>
                    <div class="recommendation-item-title">${escapeHtml(item.todo.title)}</div>
                </div>
                <div class="recommendation-item-meta">
                    <span class="recommendation-item-effort"> ${formatEffortDisplay(effort)}</span>
                    <span class="recommendation-item-deadline"> ${formatDeadlineDisplay(item.todo.deadline)}</span>
                </div>
                ${tagsHtml ? `<div class="recommendation-item-tags">${tagsHtml}</div>` : ''}
                <div class="recommendation-item-reasoning">${item.reasoning}</div>
                <div class="recommendation-item-score">
                    <span class="score-badge ${scoreClass.class}">Score: ${item.urgencyScore}</span>
                </div>
            `;

            return div;
        }

        function renderWarnings(warnings) {
            warningsSection.innerHTML = '';
            warningsSection.classList.toggle('hidden', warnings.length === 0);

            warnings.forEach(warning => {
                const card = document.createElement('div');
                card.className = `warning-card ${warning.severity === 'critical' ? 'critical' : ''}`;
                card.innerHTML = `
                    <span class="warning-icon"></span>
                    <span class="warning-message">${escapeHtml(warning.message)}</span>
                `;
                warningsSection.appendChild(card);
            });
        }

        function renderInsights(insights) {
            insightsSection.classList.toggle('hidden', insights.length === 0);
            insightsItems.innerHTML = '';

            insights.forEach(insight => {
                const card = document.createElement('div');
                card.className = 'insight-card';
                card.innerHTML = `
                    <span class="insight-icon"></span>
                    <span class="insight-message">${escapeHtml(insight.message)}</span>
                `;
                insightsItems.appendChild(card);
            });
        }

        function toggleTodoFromRecommendation(todoId) {
            const index = state.todos.findIndex(t => t.id === todoId);
            if (index !== -1) {
                toggleTodo(index);
            }
        }

        // ========================================
        // PRIORITY AUTOCOMPLETE FUNCTIONS
        // ========================================

        function renderPriorityDropdown(filter = '') {
            priorityDropdown.innerHTML = '';
            const filterLower = filter.toLowerCase();

            Object.entries(PRIORITY_TAGS).forEach(([key, priority], index) => {
                if (filter && !priority.label.toLowerCase().includes(filterLower) &&
                    !priority.name.toLowerCase().includes(filterLower)) {
                    return;
                }

                const option = document.createElement('div');
                option.className = `priority-option ${state.selectedPriority === key ? 'selected' : ''} ${state.priorityHighlightIndex === index ? 'highlighted' : ''}`;
                option.innerHTML = `
                    <span class="priority-option-color" style="background-color: ${priority.color}"></span>
                    <span class="priority-option-label">${priority.label}</span>
                    <span class="priority-option-desc">${priority.description}</span>
                `;
                option.onclick = () => selectPriority(key);
                priorityDropdown.appendChild(option);
            });
        }

        function selectPriority(key) {
            state.selectedPriority = key;
            todoPriorityInput.value = PRIORITY_TAGS[key].label;
            closePriorityDropdown();
        }

        function openPriorityDropdown() {
            state.priorityDropdownOpen = true;
            state.priorityHighlightIndex = -1;
            renderPriorityDropdown(todoPriorityInput.value);
            priorityDropdown.classList.add('open');
        }

        function closePriorityDropdown() {
            state.priorityDropdownOpen = false;
            state.priorityHighlightIndex = -1;
            priorityDropdown.classList.remove('open');
        }

        // Priority input event listeners
        if (todoPriorityInput) {
            todoPriorityInput.addEventListener('focus', () => {
                openPriorityDropdown();
            });

            todoPriorityInput.addEventListener('input', (e) => {
                openPriorityDropdown();
                renderPriorityDropdown(e.target.value);
            });

            todoPriorityInput.addEventListener('keydown', (e) => {
                const options = Object.keys(PRIORITY_TAGS);

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    state.priorityHighlightIndex = Math.min(state.priorityHighlightIndex + 1, options.length - 1);
                    renderPriorityDropdown(todoPriorityInput.value);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    state.priorityHighlightIndex = Math.max(state.priorityHighlightIndex - 1, 0);
                    renderPriorityDropdown(todoPriorityInput.value);
                } else if (e.key === 'Enter' && state.priorityDropdownOpen) {
                    e.preventDefault();
                    if (state.priorityHighlightIndex >= 0 && state.priorityHighlightIndex < options.length) {
                        selectPriority(options[state.priorityHighlightIndex]);
                    }
                } else if (e.key === 'Escape') {
                    closePriorityDropdown();
                }
            });

            todoPriorityInput.addEventListener('blur', () => {
                // Delay to allow click events on dropdown items
                setTimeout(() => {
                    // Validate input - if not a valid priority, reset to selected
                    const inputValue = todoPriorityInput.value.toLowerCase();
                    const matchingKey = Object.keys(PRIORITY_TAGS).find(
                        key => PRIORITY_TAGS[key].label.toLowerCase() === inputValue ||
                               PRIORITY_TAGS[key].name.toLowerCase() === inputValue
                    );

                    if (matchingKey) {
                        state.selectedPriority = matchingKey;
                    }

                    // Always show the selected priority label
                    todoPriorityInput.value = PRIORITY_TAGS[state.selectedPriority].label;
                    closePriorityDropdown();
                }, 200);
            });
        }

        // ========================================
        // PLANNING SETTINGS FUNCTIONS
        // ========================================

        function savePlanningSettings(event) {
            event.preventDefault();

            state.settings.workdayMinutes = parseInt(document.getElementById('workday-minutes').value) || DEFAULT_SETTINGS.workdayMinutes;
            state.settings.bufferPercentage = parseInt(document.getElementById('buffer-percentage').value) || DEFAULT_SETTINGS.bufferPercentage;
            state.settings.maxOverdueToShow = parseInt(document.getElementById('max-overdue').value) || DEFAULT_SETTINGS.maxOverdueToShow;
            state.settings.planningHorizonDays = parseInt(document.getElementById('planning-horizon').value) || DEFAULT_SETTINGS.planningHorizonDays;

            // Refresh recommendation panel with new settings
            if (state.currentPage === 'app' && state.currentTab === 'home') {
                renderRecommendationPanel();
            }

            alert('Planning settings saved successfully!');
        }

        function loadPlanningSettings() {
            document.getElementById('workday-minutes').value = state.settings.workdayMinutes;
            document.getElementById('buffer-percentage').value = state.settings.bufferPercentage;
            document.getElementById('max-overdue').value = state.settings.maxOverdueToShow;
            document.getElementById('planning-horizon').value = state.settings.planningHorizonDays;
        }

        function renderPlanningSettings() {
            loadPlanningSettings();
        }

        // ========================================
        // DATETIME HELPERS
        // ========================================

        function getDefaultDeadline() {
            const now = new Date();
            now.setHours(17, 0, 0, 0); // Default to 5 PM today
            return formatDateTimeLocal(now);
        }

        function formatDateTimeLocal(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Run migration on startup
            migrateContactsToPeople();
            navigateTo('landing');
        });
    </script>
</body>
</html>
