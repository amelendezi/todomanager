<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TodoManager - Manage Your Tasks Efficiently</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #F5F5F5 0%, #E8E8E8 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
            overflow-x: hidden;
        }

        .container {
            max-width: 600px;
            width: 100%;
            text-align: center;
            animation: fadeIn 0.6s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .logo-container {
            margin-bottom: 48px;
            animation: slideDown 0.8s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .logo {
            width: 120px;
            height: 120px;
            margin: 0 auto 24px;
            filter: drop-shadow(0 4px 12px rgba(255, 184, 0, 0.3));
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        .logo:hover {
            animation: float 3s ease-in-out infinite, pulse 0.6s ease;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        h1 {
            font-size: 48px;
            font-weight: 700;
            color: #1F1F1F;
            margin-bottom: 16px;
            letter-spacing: -1px;
        }

        .tagline {
            font-size: 18px;
            color: #6C757D;
            margin-bottom: 64px;
            font-weight: 400;
        }

        .options-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-bottom: 32px;
        }

        .option-card {
            background: white;
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid transparent;
            animation: slideUp 0.6s ease;
            animation-fill-mode: both;
        }

        .option-card:nth-child(1) {
            animation-delay: 0.2s;
        }

        .option-card:nth-child(2) {
            animation-delay: 0.3s;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .option-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            border-color: #FFB800;
        }

        .option-card:active {
            transform: translateY(-2px) scale(1.01);
        }

        .option-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            background: linear-gradient(135deg, #FFB800 0%, #FFA000 100%);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .option-card:hover .option-icon {
            transform: rotate(5deg) scale(1.1);
            box-shadow: 0 4px 16px rgba(255, 184, 0, 0.4);
        }

        .option-icon svg {
            width: 36px;
            height: 36px;
            color: #1F1F1F;
        }

        .option-title {
            font-size: 24px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 8px;
        }

        .option-description {
            font-size: 14px;
            color: #6C757D;
            line-height: 1.5;
        }

        .footer {
            margin-top: 48px;
            font-size: 14px;
            color: #ADB5BD;
            animation: fadeIn 0.8s ease 0.5s both;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 36px;
            }

            .tagline {
                font-size: 16px;
                margin-bottom: 48px;
            }

            .logo {
                width: 100px;
                height: 100px;
            }

            .option-card {
                padding: 24px;
            }

            .option-title {
                font-size: 20px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Page visibility */
        .hidden {
            display: none !important;
        }

        .page {
            min-height: 100vh;
            width: 100%;
        }

        /* Header styles */
        .header {
            height: 60px;
            background: #FFFFFF;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 24px;
        }

        .header-title {
            font-size: 16px;
            font-weight: 500;
            color: #1F1F1F;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: 4px;
        }

        .tab-btn {
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            color: #6C757D;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tab-btn:hover {
            color: #1F1F1F;
            background: #F8F9FA;
        }

        .tab-btn.active {
            color: #1F1F1F;
            background: #FFB800;
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        /* Search Control Styles */
        .header-search {
            display: flex;
            align-items: center;
            flex: 1;
            justify-content: flex-end;
            margin-right: 16px;
        }

        .search-container {
            position: relative;
            display: flex;
            align-items: center;
            width: 240px;
        }

        .search-icon {
            position: absolute;
            left: 12px;
            width: 16px;
            height: 16px;
            color: #9CA3AF;
            pointer-events: none;
        }

        .search-input {
            width: 100%;
            height: 36px;
            padding: 0 12px 0 36px;
            font-size: 14px;
            color: #1F1F1F;
            background: #F8F9FA;
            border: 1px solid #E5E7EB;
            border-radius: 18px;
            outline: none;
            transition: all 0.2s ease;
        }

        .search-input::placeholder {
            color: #9CA3AF;
        }

        .search-input:focus {
            background: #FFFFFF;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.15);
        }

        .search-input:hover:not(:focus) {
            border-color: #D1D5DB;
        }

        .icon-button {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }

        .icon-button:hover {
            background: #F8F9FA;
        }

        .icon-button:active {
            transform: scale(0.95);
        }

        .icon-button svg {
            width: 24px;
            height: 24px;
            color: #6C757D;
            transition: color 0.2s ease, transform 0.3s ease;
        }

        .icon-button:hover svg {
            color: #1F1F1F;
        }

        /* Settings icon rotation on hover */
        .icon-button[title="Settings"]:hover svg {
            transform: rotate(90deg);
        }

        /* Main content area */
        .main-content {
            padding-top: 84px;
            padding-left: 24px;
            padding-right: 24px;
            padding-bottom: 24px;
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Todo list styles */
        .todo-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .todo-item {
            background: #FFFFFF;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s ease;
        }

        .todo-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translateY(-2px);
        }

        .todo-checkbox {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #E0E0E0;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.2s ease;
        }

        .todo-checkbox.checked {
            background: #00A86B;
            border-color: #00A86B;
        }

        .todo-content {
            flex: 1;
            display: flex;
            gap: 16px;
            align-items: flex-start;
        }

        .todo-info {
            flex: 0 0 auto;
            min-width: 180px;
            max-width: 50%;
        }

        .todo-description {
            flex: 1;
            font-size: 13px;
            color: #6C757D;
            line-height: 1.4;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }

        .todo-item.completed .todo-description {
            color: #ADB5BD;
        }

        .todo-item.dropped .todo-description {
            color: #E57373;
        }

        .todo-title {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
        }

        /* Empty state styles */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 64px 24px;
            animation: fadeIn 0.5s ease;
        }

        .empty-icon {
            width: 64px;
            height: 64px;
            color: #ADB5BD;
            margin-bottom: 16px;
        }

        .empty-text {
            font-size: 16px;
            font-weight: 500;
            color: #ADB5BD;
        }

        /* Keyboard shortcut hint text */
        .shortcut-hint {
            font-size: 13px;
            font-style: italic;
            color: #ADB5BD;
            margin-top: 12px;
        }

        .shortcut-hint-floating {
            font-size: 12px;
            font-style: italic;
            color: #ADB5BD;
            text-align: center;
            padding: 8px 0;
            margin-bottom: 8px;
        }

        /* Home page body override */
        #home-page {
            background: #F5F5F5;
        }

        /* Responsive styles for home page */
        @media (max-width: 768px) {
            .header {
                padding: 0 16px;
            }

            .main-content {
                padding-left: 16px;
                padding-right: 16px;
            }
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            position: relative;
            background: #FFFFFF;
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 480px;
            max-height: calc(100vh - 48px);
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            animation: modalSlideIn 0.3s ease;
            transform-origin: center center;
            transition: max-width 300ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Expanded state for horizontal inline creation */
        .modal-content.expanded {
            max-width: 900px;
            overflow-y: visible;
        }

        /* Two-column layout container */
        .todo-form-columns {
            display: flex;
            gap: 0;
        }

        .todo-form-columns.expanded {
            gap: 24px;
        }

        /* Left column - main todo form */
        .todo-form-left {
            flex: 1;
            min-width: 0;
        }

        /* Vertical separator between columns */
        .column-separator {
            width: 0;
            background-color: #E5E7EB;
            align-self: stretch;
            opacity: 0;
            transition: width 200ms ease-in-out 100ms, opacity 200ms ease-in-out 100ms;
        }

        .todo-form-columns.expanded .column-separator {
            width: 1px;
            opacity: 1;
        }

        /* Right column - inline engagement panel */
        .todo-form-right {
            flex: 0 0 0;
            min-width: 0;
            overflow: hidden;
            opacity: 0;
            transition: flex-basis 300ms cubic-bezier(0.4, 0, 0.2, 1),
                        opacity 200ms ease-in-out;
        }

        .todo-form-columns.expanded .todo-form-right {
            flex: 0 0 380px;
            opacity: 1;
        }

        /* Disabled state for main form when inline is active */
        .todo-form-left.disabled .form-input,
        .todo-form-left.disabled .form-textarea,
        .todo-form-left.disabled .effort-select,
        .todo-form-left.disabled .priority-input,
        .todo-form-left.disabled .autocomplete-input,
        .todo-form-left.disabled .tag-input {
            background-color: #F9FAFB;
            color: #9CA3AF;
            pointer-events: none;
        }

        .todo-form-left.disabled .form-label {
            color: #9CA3AF;
        }

        /* Right panel engagement inline form - visible by default when in right column */
        .inline-eng-panel {
            padding: 0;
        }

        .inline-eng-panel .inline-eng-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid #E5E7EB;
        }

        .inline-eng-panel .inline-eng-panel-title {
            font-size: 16px;
            font-weight: 600;
            color: #374151;
        }

        .inline-eng-panel .inline-eng-panel-actions {
            display: flex;
            gap: 8px;
        }

        .inline-eng-panel .form-group {
            margin-bottom: 16px;
        }

        .inline-eng-panel .form-group:last-of-type {
            margin-bottom: 20px;
        }

        /* Contact inline form within right panel */
        .inline-contact-form {
            background: #F9FAFB;
            border: 1px solid transparent;
            border-radius: 8px;
            padding: 0;
            margin-top: 12px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 250ms cubic-bezier(0.4, 0, 0.2, 1),
                        padding 250ms cubic-bezier(0.4, 0, 0.2, 1),
                        border-color 150ms ease-in-out;
        }

        .inline-contact-form.open {
            max-height: 250px;
            padding: 16px;
            border-color: #E5E7EB;
        }

        .inline-contact-form .inline-contact-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .inline-contact-form .inline-contact-title {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
        }

        .inline-contact-form .inline-contact-actions {
            display: flex;
            gap: 8px;
        }

        .inline-contact-form .inline-contact-actions .btn {
            padding: 6px 12px;
            font-size: 12px;
        }

        .inline-contact-form .form-group {
            margin-bottom: 12px;
        }

        .inline-contact-form .form-group:last-of-type {
            margin-bottom: 0;
        }

        .inline-contact-form .form-label {
            font-size: 12px;
            margin-bottom: 4px;
        }

        .inline-contact-form .form-input {
            height: 40px;
            padding: 8px 12px;
            font-size: 13px;
        }

        /* Inline engagement textarea styling */
        .inline-eng-textarea {
            min-height: 60px;
            max-height: 100px;
            resize: vertical;
        }

        /* Panel actions at bottom of right column */
        .inline-eng-panel-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #E5E7EB;
        }

        /* Animation for right panel slide-in */
        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .todo-form-right.animate-in {
            animation: slideInRight 300ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Reduced motion preference */
        @media (prefers-reduced-motion: reduce) {
            .modal-content {
                transition: none;
            }
            .todo-form-right,
            .column-separator,
            .inline-contact-form {
                transition: none;
            }
            .todo-form-right.animate-in {
                animation: none;
            }
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 24px;
        }

        /* Issue-101: Modal header with edit button */
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .modal-header .modal-title {
            margin-bottom: 0;
        }

        .modal-edit-btn {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 1px solid #E0E0E0;
            background: #FFFFFF;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6C757D;
            transition: all 0.2s ease;
        }

        .modal-edit-btn:hover {
            background: #F5A623;
            border-color: #F5A623;
            color: #FFFFFF;
        }

        .modal-edit-btn svg {
            width: 18px;
            height: 18px;
        }

        /* Issue-101: Read-only view styles */
        .todo-readonly-view {
            padding: 0;
        }

        .todo-readonly-field {
            margin-bottom: 16px;
        }

        .todo-readonly-label {
            font-size: 12px;
            font-weight: 500;
            color: #6C757D;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .todo-readonly-value {
            font-size: 15px;
            color: #1F1F1F;
            line-height: 1.5;
        }

        .todo-readonly-value.title {
            font-size: 18px;
            font-weight: 600;
        }

        .todo-readonly-value.description {
            white-space: pre-wrap;
            background: #F8F9FA;
            padding: 12px;
            border-radius: 8px;
        }

        .todo-readonly-value.empty {
            color: #9CA3AF;
            font-style: italic;
        }

        .todo-readonly-engagement {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: #E3F2FD;
            border-radius: 6px;
            color: #1565C0;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }

        .todo-readonly-engagement:hover {
            background: #BBDEFB;
        }

        .todo-readonly-engagement svg {
            width: 14px;
            height: 14px;
        }

        .todo-readonly-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .todo-readonly-close-btn {
            width: 100%;
            margin-top: 24px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 8px;
        }

        .form-label .required {
            color: #DC3545;
        }

        .form-input {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .form-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .form-input::placeholder {
            color: #ADB5BD;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 24px;
        }

        .btn {
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .btn-primary {
            background: #FFB800;
            color: #1F1F1F;
        }

        .btn-primary:hover {
            background: #E5A600;
            transform: scale(1.02);
        }

        .btn-secondary {
            background: #F8F9FA;
            color: #6C757D;
        }

        .btn-secondary:hover {
            background: #E9ECEF;
        }

        /* Disabled button state */
        .btn:disabled,
        .btn.btn-disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        .btn-primary:disabled,
        .btn-primary.btn-disabled {
            background: #FFB800;
        }

        /* Tooltip wrapper for disabled button */
        .btn-tooltip-wrapper {
            position: relative;
            display: inline-block;
        }

        .btn-tooltip-wrapper[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            margin-bottom: 8px;
            z-index: 1000;
        }

        .btn-tooltip-wrapper[data-tooltip]:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #333;
            margin-bottom: -4px;
            z-index: 1000;
        }

        /* Todo item with due date */
        .todo-due-date {
            font-size: 12px;
            color: #6C757D;
            margin-top: 4px;
        }

        .todo-due-date.overdue {
            color: #DC3545;
        }

        .todo-item.completed .todo-title {
            text-decoration: line-through;
            color: #ADB5BD;
        }

        .todo-item.dropped {
            opacity: 0.6;
        }

        .todo-item.dropped .todo-title {
            text-decoration: line-through;
            color: #E57373;
        }

        .todo-item.dropped .todo-checkbox {
            background: #FFCDD2;
            border-color: #E57373;
        }

        .todo-item.dropped .todo-checkbox::after {
            content: '✕';
            display: block;
            color: #C62828;
            font-size: 10px;
            line-height: 16px;
            text-align: center;
            border: none;
            transform: none;
            width: auto;
            height: auto;
            margin: 0;
        }

        /* Blocked todo styles (Issue-67) */
        .todo-item.blocked {
            opacity: 0.5;
            background: #F5F5F5;
        }

        .todo-item.blocked .todo-title {
            color: #9E9E9E;
        }

        .todo-item.blocked .todo-checkbox {
            background: #E0E0E0;
            border-color: #BDBDBD;
            cursor: not-allowed;
        }

        .todo-item.blocked .todo-checkbox::after {
            content: '⏸';
            display: block;
            color: #757575;
            font-size: 10px;
            line-height: 16px;
            text-align: center;
            border: none;
            transform: none;
            width: auto;
            height: auto;
            margin: 0;
        }

        .todo-item.blocked .todo-due-date,
        .todo-item.blocked .todo-engagement,
        .todo-item.blocked .todo-description {
            color: #BDBDBD;
        }

        /* Collapsible sections for completed/dropped todos (Issue-97) */
        .todo-collapsible-section {
            margin-top: 16px;
            border-radius: 12px;
            background: #f8f9fa;
            overflow: hidden;
        }

        .todo-collapsible-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.15s ease;
        }

        .todo-collapsible-header:hover {
            background: #e9ecef;
        }

        .todo-collapsible-icon {
            width: 16px;
            height: 16px;
            color: #6C757D;
            transition: transform 0.2s ease;
            flex-shrink: 0;
        }

        .todo-collapsible-section.expanded .todo-collapsible-icon {
            transform: rotate(90deg);
        }

        .todo-collapsible-title {
            font-size: 14px;
            font-weight: 600;
            color: #495057;
            flex: 1;
        }

        .todo-collapsible-count {
            font-size: 12px;
            color: #6C757D;
            background: #dee2e6;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .todo-collapsible-content {
            display: none;
            padding: 0 12px 12px 12px;
        }

        .todo-collapsible-section.expanded .todo-collapsible-content {
            display: block;
        }

        .todo-collapsible-content .todo-item {
            margin-top: 8px;
        }

        .todo-collapsible-content .todo-item:first-child {
            margin-top: 0;
        }

        /* Completed section has green tint */
        .todo-collapsible-section.completed-section {
            background: #f0f9f4;
        }

        .todo-collapsible-section.completed-section .todo-collapsible-header:hover {
            background: #d4edda;
        }

        .todo-collapsible-section.completed-section .todo-collapsible-count {
            background: #c3e6cb;
            color: #155724;
        }

        /* Dropped section has red tint */
        .todo-collapsible-section.dropped-section {
            background: #fdf2f2;
        }

        .todo-collapsible-section.dropped-section .todo-collapsible-header:hover {
            background: #f8d7da;
        }

        .todo-collapsible-section.dropped-section .todo-collapsible-count {
            background: #f5c6cb;
            color: #721c24;
        }

        /* Issue-99: Upcoming in a Week section - blue tint */
        .todo-collapsible-section.upcoming-week-section {
            background: #e8f4fd;
        }

        .todo-collapsible-section.upcoming-week-section .todo-collapsible-header:hover {
            background: #cce5fc;
        }

        .todo-collapsible-section.upcoming-week-section .todo-collapsible-count {
            background: #b3d7fa;
            color: #0d47a1;
        }

        /* Issue-99: Upcoming in 2 Weeks section - purple tint */
        .todo-collapsible-section.upcoming-two-weeks-section {
            background: #f3e8fd;
        }

        .todo-collapsible-section.upcoming-two-weeks-section .todo-collapsible-header:hover {
            background: #e4ccfc;
        }

        .todo-collapsible-section.upcoming-two-weeks-section .todo-collapsible-count {
            background: #d4b3fa;
            color: #4a148c;
        }

        /* Issue-99: In the Horizon section - gray/neutral tint */
        .todo-collapsible-section.horizon-section {
            background: #f5f5f5;
        }

        .todo-collapsible-section.horizon-section .todo-collapsible-header:hover {
            background: #e0e0e0;
        }

        .todo-collapsible-section.horizon-section .todo-collapsible-count {
            background: #bdbdbd;
            color: #424242;
        }

        /* Daily Load highlight (Issue-74) */
        .todo-item.daily-load-highlighted {
            box-shadow: 0 0 0 3px #F5A623, 0 4px 12px rgba(245, 166, 35, 0.3);
            animation: daily-load-pulse 0.5s ease-out;
        }

        @keyframes daily-load-pulse {
            0% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        /* Block/Unblock button styles */
        .todo-block-btn {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            background: transparent;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9E9E9E;
            transition: all 0.2s ease;
        }

        .todo-block-btn:hover {
            background: #FFF3E0;
            color: #FF9800;
        }

        .todo-block-btn svg {
            width: 16px;
            height: 16px;
        }

        .todo-unblock-btn {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            background: transparent;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #FF9800;
            transition: all 0.2s ease;
        }

        .todo-unblock-btn:hover {
            background: #E8F5E9;
            color: #4CAF50;
        }

        .todo-unblock-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Checkmark icon inside checkbox */
        .todo-checkbox.checked::after {
            content: '';
            display: block;
            width: 8px;
            height: 5px;
            border-left: 2px solid #FFFFFF;
            border-bottom: 2px solid #FFFFFF;
            transform: rotate(-45deg);
            margin: 6px auto;
        }

        /* Todo actions (edit button) */
        .todo-actions {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: auto;
        }

        .todo-edit-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
            flex-shrink: 0;
        }

        .todo-edit-btn:hover {
            background: #F0F0F0;
        }

        .todo-edit-btn svg {
            width: 18px;
            height: 18px;
            color: #6C757D;
            transition: color 0.2s ease;
        }

        .todo-edit-btn:hover svg {
            color: #1F1F1F;
        }

        /* Modal responsive */
        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                padding: 20px;
            }

            .modal-actions {
                flex-direction: column-reverse;
            }

            .btn {
                width: 100%;
            }
        }

        /* Responsive fallback for horizontal expansion on narrow screens */
        @media (max-width: 950px) {
            .modal-content.expanded {
                max-width: 95%;
            }

            .todo-form-columns.expanded {
                flex-direction: column;
                gap: 16px;
            }

            .todo-form-columns.expanded .column-separator {
                width: 100%;
                height: 1px;
                margin: 8px 0;
            }

            .todo-form-columns.expanded .todo-form-right {
                flex: 1 1 auto;
            }
        }

        /* Engagement list styles */
        .engagement-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .engagement-item {
            background: #FFFFFF;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            align-items: center;
            gap: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .engagement-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translateY(-2px);
        }

        .engagement-content {
            flex: 1;
            min-width: 0;
        }

        .engagement-name {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 4px;
        }

        .engagement-contact {
            font-size: 12px;
            color: #6C757D;
        }

        /* Expanded engagement styles (Issue-57) */
        .engagement-item.expanded {
            flex-direction: column;
            align-items: stretch;
            cursor: default;
            transform: none;
        }

        .engagement-item.expanded:hover {
            transform: none;
        }

        .engagement-header {
            display: flex;
            align-items: center;
            gap: 16px;
            cursor: pointer;
            width: 100%;
        }

        .engagement-expanded-content {
            display: none;
            overflow: hidden;
            max-height: 0;
            opacity: 0;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, padding 0.3s ease-out;
            border-top: 1px solid #E5E7EB;
            margin-top: 12px;
            padding-top: 0;
        }

        .engagement-item.expanded .engagement-expanded-content {
            display: flex;
            max-height: 400px;
            opacity: 1;
            padding-top: 16px;
        }

        .engagement-expanded-panes {
            display: flex;
            gap: 24px;
            width: 100%;
        }

        .engagement-left-pane {
            flex: 1;
            min-width: 0;
        }

        .engagement-right-pane {
            flex: 1;
            min-width: 0;
            max-height: 280px;
            overflow-y: auto;
            border-left: 1px solid #E5E7EB;
            padding-left: 24px;
        }

        /* Left pane content */
        .engagement-detail-row {
            display: flex;
            gap: 32px;
            margin-bottom: 16px;
        }

        .engagement-detail-group {
            flex: 1;
        }

        .engagement-detail-label {
            font-size: 12px;
            color: #6C757D;
            margin-bottom: 4px;
        }

        .engagement-detail-value {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
        }

        .engagement-detail-subtitle {
            font-size: 12px;
            color: #9CA3AF;
        }

        .engagement-description-section {
            margin-bottom: 16px;
        }

        .engagement-description-label {
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        .engagement-description-text {
            font-size: 13px;
            color: #4B5563;
            line-height: 1.5;
        }

        .engagement-action-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 16px;
        }

        .engagement-promote-btn {
            color: #2563EB;
            font-size: 13px;
            font-weight: 500;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
        }

        .engagement-promote-btn:hover {
            text-decoration: underline;
        }

        .engagement-comments-btn {
            display: flex;
            align-items: center;
            gap: 4px;
            color: #6C757D;
            font-size: 13px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .engagement-comments-btn:hover {
            background: #F3F4F6;
            color: #374151;
        }

        .engagement-comments-btn svg {
            width: 18px;
            height: 18px;
        }

        .engagement-comments-count {
            font-weight: 500;
        }

        /* Right pane - Todo list */
        .engagement-todo-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .engagement-todo-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 0;
        }

        .engagement-todo-status {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .engagement-todo-status.open {
            color: #9CA3AF;
        }

        .engagement-todo-status.done {
            color: #22C55E;
        }

        .engagement-todo-status.dropped {
            color: #EF4444;
        }

        .engagement-todo-status svg {
            width: 18px;
            height: 18px;
        }

        .engagement-todo-title {
            flex: 1;
            font-size: 13px;
            color: #1F1F1F;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .engagement-todo-item.completed .engagement-todo-title,
        .engagement-todo-item.dropped .engagement-todo-title {
            text-decoration: line-through;
            color: #9CA3AF;
        }

        /* Blocked todo in engagement sub-list (Issue-67) */
        .engagement-todo-item.blocked {
            position: relative;
            background: #F5F5F5;
        }

        .engagement-todo-item.blocked .engagement-todo-title {
            color: #BDBDBD;
        }

        .engagement-todo-item.blocked .engagement-todo-status.blocked svg {
            color: #9E9E9E;
        }

        .blocked-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(158, 158, 158, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            pointer-events: none;
        }

        .blocked-overlay-text {
            font-size: 11px;
            font-weight: 600;
            color: #757575;
            font-style: italic;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .engagement-todo-priority {
            padding: 2px 8px;
            font-size: 10px;
            font-weight: 600;
            border-radius: 4px;
            text-transform: uppercase;
            white-space: nowrap;
        }

        .engagement-todo-priority.urgent {
            background: #FEE2E2;
            color: #DC2626;
        }

        .engagement-todo-priority.high {
            background: #FFEDD5;
            color: #EA580C;
        }

        .engagement-todo-priority.normal {
            background: #FEF3C7;
            color: #D97706;
        }

        .engagement-todo-priority.low {
            background: #E5E7EB;
            color: #6B7280;
        }

        .engagement-todo-priority.someday {
            background: #F3F4F6;
            color: #9CA3AF;
        }

        .engagement-todo-effort {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            color: #6B7280;
            white-space: nowrap;
        }

        .engagement-todo-effort svg {
            width: 14px;
            height: 14px;
            color: #22C55E;
        }

        .engagement-todos-empty {
            text-align: center;
            color: #9CA3AF;
            font-size: 13px;
            padding: 24px;
        }

        /* Status badges */
        .status-badge {
            padding: 4px 12px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 16px;
            white-space: nowrap;
        }

        .status-requested {
            background: #E3F2FD;
            color: #1976D2;
        }

        .status-open {
            background: #E8F5E9;
            color: #388E3C;
        }

        .status-paused {
            background: #FFF3E0;
            color: #F57C00;
        }

        .status-cancelled {
            background: #FFEBEE;
            color: #D32F2F;
        }

        .status-closed {
            background: #F3E5F5;
            color: #7B1FA2;
        }

        /* Side Panel */
        .side-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 400px;
            max-width: 100%;
            height: 100vh;
            background: #FFFFFF;
            box-shadow: -4px 0 24px rgba(0, 0, 0, 0.15);
            z-index: 200;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .side-panel.open {
            transform: translateX(0);
        }

        .side-panel-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 199;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .side-panel-backdrop.open {
            opacity: 1;
            visibility: visible;
        }

        .side-panel-header {
            padding: 20px 24px;
            border-bottom: 1px solid #E0E0E0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .side-panel-title-wrapper {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .side-panel-title {
            font-size: 18px;
            font-weight: 600;
            color: #1F1F1F;
            margin: 0;
        }

        .side-panel-engagement-name {
            font-size: 13px;
            color: #6C757D;
            font-weight: 400;
        }

        .side-panel-close {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }

        .side-panel-close:hover {
            background: #F8F9FA;
        }

        .side-panel-close svg {
            width: 20px;
            height: 20px;
            color: #6C757D;
        }

        .side-panel-body {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .detail-group {
            margin-bottom: 20px;
        }

        .detail-label {
            font-size: 12px;
            font-weight: 500;
            color: #6C757D;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .detail-value {
            font-size: 14px;
            color: #1F1F1F;
        }

        .detail-value.editable {
            cursor: pointer;
            padding: 4px 8px;
            margin: -4px -8px;
            border-radius: 4px;
            border: 1px solid transparent;
            transition: all 0.2s ease;
        }

        .detail-value.editable:hover {
            background: #F8F9FA;
            border-color: #E0E0E0;
        }

        .detail-input {
            width: 100%;
            font-size: 14px;
            color: #1F1F1F;
            padding: 4px 8px;
            margin: -4px -8px;
            border: 1px solid #FFB800;
            border-radius: 4px;
            outline: none;
            background: #FFFEF5;
            font-family: inherit;
        }

        .detail-input:focus {
            box-shadow: 0 0 0 2px rgba(255, 184, 0, 0.2);
        }

        .detail-textarea {
            width: calc(100% + 16px);
            min-height: 60px;
            font-size: 14px;
            color: #1F1F1F;
            padding: 4px 8px;
            margin: -4px -8px;
            border: 1px solid #FFB800;
            border-radius: 4px;
            outline: none;
            background: #FFFEF5;
            font-family: inherit;
            resize: vertical;
        }

        .detail-textarea:focus {
            box-shadow: 0 0 0 2px rgba(255, 184, 0, 0.2);
        }

        .panel-contact-wrapper {
            position: relative;
        }

        .panel-contact-dropdown {
            position: absolute;
            top: 100%;
            left: -8px;
            right: -8px;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 4px;
            display: none;
        }

        .panel-contact-dropdown.open {
            display: block;
        }

        .panel-contact-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            color: #1F1F1F;
        }

        .panel-contact-item:hover,
        .panel-contact-item.highlighted {
            background: #FFF8E1;
        }

        .detail-select {
            width: 100%;
            height: 40px;
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            cursor: pointer;
            transition: border-color 0.2s ease;
        }

        .detail-select:focus {
            outline: none;
            border-color: #FFB800;
        }

        /* Responsive side panel */
        @media (max-width: 768px) {
            .side-panel {
                width: 100%;
            }
        }

        /* Autocomplete styles */
        .autocomplete-wrapper {
            position: relative;
        }

        .autocomplete-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .autocomplete-input {
            width: 100%;
            height: 48px;
            padding: 12px 40px 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .autocomplete-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .autocomplete-input::placeholder {
            color: #ADB5BD;
        }

        .autocomplete-clear {
            position: absolute;
            right: 12px;
            width: 20px;
            height: 20px;
            border: none;
            background: #E0E0E0;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease, background-color 0.2s ease;
        }

        .autocomplete-clear.visible {
            opacity: 1;
        }

        .autocomplete-clear:hover {
            background: #D0D0D0;
        }

        .autocomplete-clear svg {
            width: 12px;
            height: 12px;
            color: #6C757D;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 4px;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-height: 200px;
            overflow-y: auto;
            z-index: 10;
            display: none;
        }

        .autocomplete-dropdown.open {
            display: block;
        }

        .autocomplete-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.15s ease;
            font-size: 14px;
            color: #1F1F1F;
        }

        .autocomplete-item:hover,
        .autocomplete-item.highlighted {
            background: #F8F9FA;
        }

        .autocomplete-item-name {
            font-weight: 500;
        }

        .autocomplete-item-contact {
            font-size: 12px;
            color: #6C757D;
            margin-top: 2px;
        }

        .autocomplete-empty {
            padding: 12px 16px;
            font-size: 14px;
            color: #6C757D;
            font-style: italic;
        }

        .autocomplete-create-hint {
            padding: 8px 16px;
            font-size: 12px;
            color: #6C757D;
            background: #F8F9FA;
            border-top: 1px solid #E0E0E0;
        }

        /* Inline engagement creation form */
        .inline-eng-form {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
            background: #F8F9FA;
            border-radius: 8px;
            margin-top: 0;
            padding: 0 16px;
        }

        .inline-eng-form.open {
            max-height: 300px;
            padding: 16px;
            margin-top: 12px;
        }

        .inline-eng-form .form-group {
            margin-bottom: 12px;
        }

        .inline-eng-form .form-group:last-child {
            margin-bottom: 0;
        }

        .inline-eng-form .form-label {
            font-size: 12px;
            margin-bottom: 4px;
        }

        .inline-eng-form .form-input {
            height: 40px;
            padding: 8px 12px;
            font-size: 13px;
        }

        .inline-eng-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .inline-eng-title {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .inline-eng-actions {
            display: flex;
            gap: 8px;
        }

        .inline-eng-actions .btn {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Todo engagement badge */
        .todo-engagement {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 500;
            color: #1976D2;
            background: #E3F2FD;
            border-radius: 12px;
            margin-top: 4px;
        }

        .todo-engagement svg {
            width: 12px;
            height: 12px;
        }

        /* Engagement action buttons */
        .engagement-actions {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: 8px;
        }

        .opp-action-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease, opacity 0.2s ease;
            flex-shrink: 0;
        }

        .opp-action-btn:hover:not(:disabled) {
            background: #F0F0F0;
        }

        .opp-action-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .opp-action-btn svg {
            width: 18px;
            height: 18px;
            color: #6C757D;
            transition: color 0.2s ease;
        }

        .opp-action-btn:hover:not(:disabled) svg {
            color: #1F1F1F;
        }

        .opp-action-btn.close-btn:hover:not(:disabled) svg {
            color: #7B1FA2;
        }

        .opp-action-btn.delete-btn:hover:not(:disabled) svg {
            color: #D32F2F;
        }

        .opp-action-btn.cancel-btn:hover:not(:disabled) svg {
            color: #F57C00;
        }

        .opp-action-btn.archive-btn:hover:not(:disabled) svg {
            color: #5C6BC0;
        }

        .opp-action-btn.edit-btn:hover:not(:disabled) svg {
            color: #1976D2;
        }

        .opp-action-btn.complete-btn:hover:not(:disabled) svg {
            color: #388E3C;
        }

        .opp-action-btn.reactivate-btn:hover:not(:disabled) svg {
            color: #0288D1;
        }

        .opp-action-btn.uncancel-btn:hover:not(:disabled) svg {
            color: #0288D1;
        }

        /* Allocation timeline bar in engagement list (Issue-69, Issue-72) */
        .allocation-timeline-bar {
            display: flex;
            align-items: center;
            gap: 4px;
            flex-shrink: 0;
            margin-left: auto;
            margin-right: 16px;
        }

        .allocation-timeline-nav-btn {
            width: 20px;
            height: 20px;
            border: none;
            background: transparent;
            color: #6C757D;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            flex-shrink: 0;
        }

        .allocation-timeline-nav-btn:hover:not(:disabled) {
            background: #F3F4F6;
            color: #374151;
        }

        .allocation-timeline-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .allocation-timeline-months {
            display: flex;
            gap: 4px;
        }

        .allocation-pebble {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .allocation-pebble-dot {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 600;
            color: #fff;
        }

        .allocation-pebble-dot.preproject {
            background: #F5A623;
        }

        .allocation-pebble-dot.project {
            background: #10B981;
        }

        .allocation-pebble-dot.empty {
            background: #E5E7EB;
            color: transparent;
        }

        .allocation-pebble-label {
            font-size: 9px;
            color: #9CA3AF;
            font-weight: 500;
        }

        /* Hide timeline bar on smaller screens */
        @media (max-width: 900px) {
            .allocation-timeline-bar {
                display: none;
            }
        }

        /* Archived engagement styling */
        .engagement-item.archived {
            opacity: 0.6;
        }

        .engagement-item.archived .engagement-name {
            text-decoration: line-through;
        }

        /* Show Archived Toggle */
        .archive-toggle-container {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            margin-bottom: 16px;
            padding-right: 8px;
        }

        .archive-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 13px;
            color: #6C757D;
            user-select: none;
        }

        .archive-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #FFB800;
            cursor: pointer;
        }

        .archive-toggle:hover {
            color: #1F1F1F;
        }

        /* Confirmation modal */
        .confirm-modal-content {
            text-align: center;
        }

        .confirm-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            color: #D32F2F;
        }

        .confirm-title {
            font-size: 20px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 12px;
        }

        .confirm-message {
            font-size: 14px;
            color: #6C757D;
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .confirm-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .btn-danger {
            background: #D32F2F;
            color: #FFFFFF;
        }

        .btn-danger:hover {
            background: #B71C1C;
        }

        /* Comments section in side panel */
        .comments-section {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid #E0E0E0;
        }

        /* Comments-only mode (side panel) */
        .comments-section.comments-only {
            margin-top: 0;
            padding-top: 0;
            border-top: none;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .comments-section.comments-only .comments-list {
            flex: 1;
            overflow-y: auto;
            max-height: none;
        }

        .comments-section.comments-only .comment-input-area {
            margin-top: auto;
            padding-top: 16px;
            border-top: 1px solid #E0E0E0;
        }

        .comments-header {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 16px;
        }

        .comments-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .comment-item {
            padding: 12px;
            background: #F8F9FA;
            border-radius: 8px;
            border-left: 3px solid #E0E0E0;
            position: relative;
        }

        .comment-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .comment-delete-btn {
            background: none;
            border: none;
            color: #ADB5BD;
            cursor: pointer;
            padding: 0;
            font-size: 16px;
            line-height: 1;
            opacity: 0;
            transition: opacity 0.2s ease, color 0.2s ease;
        }

        .comment-item:hover .comment-delete-btn {
            opacity: 1;
        }

        .comment-delete-btn:hover {
            color: #D32F2F;
        }

        .comment-item.cancellation {
            background: #FFF5F5;
            border-left-color: #D32F2F;
        }

        .comment-timestamp {
            font-size: 11px;
            color: #6C757D;
            margin-bottom: 4px;
        }

        .comment-item.cancellation .comment-timestamp {
            color: #D32F2F;
        }

        .comment-text {
            font-size: 13px;
            color: #1F1F1F;
            line-height: 1.5;
        }

        .comment-item.cancellation .comment-text {
            color: #B71C1C;
        }

        .comment-badge {
            display: inline-block;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
        }

        .comment-badge.cancellation {
            background: #FFEBEE;
            color: #D32F2F;
        }

        .no-comments {
            font-size: 13px;
            color: #ADB5BD;
            font-style: italic;
        }

        /* Comment input area */
        .comment-input-area {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #E0E0E0;
        }

        .comment-textarea {
            width: 100%;
            min-height: 80px;
            padding: 10px 12px;
            font-size: 13px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            resize: vertical;
        }

        .comment-textarea:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .comment-textarea::placeholder {
            color: #ADB5BD;
        }

        .comment-submit-btn {
            margin-top: 8px;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 500;
            background: #FFB800;
            color: #1F1F1F;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .comment-submit-btn:hover {
            background: #E5A600;
        }

        .comment-submit-btn:disabled {
            background: #E0E0E0;
            color: #ADB5BD;
            cursor: not-allowed;
        }

        /* Cancel modal with textarea */
        .cancel-modal-content {
            text-align: left;
        }

        .cancel-modal-content .modal-title {
            text-align: center;
        }

        .cancel-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            color: #F57C00;
            display: block;
        }

        .cancel-modal-content .form-group {
            margin-bottom: 20px;
        }

        .form-textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            resize: vertical;
        }

        .form-textarea:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .form-textarea::placeholder {
            color: #ADB5BD;
        }

        .btn-warning {
            background: #F57C00;
            color: #FFFFFF;
        }

        .btn-warning:hover {
            background: #E65100;
        }

        .btn-success {
            background: #388E3C;
            color: #FFFFFF;
        }

        .btn-success:hover {
            background: #2E7D32;
        }

        /* Todo Action Modal */
        .todo-action-modal-content {
            max-width: 400px;
        }

        .todo-action-buttons {
            display: flex;
            flex-direction: column;
        }

        .todo-action-buttons .btn {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Block Reason Modal (Issue-67) */
        .block-reason-modal-content {
            max-width: 400px;
        }

        .block-reason-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #E9ECEF;
            border-radius: 8px;
            font-size: 14px;
            resize: vertical;
            min-height: 80px;
            margin-bottom: 16px;
        }

        .block-reason-input:focus {
            outline: none;
            border-color: #FF9800;
            box-shadow: 0 0 0 3px rgba(255, 152, 0, 0.1);
        }

        .block-reason-hint {
            font-size: 12px;
            color: #6C757D;
            margin-bottom: 16px;
            text-align: center;
        }

        /* People page styles */
        .people-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .person-item {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .person-item:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
        }

        .person-info {
            flex: 1;
            min-width: 0;
        }

        .person-name {
            font-size: 15px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 4px;
        }

        .person-role {
            font-size: 13px;
            color: #6C757D;
        }

        .person-role-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 500;
            color: #6C757D;
            background: #F5F5F5;
            border-radius: 12px;
        }

        .person-actions {
            display: flex;
            gap: 4px;
        }

        /* Roles section */
        .roles-section {
            margin-top: 32px;
            padding-top: 24px;
            border-top: 1px solid #E0E0E0;
        }

        .roles-title {
            font-size: 14px;
            font-weight: 600;
            color: #6C757D;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .roles-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .role-tag {
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            font-size: 13px;
            color: #1F1F1F;
            background: #F5F5F5;
            border-radius: 16px;
        }

        /* Tags styles */
        .tags-section {
            margin-top: 32px;
            padding-top: 24px;
            border-top: 1px solid #E0E0E0;
        }

        .tags-title {
            font-size: 14px;
            font-weight: 600;
            color: #666;
            margin-bottom: 12px;
        }

        .tags-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .tag-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 12px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }

        .tag-item:hover {
            border-color: #BDBDBD;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .tag-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .tag-color-preview {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid rgba(0, 0, 0, 0.1);
        }

        .tag-name {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
        }

        .tag-actions {
            display: flex;
            gap: 4px;
        }

        /* Tag pill/chip for display in lists */
        .tag-pill {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            font-size: 11px;
            font-weight: 500;
            border-radius: 12px;
            margin-right: 4px;
            margin-bottom: 4px;
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            margin-top: 4px;
        }

        /* Color picker styles */
        .color-picker-wrapper {
            position: relative;
        }

        .color-picker-input {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #F5F5F5;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .color-picker-input:hover {
            border-color: #BDBDBD;
        }

        .color-picker-preview {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 2px solid rgba(0, 0, 0, 0.1);
        }

        .color-picker-value {
            font-size: 14px;
            color: #666;
            font-family: monospace;
        }

        .color-picker-native {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        /* Tag selector in modals */
        .tag-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px 0;
        }

        .tag-selector-item {
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            opacity: 0.6;
        }

        .tag-selector-item:hover {
            opacity: 0.8;
        }

        .tag-selector-item.selected {
            opacity: 1;
            border-color: rgba(0, 0, 0, 0.2);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .tag-selector-empty {
            font-size: 13px;
            color: #999;
            font-style: italic;
        }

        /* Tag input control for forms */
        .tag-input-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .selected-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .selected-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 12px;
            color: #fff;
        }

        .selected-tag .remove-tag {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            border: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            padding: 0;
            font-size: 10px;
            color: inherit;
            line-height: 1;
        }

        .selected-tag .remove-tag:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .tag-input-wrapper {
            position: relative;
        }

        .tag-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            font-size: 14px;
            background: #F5F5F5;
            transition: all 0.2s ease;
        }

        .tag-input:focus {
            outline: none;
            border-color: #F59E0B;
            background: #fff;
        }

        .tag-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #fff;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .tag-dropdown.open {
            display: block;
        }

        .tag-dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .tag-dropdown-item:hover,
        .tag-dropdown-item.highlighted {
            background: #F5F5F5;
        }

        .tag-dropdown-item .tag-color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .tag-dropdown-item.create-new {
            border-top: 1px solid #E0E0E0;
            color: #F59E0B;
            font-weight: 500;
        }

        .tag-dropdown-item.create-new .tag-color-dot {
            background: #F59E0B;
        }

        /* Inline person creation form */
        .inline-person-form {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
            background: #F8F9FA;
            border-radius: 8px;
            margin-top: 0;
            padding: 0 16px;
        }

        .inline-person-form.open {
            max-height: 200px;
            padding: 16px;
            margin-top: 12px;
        }

        .inline-person-form .form-group {
            margin-bottom: 12px;
        }

        .inline-person-form .form-group:last-child {
            margin-bottom: 0;
        }

        .inline-person-form .form-label {
            font-size: 12px;
            margin-bottom: 4px;
        }

        .inline-person-form .form-input {
            height: 40px;
            padding: 8px 12px;
            font-size: 13px;
        }

        .inline-person-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .inline-person-title {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .inline-person-actions {
            display: flex;
            gap: 8px;
        }

        .inline-person-actions .btn {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Contact badge in engagement list */
        .eng-contact-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 500;
            color: #1976D2;
            background: #E3F2FD;
            border-radius: 12px;
        }

        /* Settings page layout */
        #settings-page {
            background: #F5F5F5;
        }

        .settings-container {
            display: flex;
            min-height: calc(100vh - 60px);
            margin-top: 60px;
        }

        .settings-menu {
            width: 20%;
            background: #FFFFFF;
            border-right: 1px solid #E0E0E0;
            padding: 24px 0;
        }

        .settings-menu-title {
            font-size: 14px;
            font-weight: 600;
            color: #6C757D;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 0 24px;
            margin-bottom: 16px;
        }

        .settings-menu-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .settings-menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 24px;
            font-size: 15px;
            font-weight: 500;
            color: #1F1F1F;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .settings-menu-item:hover {
            background: #F8F9FA;
        }

        .settings-menu-item.active {
            background: #FFF8E1;
            border-left-color: #FFB800;
            color: #1F1F1F;
        }

        .settings-menu-item svg {
            width: 24px;
            height: 24px;
            color: #6C757D;
            flex-shrink: 0;
        }

        .settings-menu-item.active svg {
            color: #FFB800;
        }

        .settings-content {
            width: 80%;
            position: relative;
            padding: 24px;
            overflow-y: auto;
        }

        .settings-close-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: #FFFFFF;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .settings-close-btn:hover {
            background: #F8F9FA;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .settings-close-btn svg {
            width: 24px;
            height: 24px;
            color: #6C757D;
        }

        .settings-close-btn:hover svg {
            color: #1F1F1F;
        }

        .settings-section-title {
            font-size: 24px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 24px;
        }

        /* Responsive settings */
        @media (max-width: 768px) {
            .settings-container {
                flex-direction: column;
            }

            .settings-menu {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #E0E0E0;
                padding: 16px 0;
            }

            .settings-content {
                width: 100%;
            }
        }

        /* ========================================
           RECOMMENDATION ENGINE STYLES
           ======================================== */

        /* Split-panel layout for Todos page */
        .home-split-container {
            display: flex;
            gap: 24px;
            max-width: 2000px;
            margin: 0 auto;
        }

        /* Recommendation Panel (Left) */
        .recommendation-panel {
            width: 450px;
            min-width: 450px;
            flex-shrink: 0;
            background: #FFFFFF;
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        /* Todo Panel (Center) */
        .todo-panel {
            flex: 1;
            min-width: 500px;
        }

        /* KPI Panel (Right) - Issue-74, Issue-107: Symmetric width with Daily Plan */
        .kpi-panel {
            width: 450px;
            min-width: 450px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        /* Recommendation Header */
        .recommendation-header {
            position: relative;
            padding: 20px;
            border-bottom: 1px solid #E0E0E0;
            background: linear-gradient(135deg, #FFF8E1 0%, #FFFFFF 100%);
        }

        .recommendation-date {
            font-size: 18px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .recommendation-date-icon {
            font-size: 20px;
        }

        .recommendation-summary {
            font-size: 13px;
            color: #6C757D;
        }

        /* Recommendation Content */
        .recommendation-content {
            padding: 16px;
        }

        /* Recommendation Section */
        .recommendation-section {
            margin-bottom: 20px;
        }

        .recommendation-section:last-child {
            margin-bottom: 0;
        }

        .recommendation-section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #6C757D;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #F0F0F0;
        }

        .recommendation-section-icon {
            font-size: 14px;
        }

        .recommendation-section-count {
            background: #E9ECEF;
            color: #6C757D;
            font-size: 11px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: auto;
        }

        /* Section-specific colors */
        .recommendation-section.overdue .recommendation-section-header {
            color: #DC3545;
        }

        .recommendation-section.overdue .recommendation-section-count {
            background: #FFEBEE;
            color: #DC3545;
        }

        .recommendation-section.must-do .recommendation-section-header {
            color: #F57C00;
        }

        .recommendation-section.must-do .recommendation-section-count {
            background: #FFF3E0;
            color: #F57C00;
        }

        .recommendation-section.recommended .recommendation-section-header {
            color: #1976D2;
        }

        .recommendation-section.recommended .recommendation-section-count {
            background: #E3F2FD;
            color: #1976D2;
        }

        .recommendation-section.if-time .recommendation-section-header {
            color: #6C757D;
        }

        /* Blocked section in Daily Plan (Issue-67) */
        .recommendation-section.blocked .recommendation-section-header {
            color: #9E9E9E;
        }

        .recommendation-section.blocked .recommendation-section-icon {
            opacity: 0.6;
        }

        /* Recommendation Item - Issue-103: Compact single-line layout */
        .recommendation-item {
            background: #F8F9FA;
            border-radius: 8px;
            padding: 8px 10px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .recommendation-item:last-child {
            margin-bottom: 0;
        }

        .recommendation-item:hover {
            background: #FFFFFF;
            border-color: #E0E0E0;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.06);
        }

        .recommendation-item-checkbox {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #D0D0D0;
            flex-shrink: 0;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .recommendation-item-checkbox:hover {
            border-color: #FFB800;
        }

        .recommendation-item-checkbox.checked {
            background: #00A86B;
            border-color: #00A86B;
        }

        .recommendation-item-title {
            flex: 1;
            font-size: 13px;
            font-weight: 500;
            color: #1F1F1F;
            line-height: 1.3;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
        }

        .recommendation-item.completed .recommendation-item-title {
            text-decoration: line-through;
            color: #ADB5BD;
        }

        /* Blocked recommendation item styles (Issue-67) */
        .recommendation-item.blocked {
            opacity: 0.6;
            background: #EEEEEE;
        }

        .recommendation-item.blocked .recommendation-item-title {
            color: #9E9E9E;
        }

        .recommendation-item.blocked .recommendation-item-checkbox {
            background: #E0E0E0;
            border-color: #BDBDBD;
            cursor: not-allowed;
        }

        /* Compact meta info for single-line layout */
        .recommendation-item-meta-compact {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
            font-size: 11px;
            color: #6C757D;
        }

        .recommendation-item-effort-compact,
        .recommendation-item-deadline-compact {
            display: flex;
            align-items: center;
            gap: 2px;
            white-space: nowrap;
        }

        .recommendation-item-block-btn {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            background: transparent;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9E9E9E;
            transition: all 0.2s ease;
            opacity: 0;
            flex-shrink: 0;
        }

        .recommendation-item:hover .recommendation-item-block-btn {
            opacity: 1;
        }

        .recommendation-item-block-btn:hover {
            background: #FFF3E0;
            color: #FF9800;
        }

        .recommendation-item-block-btn svg {
            width: 12px;
            height: 12px;
        }

        /* Hide legacy multi-line elements */
        .recommendation-item-header,
        .recommendation-item-meta,
        .recommendation-item-tags,
        .recommendation-item-reasoning,
        .recommendation-item-score {
            display: none;
        }

        /* Priority pill styling - compact version */
        .priority-pill {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            padding: 2px 6px;
            font-size: 9px;
            font-weight: 600;
            border-radius: 8px;
            text-transform: uppercase;
            letter-spacing: 0.2px;
            flex-shrink: 0;
        }

        .priority-pill.priority-urgent {
            background: #FFEBEE;
            color: #C62828;
        }

        .priority-pill.priority-high {
            background: #FFF3E0;
            color: #E65100;
        }

        .priority-pill.priority-normal {
            background: #E3F2FD;
            color: #1565C0;
        }

        .priority-pill.priority-low {
            background: #F5F5F5;
            color: #616161;
        }

        .priority-pill.priority-someday {
            background: #FAFAFA;
            color: #9E9E9E;
        }

        /* Score badge - compact version */
        .score-badge {
            font-size: 9px;
            font-weight: 600;
            color: #6C757D;
            background: #E9ECEF;
            padding: 2px 6px;
            border-radius: 8px;
            flex-shrink: 0;
        }

        .score-badge.critical {
            background: #FFEBEE;
            color: #C62828;
        }

        .score-badge.high {
            background: #FFF3E0;
            color: #E65100;
        }

        .score-badge.medium {
            background: #E3F2FD;
            color: #1565C0;
        }

        /* Warning Card */
        .warning-card {
            background: #FFF3E0;
            border: 1px solid #FFE0B2;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 12px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .warning-card.critical {
            background: #FFEBEE;
            border-color: #FFCDD2;
        }

        .warning-icon {
            font-size: 16px;
            flex-shrink: 0;
        }

        .warning-message {
            font-size: 13px;
            color: #5D4037;
            line-height: 1.4;
        }

        .warning-card.critical .warning-message {
            color: #B71C1C;
        }

        /* Insight Card */
        .insight-card {
            background: #E8F5E9;
            border: 1px solid #C8E6C9;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 12px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .insight-icon {
            font-size: 16px;
            flex-shrink: 0;
        }

        .insight-message {
            font-size: 13px;
            color: #2E7D32;
            line-height: 1.4;
        }

        /* Warnings section */
        .warnings-section {
            margin-bottom: 16px;
        }

        /* Insights section */
        .insights-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #E0E0E0;
        }

        .insights-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #2E7D32;
            margin-bottom: 12px;
        }

        /* Empty recommendation state */
        .recommendation-empty {
            text-align: center;
            padding: 40px 20px;
            color: #6C757D;
        }

        .recommendation-empty-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .recommendation-empty-text {
            font-size: 14px;
        }

        /* Effort dropdown styles */
        .effort-select {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            cursor: pointer;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236C757D' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 16px center;
        }

        .effort-select:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        /* Priority autocomplete styles */
        .priority-autocomplete-wrapper {
            position: relative;
        }

        .priority-input {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .priority-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .priority-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .priority-dropdown.open {
            display: block;
        }

        .priority-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }

        .priority-option:hover,
        .priority-option.highlighted {
            background: #F8F9FA;
        }

        .priority-option.selected {
            background: #FFF8E1;
        }

        .priority-option-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .priority-option-label {
            font-size: 14px;
            color: #1F1F1F;
        }

        .priority-option-desc {
            font-size: 12px;
            color: #6C757D;
            margin-left: auto;
        }

        /* Datetime input styles */
        .datetime-input {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .datetime-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        /* Description textarea */
        .form-textarea {
            width: 100%;
            min-height: 80px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            resize: vertical;
        }

        .form-textarea:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .form-textarea::placeholder {
            color: #ADB5BD;
        }

        /* Effort display in todo list */
        .todo-effort {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            color: #6C757D;
            background: #F5F5F5;
            padding: 2px 8px;
            border-radius: 10px;
            margin-right: 8px;
        }

        .todo-effort-icon {
            font-size: 10px;
        }

        /* Priority display in todo list */
        .todo-priority {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 10px;
            margin-right: 8px;
        }

        /* Planning settings section */
        .planning-settings-form {
            max-width: 500px;
        }

        .planning-settings-form .form-group {
            margin-bottom: 20px;
        }

        .planning-settings-form .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 6px;
        }

        .planning-settings-form .form-hint {
            font-size: 12px;
            color: #6C757D;
            margin-top: 4px;
        }

        .planning-settings-form .form-input {
            max-width: 200px;
        }

        .planning-settings-form .btn-save-settings {
            margin-top: 24px;
        }

        /* ========================================
           DAILY LOAD KPI CHART - Issue-74
           ======================================== */

        .daily-load-chart {
            background: #FFFFFF;
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            padding: 20px;
        }

        .daily-load-header {
            margin-bottom: 16px;
        }

        .daily-load-title {
            font-size: 16px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 4px;
        }

        .daily-load-status {
            font-size: 13px;
            font-weight: 500;
            padding: 4px 10px;
            border-radius: 12px;
            display: inline-block;
        }

        .daily-load-status.overloaded {
            background: #FFEBEE;
            color: #DC3545;
        }

        .daily-load-status.careful {
            background: #FFF3E0;
            color: #F57C00;
        }

        .daily-load-status.balanced {
            background: #E8F5E9;
            color: #2E7D32;
        }

        .daily-load-status.light {
            background: #E3F2FD;
            color: #1976D2;
        }

        .daily-load-status.easy {
            background: #E8F5E9;
            color: #43A047;
        }

        .daily-load-container {
            display: flex;
            align-items: flex-end;
            gap: 12px;
        }

        .daily-load-scale {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            padding-right: 8px;
            width: 40px;
        }

        .daily-load-scale-mark {
            font-size: 10px;
            color: #9CA3AF;
            height: 32px;
            display: flex;
            align-items: center;
        }

        .daily-load-bars {
            display: flex;
            flex: 1;
            gap: 4px; /* Issue-107: Reduced gap for 8 columns */
            align-items: flex-end;
            justify-content: center;
        }

        .daily-load-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            min-width: 0; /* Issue-107: Allow columns to shrink */
        }

        .daily-load-column-header {
            font-size: 10px; /* Issue-107: Smaller font for 8 columns */
            color: #6C757D;
            margin-bottom: 4px;
            text-align: center;
        }

        .daily-load-column-hours {
            font-size: 9px; /* Issue-107: Smaller font for 8 columns */
            color: #9CA3AF;
            margin-bottom: 4px;
            text-align: center;
        }

        .daily-load-bar {
            width: 100%;
            min-height: 120px; /* Issue-107: Reduced height for 8 columns */
            max-height: 120px;
            display: flex;
            flex-direction: column-reverse;
            justify-content: flex-start;
            background: #F9FAFB;
            border-radius: 6px; /* Issue-107: Smaller border radius */
            overflow: hidden;
            position: relative;
        }

        .daily-load-segment {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: opacity 0.2s, transform 0.2s;
            position: relative;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            box-sizing: border-box;
        }

        /* Overdue segments always light red */
        .daily-load-segment.overdue {
            background: #F87171 !important;
        }

        .daily-load-segment:hover {
            opacity: 0.85;
            transform: scaleX(1.02);
        }

        .daily-load-segment.highlighted {
            box-shadow: inset 0 0 0 2px #1F1F1F;
        }

        .daily-load-segment.completed {
            background: #9CA3AF !important;
        }

        .daily-load-segment.completed::after {
            content: "✓";
            position: absolute;
            right: 4px;
            font-size: 8px;
        }

        /* Heat gradient colors */
        .daily-load-segment.heat-green-1 { background: #22C55E; }
        .daily-load-segment.heat-green-2 { background: #4ADE80; }
        .daily-load-segment.heat-green-3 { background: #86EFAC; }
        .daily-load-segment.heat-yellow-1 { background: #FACC15; }
        .daily-load-segment.heat-yellow-2 { background: #FDE047; }
        .daily-load-segment.heat-orange-1 { background: #FB923C; }
        .daily-load-segment.heat-orange-2 { background: #F97316; }
        .daily-load-segment.heat-red-light { background: #F87171; }
        .daily-load-segment.heat-red-intense { background: #EF4444; }

        /* Issue-107: Priority-based segment colors */
        .daily-load-segment.priority-urgent { background: #DC2626; }
        .daily-load-segment.priority-high { background: #F97316; }
        .daily-load-segment.priority-normal { background: #3B82F6; }
        .daily-load-segment.priority-low { background: #6B7280; }
        .daily-load-segment.priority-someday { background: #9CA3AF; }

        /* Issue-107: Yesterday column - completed task colors */
        .daily-load-segment.completed-ontime { background: #22C55E; }
        .daily-load-segment.completed-extra { background: #166534; }
        .daily-load-segment.overdue-missed { background: #FCA5A5; }

        /* Issue-107: Column border color coding based on workload */
        .daily-load-bar.workload-easy {
            border: 2px solid #22C55E;
        }
        .daily-load-bar.workload-moderate {
            border: 2px solid #CA8A04;
        }
        .daily-load-bar.workload-heavy {
            border: 2px solid #F97316;
        }
        .daily-load-bar.workload-overloaded {
            border: 2px solid #DC2626;
        }

        .daily-load-empty {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #D1D5DB;
            font-size: 11px;
        }

        .daily-load-label {
            font-size: 9px; /* Issue-107: Smaller font for 8 columns */
            color: #6C757D;
            margin-top: 6px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        /* Responsive split-panel */
        @media (max-width: 1400px) {
            .home-split-container {
                flex-wrap: wrap;
            }

            .kpi-panel {
                width: 100%;
                min-width: 100%;
                order: -1;
                margin-bottom: 24px;
            }

            .daily-load-bars {
                justify-content: center;
            }

            .daily-load-column {
                max-width: 120px;
            }
        }

        @media (max-width: 1024px) {
            .home-split-container {
                flex-direction: column;
            }

            .recommendation-panel {
                width: 100%;
                min-width: 100%;
                margin-bottom: 24px;
            }

            .todo-panel {
                width: 100%;
                min-width: 0;
            }
        }

        /* ========================================
           MEETINGS - Issue-80
           ======================================== */

        /* Meeting modal styles */
        .meeting-modal-content {
            max-width: 400px;
            max-height: none;
            overflow: visible;
            transition: max-width 300ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        .meeting-modal-content.expanded {
            max-width: 580px;
            overflow: visible;
        }

        /* Ensure date picker in recurring panel floats above everything */
        .meeting-recurring-panel .dtp-picker {
            z-index: 10001;
        }

        .meeting-form-container {
            display: flex;
            gap: 0;
        }

        .meeting-form-left {
            flex: 0 0 352px;
            min-width: 352px;
        }

        .meeting-duration-row {
            display: flex;
            align-items: flex-start;
            gap: 16px;
        }

        .meeting-duration-field {
            flex: 0 0 auto;
        }

        .meeting-recurring-checkbox {
            flex: 1;
            display: flex;
            align-items: center;
            padding-top: 28px;
        }

        .recurring-checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 13px;
            color: #374151;
            white-space: nowrap;
        }

        .recurring-checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #F5A623;
        }

        /* Recurring panel (right side) */
        .meeting-recurring-panel {
            width: 0;
            overflow: hidden;
            opacity: 0;
            padding: 0;
            border-left: none;
            transition: width 300ms cubic-bezier(0.4, 0, 0.2, 1),
                        opacity 300ms cubic-bezier(0.4, 0, 0.2, 1),
                        padding 300ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        .meeting-recurring-panel.visible {
            width: 180px;
            opacity: 1;
            padding: 0 0 0 20px;
            border-left: 1px solid #E5E7EB;
            margin-left: 20px;
            overflow: visible;
        }

        .recurring-panel-header {
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 12px;
        }

        .recurring-frequency-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 16px;
        }

        .recurring-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 13px;
            color: #374151;
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid transparent;
            transition: background-color 150ms, border-color 150ms;
        }

        .recurring-option:hover {
            background: #F9FAFB;
        }

        .recurring-option.selected {
            background: #FEF3C7;
            border-color: #F5A623;
        }

        .recurring-option input[type="checkbox"] {
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: #F5A623;
        }

        .recurring-end-date {
            margin-top: 12px;
        }

        .recurring-end-date .form-label {
            font-size: 12px;
            color: #6B7280;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .recurring-end-date .datetime-input {
            font-size: 12px;
            padding: 6px 10px;
        }

        .meeting-duration-input {
            width: 100px !important;
            display: inline-block;
        }

        .meeting-duration-hint {
            font-size: 12px;
            color: #9CA3AF;
            font-style: italic;
            margin-left: 8px;
        }

        /* Conflict Resolution Modal Styles (Issue-82) */
        .conflict-group {
            margin-bottom: 16px;
        }

        .conflict-group-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #F3F4F6;
            border-radius: 8px 8px 0 0;
            font-weight: 600;
            font-size: 13px;
            color: #374151;
        }

        .conflict-group-header .group-icon {
            font-size: 16px;
        }

        .conflict-group-header .group-count {
            background: #6B7280;
            color: white;
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: auto;
        }

        .conflict-items-list {
            border: 1px solid #E5E7EB;
            border-top: none;
            border-radius: 0 0 8px 8px;
        }

        .conflict-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-bottom: 1px solid #E5E7EB;
            transition: background 0.15s ease;
        }

        .conflict-item:last-child {
            border-bottom: none;
        }

        .conflict-item:hover {
            background: #F9FAFB;
        }

        .conflict-item.selected {
            background: #FEF3C7;
        }

        .conflict-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #F5A623;
            cursor: pointer;
        }

        .conflict-item-info {
            flex: 1;
            min-width: 0;
        }

        .conflict-item-title {
            font-weight: 500;
            font-size: 14px;
            color: #1F1F1F;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .conflict-item-meta {
            display: flex;
            gap: 12px;
            font-size: 12px;
            color: #6B7280;
            margin-top: 2px;
        }

        .conflict-item-date {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .conflict-item-type-badge {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 500;
        }

        .conflict-item-type-badge.todo {
            background: #DBEAFE;
            color: #1D4ED8;
        }

        .conflict-item-type-badge.meeting {
            background: #E9D5FF;
            color: #7C3AED;
        }

        .conflict-item-type-badge.recurring {
            background: #FCE7F3;
            color: #BE185D;
        }

        /* Meetings list section */
        .meetings-section {
            background: #FFFFFF;
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            padding: 16px;
            margin-top: 16px;
            max-height: 226px;
            min-height: 226px;
            display: flex;
            flex-direction: column;
        }

        .meetings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .meetings-title {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .meetings-count {
            font-size: 11px;
            color: #9CA3AF;
        }

        .meetings-list {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .meetings-empty {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9CA3AF;
            font-size: 12px;
            font-style: italic;
        }

        .meeting-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: #F9FAFB;
            border-radius: 8px;
            font-size: 12px;
            min-height: 32px;
        }

        .meeting-item:hover {
            background: #F3F4F6;
        }

        .meeting-date-label {
            font-weight: 600;
            color: #9B59B6;
            white-space: nowrap;
            min-width: 60px;
        }

        .meeting-title-text {
            flex: 1;
            color: #374151;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .meeting-duration-text {
            color: #6B7280;
            white-space: nowrap;
            font-size: 11px;
        }

        .meeting-delete-btn {
            background: none;
            border: none;
            color: #9CA3AF;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 14px;
            line-height: 1;
            border-radius: 4px;
            transition: background 0.2s, color 0.2s;
        }

        .meeting-delete-btn:hover {
            background: #FEE2E2;
            color: #DC3545;
        }

        /* Meeting segment in Daily Load (purple) */
        .daily-load-segment.meeting {
            background: #9B59B6 !important;
        }

        .daily-load-segment.meeting::before {
            content: "📅";
            position: absolute;
            left: 4px;
            font-size: 8px;
        }

        /* Engagement Lifecycle Styles */
        .engagement-type-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .type-engagement {
            background: #FFF7ED;
            color: #EA580C;
        }

        .type-pre-project {
            background: #FEF3C7;
            color: #B45309;
        }

        .type-project {
            background: #DCFCE7;
            color: #16A34A;
        }

        /* Lifecycle section in side panel */
        .lifecycle-section {
            margin-top: 16px;
            padding: 16px;
            background: #F8F9FA;
            border-radius: 8px;
            border: 1px solid #E0E0E0;
        }

        .lifecycle-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .lifecycle-title {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .lifecycle-actions {
            display: flex;
            gap: 8px;
        }

        .lifecycle-action-btn {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.15s ease;
        }

        .lifecycle-action-btn.promote {
            background: #FFB800;
            color: #1F1F1F;
        }

        .lifecycle-action-btn.promote:hover {
            background: #E5A600;
        }

        .lifecycle-action-btn.secondary {
            background: #FFFFFF;
            color: #6C757D;
            border-color: #DEE2E6;
        }

        .lifecycle-action-btn.secondary:hover {
            background: #F8F9FA;
        }

        .lifecycle-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Pre-Project Section */
        .pre-project-section {
            margin-top: 16px;
        }

        .pre-project-dates {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }

        .pre-project-date-field {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .pre-project-date-label {
            font-size: 11px;
            font-weight: 500;
            color: #6C757D;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .pre-project-date-input {
            padding: 8px 10px;
            border: 1px solid #DEE2E6;
            border-radius: 6px;
            font-size: 13px;
            color: #1F1F1F;
        }

        .pre-project-date-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 2px rgba(255, 184, 0, 0.15);
        }

        /* Allocations Table */
        .allocations-section {
            margin-top: 16px;
        }

        .allocations-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .allocations-title {
            font-size: 13px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .add-allocation-btn {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            background: #FFB800;
            color: #1F1F1F;
            border: none;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .add-allocation-btn:hover {
            background: #E5A600;
        }

        .allocations-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .allocations-table th {
            text-align: left;
            padding: 8px 6px;
            background: #E9ECEF;
            color: #495057;
            font-weight: 600;
            border-bottom: 1px solid #DEE2E6;
        }

        .allocations-table td {
            padding: 8px 6px;
            border-bottom: 1px solid #E9ECEF;
            vertical-align: middle;
        }

        .allocations-table input,
        .allocations-table select {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #DEE2E6;
            border-radius: 4px;
            font-size: 12px;
        }

        .allocations-table input:focus,
        .allocations-table select:focus {
            outline: none;
            border-color: #FFB800;
        }

        .allocation-delete-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: transparent;
            color: #DC3545;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .allocation-delete-btn:hover {
            background: #FEE2E2;
        }

        .allocation-charged-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            background: #D1FAE5;
            color: #065F46;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
        }

        .allocation-pending-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            background: #FEF3C7;
            color: #92400E;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
        }

        /* Allocation Summary */
        .allocation-summary {
            margin-top: 12px;
            padding: 12px;
            background: #FFFFFF;
            border-radius: 6px;
            border: 1px solid #E0E0E0;
        }

        .allocation-summary-row {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            padding: 4px 0;
        }

        .allocation-summary-label {
            color: #6C757D;
        }

        .allocation-summary-value {
            font-weight: 600;
            color: #1F1F1F;
        }

        /* Project Section */
        .project-section {
            margin-top: 16px;
        }

        .project-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }

        .project-field {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .project-field.full-width {
            grid-column: 1 / -1;
        }

        .project-field-label {
            font-size: 11px;
            font-weight: 500;
            color: #6C757D;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .project-field-input {
            padding: 8px 10px;
            border: 1px solid #DEE2E6;
            border-radius: 6px;
            font-size: 13px;
            color: #1F1F1F;
        }

        .project-field-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 2px rgba(255, 184, 0, 0.15);
        }

        /* Timeline Section */
        .timeline-section {
            margin-top: 16px;
            padding: 12px;
            background: #FFFFFF;
            border-radius: 6px;
            border: 1px solid #E0E0E0;
        }

        .timeline-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .timeline-title {
            font-size: 13px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .timeline-dates {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        /* Charge-Back Section */
        .chargeback-section {
            margin-top: 16px;
            padding: 12px;
            background: #FEF3C7;
            border-radius: 6px;
            border: 1px solid #F59E0B;
        }

        .chargeback-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .chargeback-title {
            font-size: 13px;
            font-weight: 600;
            color: #92400E;
        }

        .chargeback-summary {
            font-size: 12px;
            color: #78350F;
        }

        .chargeback-list {
            margin-top: 8px;
        }

        .chargeback-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid rgba(245, 158, 11, 0.3);
            font-size: 12px;
        }

        .chargeback-item:last-child {
            border-bottom: none;
        }

        /* Promote to Pre-Project Modal */
        .promote-modal-content {
            max-width: 500px;
            overflow: visible;
            max-height: none;
        }

        .promote-form-group {
            margin-bottom: 16px;
        }

        .promote-form-label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 6px;
        }

        .promote-form-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #DEE2E6;
            border-radius: 6px;
            font-size: 14px;
            color: #1F1F1F;
        }

        .promote-form-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 2px rgba(255, 184, 0, 0.15);
        }

        /* Charge-Back Mode Selection */
        .chargeback-mode-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }

        .chargeback-mode-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border: 1px solid #DEE2E6;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .chargeback-mode-option:hover {
            border-color: #FFB800;
        }

        .chargeback-mode-option.selected {
            border-color: #FFB800;
            background: #FFFBEB;
        }

        .chargeback-mode-option input[type="radio"] {
            margin: 0;
        }

        .chargeback-mode-label {
            flex: 1;
        }

        .chargeback-mode-title {
            font-size: 13px;
            font-weight: 500;
            color: #1F1F1F;
        }

        .chargeback-mode-desc {
            font-size: 11px;
            color: #6C757D;
            margin-top: 2px;
        }

        /* Unified Promotion Modal (Issue-57) */
        .unified-promote-modal {
            max-width: 700px;
            overflow: visible;
            max-height: 90vh;
            overflow-y: auto;
        }

        .unified-promote-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .unified-promote-title {
            font-size: 18px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .unified-promote-close {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            color: #6C757D;
        }

        .unified-promote-close:hover {
            color: #1F1F1F;
        }

        .allocation-section {
            margin-bottom: 20px;
        }

        .allocation-section-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 0;
            cursor: pointer;
        }

        .allocation-section-toggle {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #D1D5DB;
            background: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .allocation-section-toggle.enabled {
            border-color: #22C55E;
            background: #22C55E;
        }

        .allocation-section-toggle.enabled::after {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #fff;
        }

        .allocation-section-title {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            flex: 1;
        }

        .allocation-section-link {
            color: #6C757D;
            text-decoration: none;
        }

        .allocation-section-link:hover {
            color: #1F1F1F;
        }

        .allocation-section-content {
            display: none;
            padding: 16px;
            border: 1px solid #E5E7EB;
            border-radius: 8px;
            margin-top: 8px;
            overflow: hidden;
            max-height: 0;
            opacity: 0;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, padding 0.3s ease-out;
        }

        .allocation-section.expanded .allocation-section-content {
            display: block;
            max-height: 300px;
            opacity: 1;
            padding: 16px;
        }

        .allocation-input-row {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 16px;
        }

        .allocation-input-label {
            font-size: 13px;
            color: #374151;
            min-width: 150px;
        }

        .allocation-input {
            width: 80px;
            padding: 8px 12px;
            border: 1px solid #E5E7EB;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
        }

        .allocation-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 2px rgba(255, 184, 0, 0.15);
        }

        .allocation-months-label {
            font-size: 13px;
            color: #374151;
            margin-bottom: 12px;
        }

        /* Month Timeline */
        .month-timeline-container {
            position: relative;
            overflow: hidden;
        }

        .month-timeline-nav {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .month-timeline-arrow {
            width: 28px;
            height: 28px;
            border: 1px solid #E5E7EB;
            border-radius: 4px;
            background: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6C757D;
            flex-shrink: 0;
        }

        .month-timeline-arrow:hover {
            border-color: #D1D5DB;
            color: #374151;
        }

        .month-timeline-arrow:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .month-timeline-scroll {
            flex: 1;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .month-timeline-scroll::-webkit-scrollbar {
            display: none;
        }

        .month-timeline-years {
            display: flex;
            margin-bottom: 4px;
        }

        .month-timeline-year {
            font-size: 12px;
            color: #9CA3AF;
            text-align: center;
            flex-shrink: 0;
        }

        .month-timeline-months {
            display: flex;
            gap: 4px;
        }

        .month-timeline-month {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.15s ease;
            border: 1px solid transparent;
            background: #F9FAFB;
            color: #374151;
            flex-shrink: 0;
        }

        .month-timeline-month:hover:not(.disabled):not(.selected) {
            background: #F3F4F6;
            border-color: #D1D5DB;
        }

        .month-timeline-month.selected.preproject {
            background: #3B82F6;
            color: #fff;
            border-color: #3B82F6;
        }

        .month-timeline-month.selected.project {
            background: #22C55E;
            color: #fff;
            border-color: #22C55E;
        }

        .month-timeline-month.disabled {
            background: #F3F4F6;
            color: #D1D5DB;
            cursor: not-allowed;
        }

        /* Modal Footer */
        .unified-promote-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 24px;
            padding-top: 16px;
            border-top: 1px solid #E5E7EB;
        }

        .unified-promote-footer .btn-save {
            background: #EAB308;
            color: #1F1F1F;
            border: none;
            padding: 10px 24px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
        }

        .unified-promote-footer .btn-save:hover {
            background: #CA8A04;
        }

        .unified-promote-footer .btn-save:disabled {
            background: #FEF3C7;
            color: #A3A3A3;
            cursor: not-allowed;
        }

        /* Allocations Report View */
        .allocations-report {
            padding: 20px;
        }

        .allocations-report-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .allocations-report-title {
            font-size: 18px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .month-selector {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .month-nav-btn {
            width: 32px;
            height: 32px;
            border: 1px solid #DEE2E6;
            border-radius: 6px;
            background: #FFFFFF;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #495057;
        }

        .month-nav-btn:hover {
            background: #F8F9FA;
        }

        .month-display {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            min-width: 120px;
            text-align: center;
        }

        .allocations-report-table {
            width: 100%;
            border-collapse: collapse;
            background: #FFFFFF;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .allocations-report-table th {
            text-align: left;
            padding: 12px 16px;
            background: #F8F9FA;
            color: #495057;
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #DEE2E6;
        }

        .allocations-report-table td {
            padding: 12px 16px;
            border-bottom: 1px solid #E9ECEF;
            font-size: 13px;
        }

        .allocations-report-table tr:last-child td {
            border-bottom: none;
        }

        .allocation-total-row {
            background: #F8F9FA;
            font-weight: 600;
        }

        .allocation-warning {
            color: #DC3545;
        }

        /* Engagement Timeline View */
        .engagement-timeline {
            margin-top: 16px;
        }

        .timeline-phase {
            position: relative;
            padding-left: 24px;
            margin-bottom: 16px;
        }

        .timeline-phase::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 24px;
            bottom: 0;
            width: 2px;
            background: #DEE2E6;
        }

        .timeline-phase:last-child::before {
            display: none;
        }

        .timeline-phase-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .timeline-phase-dot {
            position: absolute;
            left: 4px;
            top: 4px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #FFB800;
        }

        .timeline-phase-dot.pre-project {
            background: #F59E0B;
        }

        .timeline-phase-dot.project {
            background: #10B981;
        }

        .timeline-phase-title {
            font-size: 13px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .timeline-phase-period {
            font-size: 11px;
            color: #6C757D;
        }

        .timeline-month {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
            font-size: 12px;
        }

        .timeline-month-label {
            width: 70px;
            color: #495057;
        }

        .timeline-month-percent {
            font-weight: 600;
            color: #1F1F1F;
        }

        .timeline-month-status {
            font-size: 10px;
        }

        /* Type selector in modal */
        .type-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .type-option {
            flex: 1;
            padding: 12px;
            border: 2px solid #DEE2E6;
            border-radius: 8px;
            background: #FFFFFF;
            cursor: pointer;
            text-align: center;
            transition: all 0.15s ease;
        }

        .type-option:hover {
            border-color: #FFB800;
        }

        .type-option.selected {
            border-color: #FFB800;
            background: #FFFBEB;
        }

        .type-option-icon {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .type-option-label {
            font-size: 12px;
            font-weight: 500;
            color: #1F1F1F;
        }

        /* Status badges for new lifecycle */
        .status-badge.status-active {
            background: #D1FAE5;
            color: #065F46;
        }

        .status-badge.status-completed {
            background: #DBEAFE;
            color: #1E40AF;
        }

        .status-badge.status-dropped {
            background: #FEE2E2;
            color: #991B1B;
        }

        .status-badge.status-closed {
            background: #E5E7EB;
            color: #374151;
        }

        .status-badge.status-paused {
            background: #FEF3C7;
            color: #92400E;
        }

        /* Status tooltip container */
        .status-tooltip-container {
            position: relative;
            display: inline-block;
        }

        /* Side panel tooltip aligns left to fit within panel */
        .side-panel-body .status-tooltip {
            left: 0;
            transform: none;
        }

        .side-panel-body .status-tooltip::after {
            left: 24px;
            transform: none;
        }

        .status-tooltip {
            position: absolute;
            top: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: #1F2937;
            color: #F9FAFB;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.5;
            width: 280px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 1000;
            pointer-events: none;
        }

        .status-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-bottom-color: #1F2937;
        }

        .status-tooltip-container:hover .status-tooltip,
        .status-tooltip-container .status-tooltip.expanded {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .status-tooltip-header {
            font-weight: 600;
            margin-bottom: 8px;
            color: #F9FAFB;
        }

        .status-tooltip-brief {
            color: #D1D5DB;
            margin-bottom: 8px;
        }

        .status-tooltip-link {
            color: #60A5FA;
            cursor: pointer;
            font-size: 12px;
            display: inline-block;
        }

        .status-tooltip-link:hover {
            text-decoration: underline;
        }

        .status-tooltip-expanded {
            display: none;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #374151;
        }

        .status-tooltip.expanded .status-tooltip-expanded {
            display: block;
        }

        .status-tooltip.expanded .status-tooltip-link {
            display: none;
        }

        .status-item {
            margin-bottom: 10px;
        }

        .status-item:last-child {
            margin-bottom: 0;
        }

        .status-item-name {
            font-weight: 600;
            color: #F9FAFB;
            margin-bottom: 2px;
        }

        .status-item-desc {
            font-size: 12px;
            color: #9CA3AF;
        }

        /* Engagement item type indicator */
        .engagement-type-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }

        .engagement-type-icon {
            width: 16px;
            height: 16px;
        }

        .engagement-type-icon.engagement-type {
            color: #0369A1;
        }

        .engagement-type-icon.pre-project-type {
            color: #92400E;
        }

        .engagement-type-icon.project-type {
            color: #065F46;
        }

        /* =============================================
           DateTimePicker Component Styles
           ============================================= */

        /* Input wrapper */
        .dtp-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .dtp-display-input {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            cursor: pointer;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .dtp-display-input:hover {
            border-color: #FFB800;
        }

        .dtp-display-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .dtp-display-input::placeholder {
            color: #ADB5BD;
        }

        .dtp-calendar-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 16px;
            cursor: pointer;
            color: #666666;
            transition: color 0.2s ease;
        }

        .dtp-calendar-icon:hover {
            color: #FFB800;
        }

        /* Picker container */
        .dtp-picker {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            z-index: 1000;
            width: 420px;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px) scale(0.98);
            transition: opacity 150ms ease-out, transform 150ms ease-out, visibility 150ms;
        }

        .dtp-picker.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }

        /* Position picker above input when insufficient space below */
        .dtp-picker.above {
            top: auto;
            bottom: calc(100% + 4px);
            transform: translateY(8px) scale(0.98);
        }

        .dtp-picker.above.open {
            transform: translateY(0) scale(1);
        }

        /* Picker header */
        .dtp-header {
            padding: 12px 16px;
            border-bottom: 1px solid #E0E0E0;
            font-size: 14px;
            font-weight: 600;
            color: #333333;
        }

        /* Picker body - side by side layout */
        .dtp-body {
            display: flex;
            padding: 16px;
            gap: 16px;
        }

        /* Date-only mode - calendar only, narrower picker */
        .dtp-body.dtp-date-only {
            justify-content: center;
        }

        .dtp-body.dtp-date-only .dtp-calendar-panel {
            width: 100%;
        }

        .dtp-body.dtp-date-only + .dtp-footer {
            justify-content: center;
        }

        /* Date-only picker is narrower */
        .dtp-picker:has(.dtp-date-only) {
            width: 280px;
        }

        /* Time panel (left side) */
        .dtp-time-panel {
            display: flex;
            flex-direction: column;
            width: 120px;
            flex-shrink: 0;
            align-items: center;
            justify-content: center;
            border-right: 1px solid #E8E8E8;
            padding-right: 16px;
        }

        .dtp-date-display {
            font-size: 12px;
            color: #888888;
            margin-bottom: 8px;
            text-align: center;
        }

        /* Time spinners container - horizontal layout */
        .dtp-time-spinners {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0;
        }

        /* Individual spinner - vertical layout (▲, value, ▼) */
        .dtp-spinner {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        /* Spinner buttons - subtle, borderless arrows */
        .dtp-spinner-btn {
            width: 40px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            cursor: pointer;
            color: #999999;
            font-size: 10px;
            transition: color 80ms ease;
        }

        .dtp-spinner-btn:hover {
            color: #F5A623;
        }

        .dtp-spinner-btn:active {
            color: #D4920F;
        }

        /* Time input - large, clean, borderless */
        .dtp-time-input {
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 36px;
            font-weight: 300;
            color: #333333;
            width: 52px;
            text-align: center;
            padding: 4px 0;
            border: none;
            border-radius: 4px;
            background: transparent;
            cursor: pointer;
            transition: background 80ms ease;
        }

        .dtp-time-input:hover {
            background: #FEF7E6;
        }

        .dtp-time-input:focus {
            outline: none;
            background: #FEF7E6;
            color: #F5A623;
        }

        /* Time separator colon */
        .dtp-time-separator {
            font-size: 36px;
            font-weight: 300;
            color: #333333;
            padding: 0 2px;
            align-self: center;
        }

        /* Calendar panel (right side) */
        .dtp-calendar-panel {
            flex: 1;
            min-width: 0;
        }

        /* Calendar header with month/year navigation */
        .dtp-calendar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .dtp-nav-btn {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: 1px solid #E0E0E0;
            border-radius: 4px;
            cursor: pointer;
            color: #666666;
            transition: all 80ms ease;
        }

        .dtp-nav-btn:hover {
            background: #FEF7E6;
            border-color: #F5A623;
            color: #F5A623;
        }

        .dtp-month-year {
            display: flex;
            gap: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #333333;
        }

        .dtp-month-label,
        .dtp-year-label {
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 80ms ease;
        }

        .dtp-month-label:hover,
        .dtp-year-label:hover {
            background: #FEF7E6;
        }

        /* Day headers container - grid aligned with calendar */
        .dtp-day-headers {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            margin-bottom: 4px;
        }

        /* Individual day header */
        .dtp-day-header {
            font-size: 11px;
            font-weight: 600;
            color: #888888;
            text-align: center;
            padding: 4px 0;
            width: 32px;
            justify-self: center;
        }

        /* Calendar grid */
        .dtp-calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            outline: none;
            border: none;
        }

        .dtp-calendar-grid:focus {
            outline: none;
        }

        .dtp-day {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            color: #333333;
            border-radius: 50%;
            cursor: pointer;
            transition: all 80ms ease;
            border: 2px solid transparent;
        }

        .dtp-day:hover {
            background: #FEF7E6;
            transform: scale(1.05);
        }

        .dtp-day.other-month {
            color: #999999;
        }

        .dtp-day.today {
            background: #FFF3CD;
            border-color: #F5A623;
        }

        .dtp-day.selected {
            background: #F5A623;
            color: #FFFFFF;
            border-color: #F5A623;
        }

        .dtp-day.focused {
            box-shadow: 0 0 0 2px #F5A623;
        }

        .dtp-day.disabled {
            color: #CCCCCC;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Non-work days (weekends, holidays, PTO) - Issue-76 */
        .dtp-day.disabled-day {
            color: #D1D5DB;
            background: #F3F4F6;
            cursor: not-allowed;
            pointer-events: none;
            text-decoration: line-through;
        }

        .dtp-day.disabled-day.other-month {
            color: #E5E7EB;
            background: #FAFAFA;
        }
/* Range selection styles for PTO picker */        .dtp-day.range-start {            background: #F5A623;            color: white;            border-radius: 50% 0 0 50%;        }        .dtp-day.range-end {            background: #F5A623;            color: white;            border-radius: 0 50% 50% 0;        }        .dtp-day.range-start.range-end {            border-radius: 50%;        }        .dtp-day.in-range {            background: #FEF3C7;            color: #92400E;            border-radius: 0;        }        .dtp-day.in-range:hover {            background: #FDE68A;        }        .dtp-day.range-preview {            background: #FEF9C3;            color: #A16207;        }

        /* Month picker overlay */
        .dtp-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #FFFFFF;
            border-radius: 8px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-4px);
            transition: all 100ms ease-out;
            z-index: 10;
        }

        .dtp-overlay.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .dtp-overlay-header {
            padding: 12px 16px;
            border-bottom: 1px solid #E0E0E0;
            font-size: 14px;
            font-weight: 600;
            color: #333333;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .dtp-overlay-close {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            cursor: pointer;
            color: #666666;
            border-radius: 4px;
        }

        .dtp-overlay-close:hover {
            background: #FEF7E6;
            color: #F5A623;
        }

        .dtp-overlay-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            padding: 16px;
        }

        .dtp-overlay-item {
            padding: 12px 8px;
            text-align: center;
            font-size: 13px;
            color: #333333;
            border-radius: 4px;
            cursor: pointer;
            transition: all 80ms ease;
            border: 2px solid transparent;
        }

        .dtp-overlay-item:hover {
            background: #FEF7E6;
            transform: scale(1.05);
        }

        .dtp-overlay-item.current {
            border-color: #F5A623;
        }

        .dtp-overlay-item.selected {
            background: #F5A623;
            color: #FFFFFF;
        }

        .dtp-overlay-item.focused {
            box-shadow: 0 0 0 2px #F5A623;
        }

        /* Footer with Select button */
        .dtp-footer {
            padding: 12px 16px;
            border-top: 1px solid #E0E0E0;
            display: flex;
            justify-content: flex-start;
        }

        .dtp-select-btn {
            width: 100px;
            height: 36px;
            background: #F5A623;
            color: #FFFFFF;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 80ms ease;
        }

        .dtp-select-btn:hover {
            background: #D4920F;
        }

        .dtp-select-btn:active {
            background: #B87D0A;
        }

        .dtp-select-btn:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(245, 166, 35, 0.3);
        }

        /* Screen reader only */
        .dtp-sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Responsive - stacked layout for mobile */
        @media (max-width: 767px) {
            .dtp-picker {
                width: 100%;
                max-width: 320px;
            }

            .dtp-body {
                flex-direction: column;
            }

            .dtp-time-panel {
                width: 100%;
                flex-direction: row;
                align-items: center;
                justify-content: space-between;
            }

            .dtp-date-display {
                margin-bottom: 0;
            }

            .dtp-day {
                width: 40px;
                height: 40px;
            }
        }
    </style>
</head>
<body>
    <!-- Landing Page -->
    <div id="landing-page" class="container">
        <div class="logo-container">
            <svg class="logo" viewBox="0 0 120 120" fill="none" xmlns="http://www.w3.org/2000/svg">
                <!-- Clipboard background -->
                <rect x="20" y="15" width="80" height="95" rx="8" fill="#FFB800"/>
                <rect x="25" y="20" width="70" height="85" rx="6" fill="#FFFFFF"/>

                <!-- Clipboard clip -->
                <path d="M45 10 H75 C78 10 80 12 80 15 V20 H40 V15 C40 12 42 10 45 10 Z" fill="#FFB800"/>
                <rect x="48" y="5" width="24" height="12" rx="3" fill="#1F1F1F"/>

                <!-- Checkmark items -->
                <g opacity="0.9">
                    <!-- First item - checked -->
                    <circle cx="35" cy="38" r="5" fill="#00A86B"/>
                    <path d="M33 38 L34.5 39.5 L37.5 36.5" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <rect x="45" y="36" width="45" height="4" rx="2" fill="#E0E0E0"/>

                    <!-- Second item - checked -->
                    <circle cx="35" cy="55" r="5" fill="#00A86B"/>
                    <path d="M33 55 L34.5 56.5 L37.5 53.5" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <rect x="45" y="53" width="35" height="4" rx="2" fill="#E0E0E0"/>

                    <!-- Third item - unchecked -->
                    <circle cx="35" cy="72" r="5" fill="#E0E0E0"/>
                    <rect x="45" y="70" width="40" height="4" rx="2" fill="#E0E0E0"/>

                    <!-- Fourth item - unchecked -->
                    <circle cx="35" cy="89" r="5" fill="#E0E0E0"/>
                    <rect x="45" y="87" width="30" height="4" rx="2" fill="#E0E0E0"/>
                </g>
            </svg>
            <h1>TodoManager</h1>
            <p class="tagline">Organize your tasks, achieve your goals</p>
        </div>

        <div class="options-container">
            <div class="option-card" onclick="startFromScratch()">
                <div class="option-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </div>
                <h2 class="option-title">Start from Scratch</h2>
                <p class="option-description">Begin fresh with a clean workspace and create your first task list</p>
            </div>

            <div class="option-card" onclick="continueWorking()">
                <div class="option-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 11l3 3L22 4"></path>
                        <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"></path>
                    </svg>
                </div>
                <h2 class="option-title">Continue Working</h2>
                <p class="option-description">Pick up where you left off and manage your existing tasks</p>
            </div>
        </div>

        <div class="footer">
            <p>&copy; 2025 TodoManager. Built with care.</p>
        </div>
    </div>

    <!-- Hidden file input for importing state -->
    <input type="file" id="import-file-input" accept=".json" style="display: none;" onchange="importData(event)">

    <!-- App Header (shared across pages) -->
    <header id="app-header" class="header hidden">
        <div class="header-left">
            <nav class="tab-nav">
                <button id="tab-home" class="tab-btn active" onclick="switchTab('home')">Todo's</button>
                <button id="tab-engagements" class="tab-btn" onclick="switchTab('engagements')">Engagements</button>
            </nav>
        </div>
        <div class="header-search">
            <div class="search-container">
                <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
                <input type="text" id="global-search-input" class="search-input" placeholder="Search... (Shift+Space)" oninput="handleSearchInput(this.value)">
            </div>
        </div>
        <div class="header-actions">
            <button class="icon-button" onclick="openSettings()" title="Settings">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="3"></circle>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                </svg>
            </button>
            <button class="icon-button" onclick="exportData()" title="Export">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
            </button>
        </div>
    </header>

    <!-- Home Page -->
    <div id="home-page" class="page hidden">

        <!-- Main Content -->
        <main class="main-content">
            <!-- Split Container -->
            <div class="home-split-container">
                <!-- Recommendation Panel (Left) -->
                <div id="recommendation-panel" class="recommendation-panel">
                    <!-- Panel Header -->
                    <div class="recommendation-header">
                        <div class="recommendation-date">
                            <span class="recommendation-date-icon">📅</span>
                            <span id="recommendation-date-text">Daily Plan</span>
                        </div>
                        <div id="recommendation-summary" class="recommendation-summary"></div>
                    </div>

                    <!-- Panel Content -->
                    <div class="recommendation-content">
                        <!-- Warnings Section -->
                        <div id="warnings-section" class="warnings-section hidden"></div>

                        <!-- Overdue Section -->
                        <div id="overdue-section" class="recommendation-section overdue hidden">
                            <div class="recommendation-section-header">
                                <span class="recommendation-section-icon">🔴</span>
                                <span>Overdue</span>
                                <span id="overdue-count" class="recommendation-section-count">0</span>
                            </div>
                            <div id="overdue-items" class="recommendation-items"></div>
                        </div>

                        <!-- Must Complete Today Section -->
                        <div id="must-do-section" class="recommendation-section must-do hidden">
                            <div class="recommendation-section-header">
                                <span class="recommendation-section-icon">⚡</span>
                                <span>Must Complete Today</span>
                                <span id="must-do-count" class="recommendation-section-count">0</span>
                            </div>
                            <div id="must-do-items" class="recommendation-items"></div>
                        </div>

                        <!-- Recommended Section -->
                        <div id="recommended-section" class="recommendation-section recommended hidden">
                            <div class="recommendation-section-header">
                                <span class="recommendation-section-icon">📋</span>
                                <span>Recommended</span>
                                <span id="recommended-count" class="recommendation-section-count">0</span>
                            </div>
                            <div id="recommended-items" class="recommendation-items"></div>
                        </div>

                        <!-- If Time Permits Section -->
                        <div id="if-time-section" class="recommendation-section if-time hidden">
                            <div class="recommendation-section-header">
                                <span class="recommendation-section-icon">💡</span>
                                <span>If Time Permits</span>
                                <span id="if-time-count" class="recommendation-section-count">0</span>
                            </div>
                            <div id="if-time-items" class="recommendation-items"></div>
                        </div>

                        <!-- Blocked Section (Issue-67) -->
                        <div id="blocked-section" class="recommendation-section blocked hidden">
                            <div class="recommendation-section-header">
                                <span class="recommendation-section-icon">⏸️</span>
                                <span>Blocked</span>
                                <span id="blocked-count" class="recommendation-section-count">0</span>
                            </div>
                            <div id="blocked-items" class="recommendation-items"></div>
                        </div>

                        <!-- Insights Section -->
                        <div id="insights-section" class="insights-section hidden">
                            <div class="insights-header">
                                <span>💬</span>
                                <span>Insights</span>
                            </div>
                            <div id="insights-items"></div>
                        </div>

                        <!-- Empty State -->
                        <div id="recommendation-empty" class="recommendation-empty">
                            <div class="recommendation-empty-icon">🎉</div>
                            <p class="recommendation-empty-text">No tasks to recommend.<br>Add some todos to get started!</p>
                        </div>
                    </div>
                </div>

                <!-- Todo Panel (Right) -->
                <div class="todo-panel">
                    <!-- Floating shortcut hint (shown when items exist) -->
                    <p id="todo-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create a new task / Press Shift + M to create a new meeting</p>

                    <!-- Todo List Container -->
                    <div id="todo-list" class="todo-list">
                        <!-- Todos will be rendered here -->
                    </div>

                    <!-- Empty State -->
                    <div id="empty-state" class="empty-state">
                        <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"></path>
                            <rect x="9" y="3" width="6" height="4" rx="1"></rect>
                            <line x1="9" y1="12" x2="15" y2="12"></line>
                            <line x1="9" y1="16" x2="13" y2="16"></line>
                        </svg>
                        <p class="empty-text">No Todos</p>
                        <p class="shortcut-hint">Press Shift + N to create a new task / Press Shift + M to create a new meeting</p>
                    </div>
                </div>

                <!-- KPI Panel (Right) - Issue-74, Issue-107 -->
                <div class="kpi-panel">
                    <!-- Daily Load Chart - Issue-107: 8-column forecast -->
                    <div id="daily-load-chart" class="daily-load-chart">
                        <div class="daily-load-header">
                            <div class="daily-load-title">Daily Load</div>
                            <div id="daily-load-status" class="daily-load-status balanced">Balanced workload</div>
                        </div>
                        <div class="daily-load-container">
                            <div id="daily-load-bars" class="daily-load-bars">
                                <!-- Columns generated dynamically by renderDailyLoadChart() -->
                            </div>
                        </div>
                    </div>
                    <!-- Meetings Section (Issue-80) -->
                    <div id="meetings-section" class="meetings-section">
                        <div class="meetings-header">
                            <div class="meetings-title">📅 Meetings</div>
                            <div id="meetings-count" class="meetings-count"></div>
                        </div>
                        <div id="meetings-list" class="meetings-list">
                            <div class="meetings-empty">No upcoming meetings</div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Engagements Page -->
    <div id="engagements-page" class="page hidden">
        <!-- Main Content -->
        <main class="main-content">
            <!-- Archive Toggle -->
            <div class="archive-toggle-container">
                <label class="archive-toggle">
                    <input type="checkbox" id="show-archived-toggle" onchange="toggleShowArchived()">
                    <span>Show Archived</span>
                </label>
            </div>
            <!-- Floating shortcut hint (shown when items exist) -->
            <p id="opp-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

            <!-- Engagement List Container -->
            <div id="engagement-list" class="engagement-list">
                <!-- Engagements will be rendered here -->
            </div>

            <!-- Empty State -->
            <div id="engagement-empty-state" class="empty-state">
                <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                </svg>
                <p class="empty-text">No Engagements</p>
                <p class="shortcut-hint">Press Shift + N to create new items</p>
            </div>
        </main>
    </div>

    <!-- Settings Page -->
    <div id="settings-page" class="page hidden">
        <div class="settings-container">
            <!-- Left Menu -->
            <nav class="settings-menu">
                <h2 class="settings-menu-title">Settings</h2>
                <ul class="settings-menu-list">
                    <li class="settings-menu-item active" data-section="people" onclick="switchSettingsSection('people')">
                        <!-- Multi-user icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                        <span>People</span>
                    </li>
                    <li class="settings-menu-item" data-section="tags" onclick="switchSettingsSection('tags')">
                        <!-- Tag icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                            <line x1="7" y1="7" x2="7.01" y2="7"></line>
                        </svg>
                        <span>Tags</span>
                    </li>
                    <li class="settings-menu-item" data-section="planning" onclick="switchSettingsSection('planning')">
                        <!-- Calendar/Clock icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                            <line x1="16" y1="2" x2="16" y2="6"></line>
                            <line x1="8" y1="2" x2="8" y2="6"></line>
                            <line x1="3" y1="10" x2="21" y2="10"></line>
                            <circle cx="12" cy="15" r="2"></circle>
                        </svg>
                        <span>Planning</span>
                    </li>
                    <li class="settings-menu-item" data-section="tasks" onclick="switchSettingsSection('tasks')">
                        <!-- Checklist/Tasks icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 11l3 3L22 4"></path>
                            <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
                        </svg>
                        <span>Tasks</span>
                    </li>
                    <li class="settings-menu-item" data-section="calendar" onclick="switchSettingsSection('calendar')">
                        <!-- Calendar icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                            <line x1="16" y1="2" x2="16" y2="6"></line>
                            <line x1="8" y1="2" x2="8" y2="6"></line>
                            <line x1="3" y1="10" x2="21" y2="10"></line>
                            <path d="M8 14h.01"></path>
                            <path d="M12 14h.01"></path>
                            <path d="M16 14h.01"></path>
                            <path d="M8 18h.01"></path>
                            <path d="M12 18h.01"></path>
                        </svg>
                        <span>Calendar</span>
                    </li>
                    <li class="settings-menu-item" data-section="storage" onclick="switchSettingsSection('storage')">
                        <!-- Database/Storage icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <ellipse cx="12" cy="5" rx="9" ry="3"></ellipse>
                            <path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path>
                            <path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>
                        </svg>
                        <span>Storage</span>
                    </li>
                </ul>
            </nav>

            <!-- Content Area -->
            <div class="settings-content">
                <!-- Close Button -->
                <button class="settings-close-btn" onclick="closeSettings()" title="Close Settings">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>

                <!-- People Section -->
                <div id="settings-section-people" class="settings-section">
                    <h2 class="settings-section-title">People</h2>

                    <!-- Floating shortcut hint (shown when items exist) -->
                    <p id="people-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

                    <!-- People List Container -->
                    <div id="people-list" class="people-list">
                        <!-- People will be rendered here -->
                    </div>

                    <!-- Empty State -->
                    <div id="people-empty-state" class="empty-state">
                        <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                        <p class="empty-text">No People</p>
                        <p class="shortcut-hint">Press Shift + N to create new items</p>
                    </div>

                    <!-- Roles Section -->
                    <div id="roles-section" class="roles-section hidden">
                        <h3 class="roles-title">Roles</h3>
                        <div id="roles-list" class="roles-list">
                            <!-- Roles will be rendered here -->
                        </div>
                    </div>
                </div>

                <!-- Tags Section -->
                <div id="settings-section-tags" class="settings-section hidden">
                    <h2 class="settings-section-title">Tags</h2>

                    <!-- Floating shortcut hint (shown when items exist) -->
                    <p id="tags-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

                    <!-- Tags List Container -->
                    <div id="tags-list" class="tags-list-container">
                        <!-- Tags will be rendered here -->
                    </div>

                    <!-- Empty State -->
                    <div id="tags-empty-state" class="empty-state">
                        <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                            <line x1="7" y1="7" x2="7.01" y2="7"></line>
                        </svg>
                        <p class="empty-text">No Tags</p>
                        <p class="shortcut-hint">Press Shift + N to create new items</p>
                    </div>
                </div>

                <!-- Planning Section -->
                <div id="settings-section-planning" class="settings-section hidden">
                    <h2 class="settings-section-title">Planning</h2>
                    <p style="color: #6C757D; margin-bottom: 24px;">Configure how the daily recommendation engine calculates and displays your task priorities.</p>

                    <form class="planning-settings-form" onsubmit="savePlanningSettings(event)">
                        <div class="form-group">
                            <label for="workday-minutes" class="form-label">Workday Length (minutes)</label>
                            <input type="number" id="workday-minutes" class="form-input" min="60" max="1440" value="480">
                            <p class="form-hint">How many minutes you plan to work each day (default: 480 = 8 hours)</p>
                        </div>

                        <div class="form-group">
                            <label for="buffer-percentage" class="form-label">Buffer Percentage (%)</label>
                            <input type="number" id="buffer-percentage" class="form-input" min="0" max="50" value="15">
                            <p class="form-hint">Reserve time for interruptions and context switching (default: 15%)</p>
                        </div>

                        <div class="form-group">
                            <label for="max-overdue" class="form-label">Max Overdue Items to Show</label>
                            <input type="number" id="max-overdue" class="form-input" min="1" max="20" value="5">
                            <p class="form-hint">Limit how many overdue items appear in recommendations (default: 5)</p>
                        </div>

                        <div class="form-group">
                            <label for="planning-horizon" class="form-label">Planning Horizon (days)</label>
                            <input type="number" id="planning-horizon" class="form-input" min="1" max="30" value="14">
                            <p class="form-hint">How far ahead to look when recommending tasks (default: 14 days)</p>
                        </div>

                        <button type="submit" class="btn btn-primary btn-save-settings">Save Settings</button>
                    </form>
                </div>

                <!-- Tasks Section (Issue-97) -->
                <div id="settings-section-tasks" class="settings-section hidden">
                    <h2 class="settings-section-title">Tasks</h2>
                    <p style="color: #6C757D; margin-bottom: 24px;">Configure how completed and dropped tasks are displayed in the todo list.</p>

                    <form class="tasks-settings-form" onsubmit="saveTasksSettings(event)">
                        <div class="form-group">
                            <label for="completed-visibility-days" class="form-label">Completed/Dropped Visibility (days)</label>
                            <input type="number" id="completed-visibility-days" class="form-input" min="1" max="365" value="5">
                            <p class="form-hint">Recently completed and dropped tasks older than this will be hidden from the list (default: 5 days). Tasks remain in the system and are included in exports.</p>
                        </div>

                        <button type="submit" class="btn btn-primary btn-save-settings">Save Settings</button>
                    </form>
                </div>

                <!-- Calendar Section (Issue-76) -->
                <div id="settings-section-calendar" class="settings-section hidden">
                    <h2 class="settings-section-title">Work Calendar</h2>
                    <p style="color: #6C757D; margin-bottom: 24px;">Configure your available work days, hours per day, holidays, and time off.</p>

                    <!-- Work Days Configuration -->
                    <div class="calendar-work-days" style="background: #f8f9fa; border-radius: 8px; padding: 16px 20px; margin-bottom: 24px; display: flex; align-items: center; gap: 24px;">
                        <div style="flex: 0 0 auto; min-width: 140px;">
                            <h3 style="font-size: 14px; font-weight: 600; color: #1F1F1F; margin-bottom: 4px;">Work Days & Hours</h3>
                            <p style="color: #6C757D; font-size: 12px; margin: 0; line-height: 1.4;">Enable days you work and set hours per day.</p>
                        </div>
                        <div id="work-days-grid" style="display: flex; gap: 6px; flex: 1;">
                            <!-- Work days will be rendered here -->
                        </div>
                    </div>

                    <!-- Holidays Configuration -->
                    <div class="calendar-holidays" style="background: #f8f9fa; border-radius: 8px; padding: 16px 20px; margin-bottom: 24px;">
                        <h3 style="font-size: 14px; font-weight: 600; color: #1F1F1F; margin-bottom: 4px;">Holidays</h3>
                        <p style="color: #6C757D; font-size: 12px; margin-bottom: 12px; line-height: 1.4;">Add holidays when you won't be working. <span style="color: #F5A623; font-style: italic;">Click a date to add it.</span></p>
                        <div style="display: flex; gap: 20px; align-items: stretch;">
                            <div id="holiday-picker-container" style="flex: 0 0 auto;"></div>
                            <div style="flex: 1; display: flex; flex-direction: column; gap: 8px;">
                                <div style="display: flex; justify-content: flex-end;">
                                    <button type="button" class="btn btn-secondary" onclick="openHolidayTemplateModal()" style="font-size: 12px; padding: 6px 12px;">Apply Holiday Template</button>
                                </div>
                                <div id="holidays-list" style="flex: 1; display: flex; flex-wrap: wrap; gap: 8px; align-content: flex-start; overflow-y: auto; border: 1px solid #E5E7EB; border-radius: 6px; padding: 8px; background: white;">
                                    <!-- Holidays will be rendered here -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- PTO Configuration -->
                    <div class="calendar-pto" style="background: #f8f9fa; border-radius: 8px; padding: 16px 20px; margin-bottom: 24px;">
                        <h3 style="font-size: 14px; font-weight: 600; color: #1F1F1F; margin-bottom: 4px;">Paid Time Off (PTO)</h3>
                        <p style="color: #6C757D; font-size: 12px; margin-bottom: 12px; line-height: 1.4;">Add PTO days when you'll be away from work. <span style="color: #F5A623; font-style: italic;">Click to select a range, then click Add PTO.</span></p>
                        <div style="display: flex; gap: 20px; align-items: stretch;">
                            <div style="flex: 0 0 auto;">
                                <div id="pto-picker-container"></div>
                                <div id="pto-range-status" style="color: #F5A623; font-size: 11px; margin-top: 8px;"></div>
                            </div>
                            <div id="pto-list" style="flex: 1; display: flex; flex-wrap: wrap; gap: 8px; align-content: flex-start; overflow-y: auto; border: 1px solid #E5E7EB; border-radius: 6px; padding: 8px; background: white;">
                                <!-- PTO days will be rendered here -->
                            </div>
                        </div>
                    </div>

                    <button type="button" class="btn btn-primary" onclick="saveCalendarSettings()">Save Calendar Settings</button>
                </div>

                <!-- Storage Section -->
                <div id="settings-section-storage" class="settings-section hidden">
                    <h2 class="settings-section-title">Storage</h2>
                    <p style="color: #6C757D; margin-bottom: 24px;">View storage statistics and manage browser-stored data.</p>

                    <div class="storage-stats" style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin-bottom: 24px;">
                        <h3 style="font-size: 16px; font-weight: 600; color: #1F1F1F; margin-bottom: 16px;">Storage Statistics</h3>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;">
                            <div style="text-align: center; padding: 16px; background: white; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                <div id="storage-size" style="font-size: 24px; font-weight: 700; color: #3B82F6;">--</div>
                                <div style="font-size: 12px; color: #6C757D; margin-top: 4px;">Estimated Size</div>
                            </div>
                            <div style="text-align: center; padding: 16px; background: white; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                <div id="storage-todos" style="font-size: 24px; font-weight: 700; color: #10B981;">--</div>
                                <div style="font-size: 12px; color: #6C757D; margin-top: 4px;">Todos</div>
                            </div>
                            <div style="text-align: center; padding: 16px; background: white; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                <div id="storage-engagements" style="font-size: 24px; font-weight: 700; color: #F59E0B;">--</div>
                                <div style="font-size: 12px; color: #6C757D; margin-top: 4px;">Engagements</div>
                            </div>
                        </div>
                    </div>

                    <div style="border-top: 1px solid #e5e7eb; padding-top: 24px; margin-bottom: 24px;">
                        <h3 style="font-size: 16px; font-weight: 600; color: #1F1F1F; margin-bottom: 12px;">Debug Logging</h3>
                        <p style="color: #6C757D; margin-bottom: 16px; font-size: 14px;">
                            Enable console logging for debugging purposes. When disabled, error messages are suppressed to prevent exposing sensitive information.
                        </p>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="debug-logging-toggle" onchange="toggleDebugLogging(this.checked)" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="font-size: 14px; color: #1F1F1F;">Enable debug logging to browser console</span>
                        </label>
                    </div>

                    <div style="border-top: 1px solid #e5e7eb; padding-top: 24px;">
                        <h3 style="font-size: 16px; font-weight: 600; color: #1F1F1F; margin-bottom: 12px;">Clear Browser State</h3>
                        <p style="color: #6C757D; margin-bottom: 16px; font-size: 14px;">
                            Remove all data stored in your browser. This will delete all todos, engagements, people, tags, and settings.
                        </p>
                        <button type="button" class="btn btn-danger" onclick="openClearStateModal()">
                            Clear Browser State
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tag Modal -->
    <div id="tag-modal" class="modal hidden">
        <div class="modal-content">
            <h2 id="tag-modal-title">New Tag</h2>
            <form id="tag-form" onsubmit="saveTag(event)">
                <div class="form-group">
                    <label for="tag-name" class="form-label">Name *</label>
                    <input type="text" id="tag-name" class="form-input" placeholder="Tag name" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Color *</label>
                    <div class="color-picker-wrapper">
                        <div class="color-picker-input">
                            <div id="tag-color-preview" class="color-picker-preview" style="background-color: #F59E0B;"></div>
                            <span id="tag-color-value" class="color-picker-value">#F59E0B</span>
                        </div>
                        <input type="color" id="tag-color" class="color-picker-native" value="#F59E0B" onchange="updateColorPreview(this.value)">
                    </div>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeTagModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Side Panel for Comments Only -->
    <div id="side-panel-backdrop" class="side-panel-backdrop" onclick="closeSidePanel()"></div>
    <div id="side-panel" class="side-panel">
        <div class="side-panel-header">
            <div class="side-panel-title-wrapper">
                <h2 class="side-panel-title">Comments</h2>
                <span id="side-panel-engagement-name" class="side-panel-engagement-name"></span>
            </div>
            <button class="side-panel-close" onclick="closeSidePanel()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="side-panel-body">
            <!-- Comments Section -->
            <div class="comments-section comments-only">
                <div id="panel-comments" class="comments-list">
                    <!-- Comments will be rendered here -->
                </div>
                <!-- Comment Input Area -->
                <div class="comment-input-area">
                    <textarea id="comment-input" class="comment-textarea" placeholder="Add a comment..."></textarea>
                    <button type="button" class="comment-submit-btn" onclick="addComment()">Add Comment</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Create Todo Modal -->
    <div id="todo-modal" class="modal hidden">
        <div class="modal-backdrop" id="todo-modal-backdrop" onclick="handleTodoModalBackdropClick()"></div>
        <div class="modal-content" id="todo-modal-content">
            <!-- Issue-101: Modal header with edit button -->
            <div class="modal-header" id="todo-modal-header">
                <h2 id="modal-title" class="modal-title">New Todo</h2>
                <button type="button" id="todo-edit-mode-btn" class="modal-edit-btn hidden" onclick="switchToEditMode()" title="Edit">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                    </svg>
                </button>
            </div>

            <!-- Issue-101: Read-only view -->
            <div id="todo-readonly-view" class="todo-readonly-view hidden">
                <!-- Content will be rendered dynamically -->
            </div>

            <form id="todo-form" onsubmit="saveTodo(event)">
                <div id="todo-form-columns" class="todo-form-columns">
                    <!-- Left Column - Main Todo Form -->
                    <div id="todo-form-left" class="todo-form-left">
                        <div class="form-group">
                            <label for="todo-title" class="form-label">Title <span class="required">*</span></label>
                            <input type="text" id="todo-title" class="form-input" placeholder="What needs to be done?" required autofocus>
                        </div>
                        <div class="form-group">
                            <label for="todo-description" class="form-label">Description</label>
                            <textarea id="todo-description" class="form-textarea" placeholder="Additional details (optional)"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="todo-deadline" class="form-label">Deadline <span class="required">*</span></label>
                            <input type="datetime-local" id="todo-deadline" class="datetime-input" data-datetimepicker required>
                        </div>
                        <div class="form-group">
                            <label for="todo-effort" class="form-label">Effort Level <span class="required">*</span></label>
                            <select id="todo-effort" class="effort-select" required>
                                <option value="minimal">Minimal Work (30 min)</option>
                                <option value="very_low">Very Low (1 hour)</option>
                                <option value="low">Low (2 hours)</option>
                                <option value="average" selected>Average (4 hours)</option>
                                <option value="high">High (6 hours)</option>
                                <option value="very_high">Very High (8 hours)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="todo-priority" class="form-label">Priority <span class="required">*</span></label>
                            <div class="priority-autocomplete-wrapper">
                                <input type="text" id="todo-priority" class="priority-input" placeholder="Type to select priority..." autocomplete="off" required>
                                <div id="priority-dropdown" class="priority-dropdown">
                                    <!-- Priority options will be rendered here -->
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="todo-engagement" class="form-label">Linked Engagement</label>
                            <div class="autocomplete-wrapper">
                                <div class="autocomplete-input-wrapper">
                                    <input type="text" id="todo-engagement" class="autocomplete-input" placeholder="Type to search or create..." autocomplete="off">
                                    <button type="button" id="todo-engagement-clear" class="autocomplete-clear" onclick="clearEngagementSelection()">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <line x1="18" y1="6" x2="6" y2="18"></line>
                                            <line x1="6" y1="6" x2="18" y2="18"></line>
                                        </svg>
                                    </button>
                                </div>
                                <div id="engagement-dropdown" class="autocomplete-dropdown">
                                    <!-- Dropdown items will be rendered here -->
                                </div>
                            </div>
                        </div>
                        <!-- Tags Section -->
                        <div class="form-group">
                            <label class="form-label">Tags</label>
                            <div class="tag-input-container" id="todo-tag-container">
                                <div class="selected-tags" id="todo-selected-tags">
                                    <!-- Selected tags will be rendered here -->
                                </div>
                                <div class="tag-input-wrapper">
                                    <input type="text" id="todo-tag-input" class="tag-input" placeholder="Type to add tags..." autocomplete="off">
                                    <div id="todo-tag-dropdown" class="tag-dropdown">
                                        <!-- Tag suggestions will be rendered here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-actions" id="modal-actions">
                            <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                            <span id="todo-save-wrapper" class="btn-tooltip-wrapper">
                                <button type="submit" id="todo-save-btn" class="btn btn-primary">Save</button>
                            </span>
                        </div>
                    </div>

                    <!-- Column Separator -->
                    <div id="column-separator" class="column-separator"></div>

                    <!-- Right Column - Inline Engagement Panel -->
                    <div id="todo-form-right" class="todo-form-right">
                        <div class="inline-eng-panel">
                            <div class="inline-eng-panel-header">
                                <span class="inline-eng-panel-title">New Engagement</span>
                            </div>
                            <div class="form-group">
                                <label for="inline-eng-name" class="form-label">Name</label>
                                <input type="text" id="inline-eng-name" class="form-input" placeholder="Engagement name" readonly>
                            </div>
                            <div class="form-group">
                                <label for="inline-eng-description" class="form-label">Description</label>
                                <textarea id="inline-eng-description" class="form-textarea inline-eng-textarea" placeholder="Additional details (optional)"></textarea>
                            </div>
                            <div class="form-group">
                                <label for="inline-eng-start-date" class="form-label">Start Date</label>
                                <input type="date" id="inline-eng-start-date" class="form-input" data-datetimepicker>
                            </div>
                            <div class="form-group">
                                <label for="inline-eng-contact" class="form-label">Contact</label>
                                <div class="autocomplete-wrapper">
                                    <div class="autocomplete-input-wrapper">
                                        <input type="text" id="inline-eng-contact" class="form-input" placeholder="Type to search or create person..." autocomplete="off">
                                        <button type="button" id="inline-eng-contact-clear" class="autocomplete-clear" onclick="clearInlineOppContact()">
                                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                                <line x1="6" y1="6" x2="18" y2="18"></line>
                                            </svg>
                                        </button>
                                    </div>
                                    <div id="inline-eng-contact-dropdown" class="autocomplete-dropdown">
                                        <!-- Contact dropdown items will be rendered here -->
                                    </div>
                                </div>
                                <!-- Inline Person Creation Form (within inline engagement) -->
                                <div id="inline-eng-person-form" class="inline-contact-form">
                                    <div class="inline-contact-header">
                                        <span class="inline-contact-title">Create New Person</span>
                                        <div class="inline-contact-actions">
                                            <button type="button" class="btn btn-secondary" onclick="cancelInlineOppPerson()">Cancel</button>
                                            <button type="button" class="btn btn-primary" id="inline-eng-person-add-btn" onclick="confirmInlineOppPerson()">Add</button>
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label for="inline-eng-person-name" class="form-label">Name</label>
                                        <input type="text" id="inline-eng-person-name" class="form-input" placeholder="Person's name" readonly>
                                    </div>
                                    <div class="form-group">
                                        <label for="inline-eng-person-role" class="form-label">Role</label>
                                        <input type="text" id="inline-eng-person-role" class="form-input" placeholder="Person's role">
                                    </div>
                                </div>
                            </div>
                            <div class="inline-eng-panel-footer">
                                <button type="button" class="btn btn-secondary" id="inline-eng-cancel-btn" onclick="cancelInlineEngagement()">Cancel</button>
                                <button type="button" class="btn btn-primary" id="inline-eng-add-btn" onclick="confirmInlineEngagement()">Add</button>
                            </div>
                        </div>
                    </div>
                </div>
            </form>
        </div>
    </div>

    <!-- Create Engagement Modal -->
    <div id="engagement-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeEngagementModal()"></div>
        <div class="modal-content">
            <h2 class="modal-title">New Engagement</h2>
            <form id="engagement-form" onsubmit="saveEngagement(event)">
                <div class="form-group">
                    <label for="eng-name" class="form-label">Name <span class="required">*</span></label>
                    <input type="text" id="eng-name" class="form-input" placeholder="Engagement name" required autofocus>
                </div>
                <div class="form-group">
                    <label for="eng-description" class="form-label">Description</label>
                    <input type="text" id="eng-description" class="form-input" placeholder="Brief description">
                </div>
                <div class="form-group">
                    <label for="eng-start-date" class="form-label">Start Date</label>
                    <input type="date" id="eng-start-date" class="form-input" data-datetimepicker>
                </div>
                <div class="form-group">
                    <label for="eng-contact" class="form-label">Contact</label>
                    <div class="autocomplete-wrapper">
                        <input type="text" id="eng-contact" class="form-input" placeholder="Type to search or create person..." autocomplete="off">
                        <button type="button" id="eng-contact-clear" class="autocomplete-clear" onclick="clearOppContact()">×</button>
                        <div id="contact-dropdown" class="autocomplete-dropdown">
                            <!-- Contact dropdown items will be rendered here -->
                        </div>
                    </div>
                    <!-- Inline Person Creation Form -->
                    <div id="inline-person-form" class="inline-person-form">
                        <div class="inline-person-header">
                            <span class="inline-person-title">Create New Person</span>
                            <div class="inline-person-actions">
                                <button type="button" class="btn btn-secondary" onclick="cancelInlinePerson()">Cancel</button>
                                <button type="button" class="btn btn-primary" onclick="confirmInlinePerson()">Add</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="inline-person-name" class="form-label">Name</label>
                            <input type="text" id="inline-person-name" class="form-input" placeholder="Person's name">
                        </div>
                        <div class="form-group">
                            <label for="inline-person-role" class="form-label">Role</label>
                            <input type="text" id="inline-person-role" class="form-input" placeholder="Person's role">
                        </div>
                    </div>
                </div>
                <!-- Tags Section -->
                <div class="form-group">
                    <label class="form-label">Tags</label>
                    <div class="tag-input-container" id="opp-tag-container">
                        <div class="selected-tags" id="opp-selected-tags">
                            <!-- Selected tags will be rendered here -->
                        </div>
                        <div class="tag-input-wrapper">
                            <input type="text" id="opp-tag-input" class="tag-input" placeholder="Type to add tags..." autocomplete="off">
                            <div id="opp-tag-dropdown" class="tag-dropdown">
                                <!-- Tag suggestions will be rendered here -->
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeEngagementModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="confirm-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeConfirmModal()"></div>
        <div class="modal-content confirm-modal-content">
            <svg class="confirm-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
            <h2 class="confirm-title">Delete Engagement?</h2>
            <p id="confirm-message" class="confirm-message">Are you sure you want to delete this engagement? This action cannot be undone.</p>
            <div class="confirm-actions">
                <button type="button" class="btn btn-secondary" onclick="closeConfirmModal()">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="confirmDeleteEngagement()">Delete</button>
            </div>
        </div>
    </div>

    <!-- Cancel Engagement Modal -->
    <div id="cancel-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeCancelModal()"></div>
        <div class="modal-content cancel-modal-content">
            <svg class="cancel-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="15" y1="9" x2="9" y2="15"></line>
                <line x1="9" y1="9" x2="15" y2="15"></line>
            </svg>
            <h2 class="modal-title">Cancel Engagement</h2>
            <p id="cancel-eng-name" style="text-align: center; color: #6C757D; margin-bottom: 20px;"></p>
            <div class="form-group">
                <label for="cancel-reason" class="form-label">Reason for Cancellation <span class="required">*</span></label>
                <textarea id="cancel-reason" class="form-textarea" placeholder="Please provide a reason for cancelling this engagement..." required></textarea>
            </div>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeCancelModal()">Back</button>
                <button type="button" class="btn btn-warning" onclick="confirmCancelEngagement()">Cancel Engagement</button>
            </div>
        </div>
    </div>

    <!-- Todo Action Modal (for Close/Cancel engagement with linked todos) -->
    <div id="todo-action-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeTodoActionModal()"></div>
        <div class="modal-content todo-action-modal-content">
            <svg class="cancel-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
            </svg>
            <h2 class="modal-title" id="todo-action-modal-title">Handle Linked Todos</h2>
            <p id="todo-action-eng-name" style="text-align: center; color: #6C757D; margin-bottom: 10px;"></p>
            <p id="todo-action-count" style="text-align: center; color: #495057; margin-bottom: 20px; font-size: 14px;"></p>
            <p style="font-size: 13px; color: #495057; margin-bottom: 16px; text-align: center;">
                What would you like to do with the linked todos?
            </p>
            <div class="todo-action-buttons">
                <button type="button" class="btn btn-success" onclick="todoActionComplete()" style="width: 100%; margin-bottom: 8px;">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px; margin-right: 6px;">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                    Complete All Todos
                </button>
                <button type="button" class="btn btn-warning" onclick="todoActionDrop()" style="width: 100%; margin-bottom: 8px;">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px; margin-right: 6px;">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="15" y1="9" x2="9" y2="15"></line>
                        <line x1="9" y1="9" x2="15" y2="15"></line>
                    </svg>
                    Drop All Todos
                </button>
                <button type="button" class="btn btn-danger" onclick="todoActionDelete()" style="width: 100%; margin-bottom: 16px;">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px; margin-right: 6px;">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    </svg>
                    Delete All Todos
                </button>
            </div>
            <div class="modal-actions" style="border-top: 1px solid #E9ECEF; padding-top: 16px;">
                <button type="button" class="btn btn-secondary" onclick="closeTodoActionModal()" style="width: 100%;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Block Reason Modal (Issue-67) -->
    <div id="block-reason-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeBlockReasonModal()"></div>
        <div class="modal-content block-reason-modal-content">
            <svg class="cancel-icon" viewBox="0 0 24 24" fill="none" stroke="#FF9800" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="6" y="4" width="4" height="16"></rect>
                <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
            <h2 class="modal-title">Block Todo</h2>
            <p id="block-todo-title" style="text-align: center; color: #6C757D; margin-bottom: 10px; font-weight: 500;"></p>
            <p class="block-reason-hint">
                Optionally provide a reason why this task is blocked.
            </p>
            <textarea id="block-reason-input" class="block-reason-input" placeholder="e.g., Waiting for client approval..."></textarea>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeBlockReasonModal()">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="confirmBlockTodo()" style="background: #FF9800; border-color: #FF9800;">Block</button>
            </div>
        </div>
    </div>

    <!-- Meeting Modal (Issue-80) -->
    <div id="meeting-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeMeetingModal()"></div>
        <div class="modal-content meeting-modal-content">
            <h2 class="modal-title" id="meeting-modal-title">New Meeting</h2>
            <div class="meeting-form-container">
                <!-- Main form (left side) -->
                <form id="meeting-form" class="meeting-form-left" onsubmit="saveMeeting(event)">
                    <div class="form-group">
                        <label for="meeting-title" class="form-label">Title <span class="required">*</span></label>
                        <input type="text" id="meeting-title" class="form-input" placeholder="What needs to be done?" required>
                    </div>
                    <div class="form-group">
                        <label for="meeting-description" class="form-label">Description</label>
                        <textarea id="meeting-description" class="form-input" placeholder="Additional details (optional)" rows="2"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="meeting-date" class="form-label">Date <span class="required">*</span></label>
                        <div class="datetime-input-wrapper">
                            <input type="datetime-local" id="meeting-date" class="datetime-input" data-datetimepicker required>
                        </div>
                    </div>
                    <div class="form-group meeting-duration-row">
                        <div class="meeting-duration-field">
                            <label for="meeting-duration" class="form-label">Duration <span class="required">*</span></label>
                            <input type="text" id="meeting-duration" class="form-input meeting-duration-input" value="1 hr" placeholder="1 hr (default)" required>
                            <span class="meeting-duration-hint">(default)</span>
                        </div>
                        <div class="meeting-recurring-checkbox">
                            <label class="recurring-checkbox-label">
                                <input type="checkbox" id="meeting-recurring-check" onchange="toggleRecurringPanel()">
                                <span>Make this a recurring meeting</span>
                            </label>
                        </div>
                    </div>
                    <div class="modal-actions">
                        <button type="button" class="btn btn-secondary" onclick="closeMeetingModal()">Cancel</button>
                        <button type="submit" class="btn btn-primary" id="meeting-save-btn">Save</button>
                    </div>
                </form>
                <!-- Recurring panel (right side) -->
                <div id="meeting-recurring-panel" class="meeting-recurring-panel">
                    <div class="recurring-panel-header">Recurring</div>
                    <div class="recurring-frequency-options">
                        <label class="recurring-option">
                            <input type="checkbox" name="recurring-freq" value="daily" onchange="selectRecurringFrequency('daily')">
                            <span>Daily</span>
                        </label>
                        <label class="recurring-option selected">
                            <input type="checkbox" name="recurring-freq" value="weekly" checked onchange="selectRecurringFrequency('weekly')">
                            <span>Weekly</span>
                        </label>
                        <label class="recurring-option">
                            <input type="checkbox" name="recurring-freq" value="biweekly" onchange="selectRecurringFrequency('biweekly')">
                            <span>Bi-Weekly</span>
                        </label>
                        <label class="recurring-option">
                            <input type="checkbox" name="recurring-freq" value="3weeks" onchange="selectRecurringFrequency('3weeks')">
                            <span>3 Weeks</span>
                        </label>
                        <label class="recurring-option">
                            <input type="checkbox" name="recurring-freq" value="monthly" onchange="selectRecurringFrequency('monthly')">
                            <span>Monthly</span>
                        </label>
                    </div>
                    <div class="recurring-end-date">
                        <label class="form-label">End By: <span id="recurring-end-icon">📅</span></label>
                        <div class="datetime-input-wrapper">
                            <input type="date" id="meeting-recurring-end" class="datetime-input" data-datetimepicker onchange="updateMeetingSaveButton()">
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Promote to Pre-Project Modal -->
    <div id="promote-preproject-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closePromotePreProjectModal()"></div>
        <div class="modal-content promote-modal-content">
            <h2 class="modal-title">Promote to Pre-Project</h2>
            <p id="promote-preproject-name" style="text-align: center; color: #6C757D; margin-bottom: 20px;"></p>
            <p style="font-size: 13px; color: #495057; margin-bottom: 16px;">
                Pre-project phase tracks informal work with expectation of future project formalization.
                You can track monthly allocations during this phase.
            </p>
            <div class="promote-form-group">
                <label for="preproject-started" class="promote-form-label">Pre-Project Started</label>
                <input type="date" id="preproject-started" class="promote-form-input" data-datetimepicker>
            </div>
            <div class="promote-form-group">
                <label for="preproject-expected" class="promote-form-label">Expected Formalization Date (Optional)</label>
                <input type="date" id="preproject-expected" class="promote-form-input" data-datetimepicker>
            </div>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closePromotePreProjectModal()">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="confirmPromoteToPreProject()">Promote</button>
            </div>
        </div>
    </div>

    <!-- Promote to Project Modal -->
    <div id="promote-project-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closePromoteProjectModal()"></div>
        <div class="modal-content promote-modal-content" style="max-width: 600px;">
            <h2 class="modal-title">Promote to Project</h2>
            <p id="promote-project-name" style="text-align: center; color: #6C757D; margin-bottom: 20px;"></p>
            <p style="font-size: 13px; color: #495057; margin-bottom: 16px;">
                Converting to a formal project with funding and governance.
                Pre-project time can be charged back to the project.
            </p>
            <div class="promote-form-group">
                <label for="project-formalized" class="promote-form-label">Formalization Date</label>
                <input type="date" id="project-formalized" class="promote-form-input" data-datetimepicker>
            </div>
            <div class="promote-form-group">
                <label for="project-code" class="promote-form-label">Project Code (Optional)</label>
                <input type="text" id="project-code" class="promote-form-input" placeholder="e.g., PRJ-2025-042">
            </div>
            <div class="promote-form-group">
                <label for="project-funding" class="promote-form-label">Funding Source (Optional)</label>
                <input type="text" id="project-funding" class="promote-form-input" placeholder="e.g., IT Capital Budget 2025">
            </div>
            <div class="promote-form-group">
                <label class="promote-form-label">Project Timeline</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <div>
                        <label for="project-start" style="font-size: 11px; color: #6C757D;">Start Date</label>
                        <input type="date" id="project-start" class="promote-form-input" data-datetimepicker>
                    </div>
                    <div>
                        <label for="project-end" style="font-size: 11px; color: #6C757D;">End Date</label>
                        <input type="date" id="project-end" class="promote-form-input" data-datetimepicker>
                    </div>
                </div>
            </div>
            <div class="promote-form-group">
                <label for="project-allocation" class="promote-form-label">Allocation Percentage</label>
                <input type="number" id="project-allocation" class="promote-form-input" placeholder="25" min="0" max="100">
            </div>
            <div id="chargeback-options" class="promote-form-group" style="display: none;">
                <label class="promote-form-label">Charge-Back Mode</label>
                <p style="font-size: 12px; color: #6C757D; margin-bottom: 8px;">
                    How should pre-project time be charged to the project?
                </p>
                <div class="chargeback-mode-options">
                    <label class="chargeback-mode-option selected" onclick="selectChargeBackMode('original')">
                        <input type="radio" name="chargeback-mode" value="original" checked>
                        <div class="chargeback-mode-label">
                            <div class="chargeback-mode-title">Original Rate</div>
                            <div class="chargeback-mode-desc">Charge the actual percentage worked during pre-project</div>
                        </div>
                    </label>
                    <label class="chargeback-mode-option" onclick="selectChargeBackMode('project_rate')">
                        <input type="radio" name="chargeback-mode" value="project_rate">
                        <div class="chargeback-mode-label">
                            <div class="chargeback-mode-title">Project Rate</div>
                            <div class="chargeback-mode-desc">Charge at the formal project allocation rate</div>
                        </div>
                    </label>
                    <label class="chargeback-mode-option" onclick="selectChargeBackMode('none')">
                        <input type="radio" name="chargeback-mode" value="none">
                        <div class="chargeback-mode-label">
                            <div class="chargeback-mode-title">No Charge-Back</div>
                            <div class="chargeback-mode-desc">Don't charge pre-project time to the project</div>
                        </div>
                    </label>
                </div>
            </div>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closePromoteProjectModal()">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="confirmPromoteToProject()">Promote to Project</button>
            </div>
        </div>
    </div>

    <!-- Unified Promotion Modal (Issue-57) -->
    <div id="unified-promote-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeUnifiedPromoteModal()"></div>
        <div class="modal-content unified-promote-modal">
            <div class="unified-promote-header">
                <h2 id="unified-promote-title" class="unified-promote-title">Promote Engagement</h2>
                <button class="unified-promote-close" onclick="closeUnifiedPromoteModal()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>

            <!-- Pre-Project Section -->
            <div id="preproject-allocation-section" class="allocation-section">
                <div class="allocation-section-header" onclick="togglePreProjectSection()">
                    <div id="preproject-toggle" class="allocation-section-toggle"></div>
                    <span class="allocation-section-title">Pre-Project Time Reporting</span>
                    <a href="#" class="allocation-section-link" onclick="event.stopPropagation();">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                            <polyline points="15 3 21 3 21 9"></polyline>
                            <line x1="10" y1="14" x2="21" y2="3"></line>
                        </svg>
                    </a>
                </div>
                <div id="preproject-section-content" class="allocation-section-content">
                    <div class="allocation-input-row">
                        <span class="allocation-input-label">Pre-Project Allocation</span>
                        <input type="text" id="preproject-allocation-input" class="allocation-input" value="25%" oninput="updatePreProjectAllocationValue(this.value)">
                    </div>
                    <div class="allocation-months-label">Pre-Project Allocation Months</div>
                    <div id="preproject-timeline" class="month-timeline-container">
                        <!-- Timeline will be rendered dynamically -->
                    </div>
                </div>
            </div>

            <!-- Project Section -->
            <div id="project-allocation-section" class="allocation-section">
                <div class="allocation-section-header" onclick="toggleProjectSection()">
                    <div id="project-toggle" class="allocation-section-toggle"></div>
                    <span class="allocation-section-title">Project Allocation Time Reporting</span>
                    <a href="#" class="allocation-section-link" onclick="event.stopPropagation();">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                            <polyline points="15 3 21 3 21 9"></polyline>
                            <line x1="10" y1="14" x2="21" y2="3"></line>
                        </svg>
                    </a>
                </div>
                <div id="project-section-content" class="allocation-section-content">
                    <div class="allocation-input-row">
                        <span class="allocation-input-label">Project Allocation</span>
                        <input type="text" id="project-allocation-input" class="allocation-input" value="50%" oninput="updateProjectAllocationValue(this.value)">
                    </div>
                    <div class="allocation-months-label">Project Allocation Months</div>
                    <div id="project-timeline" class="month-timeline-container">
                        <!-- Timeline will be rendered dynamically -->
                    </div>
                </div>
            </div>

            <div class="unified-promote-footer">
                <button type="button" class="btn btn-secondary" onclick="closeUnifiedPromoteModal()">Cancel</button>
                <button type="button" id="unified-promote-save-btn" class="btn-save" onclick="saveUnifiedPromotion()" disabled>Save</button>
            </div>
        </div>
    </div>

    <!-- Person Modal -->
    <div id="person-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closePersonModal()"></div>
        <div class="modal-content">
            <h2 id="person-modal-title" class="modal-title">New Person</h2>
            <form id="person-form" onsubmit="savePerson(event)">
                <div class="form-group">
                    <label for="person-name" class="form-label">Name <span class="required">*</span></label>
                    <input type="text" id="person-name" class="form-input" placeholder="Person's name" required>
                </div>
                <div class="form-group">
                    <label for="person-role" class="form-label">Role</label>
                    <div class="autocomplete-wrapper">
                        <input type="text" id="person-role" class="form-input" placeholder="Type to search or create role..." autocomplete="off">
                        <button type="button" id="person-role-clear" class="autocomplete-clear" onclick="clearPersonRole()">×</button>
                        <div id="role-dropdown" class="autocomplete-dropdown">
                            <!-- Role dropdown items will be rendered here -->
                        </div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closePersonModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- IndexedDB Unavailable Warning Modal -->
    <div id="indexeddb-warning-modal" class="modal hidden">
        <div class="modal-backdrop"></div>
        <div class="modal-content confirm-modal-content">
            <svg class="confirm-icon" style="stroke: #EF4444;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
            <h2 class="modal-title">Browser Storage Unavailable</h2>
            <p style="text-align: center; color: #6C757D; margin-bottom: 20px;">
                IndexedDB is not available in your browser. This usually happens when using private/incognito browsing mode.
            </p>
            <p style="text-align: center; color: #6C757D; margin-bottom: 20px;">
                Please switch to a regular browser window to use TodoManager, as your data cannot be saved in private browsing mode.
            </p>
        </div>
    </div>

    <!-- Clear State Confirmation Modal -->
    <div id="clear-state-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeClearStateModal()"></div>
        <div class="modal-content confirm-modal-content">
            <svg class="confirm-icon" style="stroke: #EF4444;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
            <h2 class="modal-title">Clear Browser State</h2>
            <p style="text-align: center; color: #6C757D; margin-bottom: 20px;">
                This will permanently delete all your data stored in the browser, including todos, engagements, people, and settings.
            </p>
            <p style="text-align: center; color: #6C757D; margin-bottom: 20px;">
                Would you like to export your data before clearing?
            </p>
            <div class="modal-actions" style="flex-direction: column; gap: 12px;">
                <button type="button" class="btn btn-primary" onclick="exportThenClear()" style="width: 100%;">Export Data & Clear</button>
                <button type="button" class="btn btn-danger" onclick="confirmClearState()" style="width: 100%;">Clear Without Export</button>
                <button type="button" class="btn btn-secondary" onclick="closeClearStateModal()" style="width: 100%;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- What's New Modal (Issue-76, Issue-78) -->
    <div id="whats-new-modal" class="modal hidden">
        <div class="modal-backdrop"></div>
        <div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
            <div style="text-align: center; margin-bottom: 24px;">
                <div style="font-size: 48px; margin-bottom: 12px;">🎉</div>
                <h2 class="modal-title" style="margin-bottom: 8px;">Welcome to Version <span id="whats-new-version">1.1.0</span></h2>
                <p style="color: #6C757D; font-size: 14px;">Your data has been migrated to support new features</p>
            </div>

            <div style="text-align: left; margin-bottom: 24px;">
                <h3 style="font-size: 16px; font-weight: 600; color: #1F1F1F; margin-bottom: 12px;">What's New</h3>
                <ul style="margin: 0; padding-left: 20px; color: #374151; font-size: 14px; line-height: 1.8;">
                    <li><strong>Daily Load Redesign</strong> - 8-day workload forecast with priority-based task ordering</li>
                    <li><strong>Yesterday Column</strong> - See completed tasks and missed overdue items from previous work day</li>
                    <li><strong>Smart Day Labels</strong> - Shows weekday names or dates when there's a gap (weekends/holidays)</li>
                    <li><strong>Workload Borders</strong> - Color-coded column borders indicate daily workload level (green/yellow/orange/red)</li>
                    <li><strong>Symmetric Layout</strong> - Daily Plan and Daily Load panels now have equal widths</li>
                </ul>
            </div>

            <div id="whats-new-migration" style="display: none; background: #FEF3C7; border-radius: 8px; padding: 16px; margin-bottom: 24px;">
                <h3 style="font-size: 14px; font-weight: 600; color: #92400E; margin-bottom: 8px;">⚡ Data Migration Performed</h3>
                <p id="whats-new-migration-count" style="color: #92400E; font-size: 13px; margin-bottom: 8px;"></p>
                <div id="whats-new-migration-list" style="max-height: 150px; overflow-y: auto; font-size: 12px; color: #92400E;"></div>
            </div>

            <div style="text-align: center;">
                <button type="button" class="btn btn-primary" onclick="closeWhatsNewModal()" style="min-width: 200px;">Continue</button>
            </div>
        </div>
    </div>

    <!-- Conflict Resolution Modal (Issue-82) -->
    <div id="conflict-resolution-modal" class="modal hidden">
        <div class="modal-backdrop"></div>
        <div class="modal-content" style="max-width: 650px; max-height: 80vh; overflow-y: auto;">
            <div style="text-align: center; margin-bottom: 20px;">
                <div style="font-size: 40px; margin-bottom: 8px;">⚠️</div>
                <h2 class="modal-title" style="margin-bottom: 8px;">Scheduling Conflicts Detected</h2>
                <p style="color: #6C757D; font-size: 14px;">The following items conflict with your new calendar exclusion dates.</p>
            </div>

            <div id="conflict-items-container" style="margin-bottom: 20px;">
                <!-- Conflict items will be rendered here -->
            </div>

            <div style="display: flex; gap: 12px; justify-content: space-between; align-items: center; border-top: 1px solid #E5E7EB; padding-top: 20px;">
                <div style="display: flex; gap: 8px;">
                    <button type="button" class="btn btn-secondary" onclick="selectAllConflicts()" style="font-size: 12px; padding: 6px 12px;">Select All</button>
                    <button type="button" class="btn btn-secondary" onclick="deselectAllConflicts()" style="font-size: 12px; padding: 6px 12px;">Deselect All</button>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button type="button" class="btn btn-secondary" onclick="moveSelectedConflicts()" style="background: #10B981; color: white; border-color: #10B981;">
                        <span style="margin-right: 4px;">→</span> Move Selected
                    </button>
                    <button type="button" class="btn btn-primary" onclick="deleteSelectedConflicts()" style="background: #DC2626; border-color: #DC2626;">
                        <span style="margin-right: 4px;">🗑</span> Delete Selected
                    </button>
                </div>
            </div>

            <div style="text-align: center; margin-top: 16px;">
                <button type="button" class="btn btn-secondary" onclick="closeConflictResolutionModal()" style="min-width: 120px;">Keep All (No Changes)</button>
            </div>
        </div>
    </div>

    <!-- Holiday Template Modal -->
    <div id="holiday-template-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeHolidayTemplateModal()"></div>
        <div class="modal-content" style="max-width: 450px;">
            <h2 class="modal-title" style="margin-bottom: 16px;">Apply Holiday Template</h2>
            <p style="color: #6C757D; font-size: 13px; margin-bottom: 20px;">
                Select a country template and end year to automatically add public holidays to your calendar.
            </p>

            <div style="margin-bottom: 16px;">
                <label style="display: block; font-size: 13px; font-weight: 600; color: #374151; margin-bottom: 6px;">Country</label>
                <select id="holiday-template-country" style="width: 100%; padding: 8px 12px; border: 1px solid #D1D5DB; border-radius: 6px; font-size: 14px;">
                    <option value="">Select a country...</option>
                    <option value="NL">Netherlands</option>
                    <option value="DE">Germany</option>
                    <option value="UK">United Kingdom</option>
                    <option value="US">United States of America</option>
                    <option value="IN">India</option>
                </select>
            </div>

            <div style="margin-bottom: 20px;">
                <label style="display: block; font-size: 13px; font-weight: 600; color: #374151; margin-bottom: 6px;">Add holidays up to and including</label>
                <select id="holiday-template-end-year" style="width: 100%; padding: 8px 12px; border: 1px solid #D1D5DB; border-radius: 6px; font-size: 14px;">
                    <!-- Years will be populated dynamically -->
                </select>
            </div>

            <div id="holiday-template-preview" style="display: none; background: #F3F4F6; border-radius: 6px; padding: 12px; margin-bottom: 20px; max-height: 150px; overflow-y: auto;">
                <p style="font-size: 12px; font-weight: 600; color: #374151; margin-bottom: 8px;">Preview:</p>
                <p id="holiday-template-preview-text" style="font-size: 12px; color: #6B7280; margin: 0;"></p>
            </div>

            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeHolidayTemplateModal()">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="applyHolidayTemplate()">Apply Template</button>
            </div>
        </div>
    </div>

    <!-- Delete Person Confirmation Modal -->
    <div id="delete-person-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeDeletePersonModal()"></div>
        <div class="modal-content confirm-modal-content">
            <svg class="confirm-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
            <h2 class="modal-title">Delete Person</h2>
            <p id="delete-person-name" style="text-align: center; color: #6C757D; margin-bottom: 20px;"></p>
            <p style="text-align: center; margin-bottom: 20px;">Are you sure you want to delete this person? This will remove them from any linked engagements.</p>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeDeletePersonModal()">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="confirmDeletePerson()">Delete</button>
            </div>
        </div>
    </div>

    <!-- Work Day Hours Modal -->
    <div id="workday-hours-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeWorkDayHoursModal()"></div>
        <div class="modal-content" style="max-width: 320px;">
            <h2 class="modal-title" id="workday-hours-modal-title">Edit Hours</h2>
            <form id="workday-hours-form" onsubmit="saveWorkDayHours(event)">
                <input type="hidden" id="workday-hours-day-index">
                <div class="form-group">
                    <label for="workday-hours-input" class="form-label">Hours per day</label>
                    <input type="number" id="workday-hours-input" class="form-input" min="0" max="24" step="0.5" required style="text-align: center; font-size: 18px; padding: 12px;">
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeWorkDayHoursModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // ========================================
        // LOGGER UTILITY - Configurable logging (Issue-64)
        // ========================================
        const Logger = {
            _debug: false,
            get debug() { return this._debug; },
            set debug(value) { this._debug = !!value; },
            error: function(msg, err) {
                if (this._debug) {
                    console.error(msg, err);
                }
            },
            log: function(msg, ...args) {
                if (this._debug) {
                    console.log(msg, ...args);
                }
            },
            warn: function(msg, ...args) {
                if (this._debug) {
                    console.warn(msg, ...args);
                }
            }
        };

        // ========================================
        // PRIORITY TAGS - System-defined constants
        // ========================================
        const PRIORITY_TAGS = Object.freeze({
            urgent: {
                id: "priority-urgent",
                name: "urgent",
                label: "Urgent",
                color: "#ef4444",
                weight: 100,
                description: "Must be addressed immediately"
            },
            high: {
                id: "priority-high",
                name: "high",
                label: "High Priority",
                color: "#f97316",
                weight: 75,
                description: "Important, should be done soon"
            },
            normal: {
                id: "priority-normal",
                name: "normal",
                label: "Normal",
                color: "#3b82f6",
                weight: 50,
                description: "Standard priority"
            },
            low: {
                id: "priority-low",
                name: "low",
                label: "Low Priority",
                color: "#6b7280",
                weight: 25,
                description: "Can wait, do when time permits"
            },
            someday: {
                id: "priority-someday",
                name: "someday",
                label: "Someday",
                color: "#9ca3af",
                weight: 10,
                description: "No urgency, backlog item"
            }
        });

        const DEFAULT_PRIORITY = "normal";

        // ========================================
        // EFFORT LEVELS - Configuration
        // ========================================
        const EFFORT_CONFIG = Object.freeze({
            minimal:   { label: "Minimal Work", minutes: 30,  icon: "⚡" },
            very_low:  { label: "Very Low",     minutes: 60,  icon: "🟢" },
            low:       { label: "Low",          minutes: 120, icon: "🟡" },
            average:   { label: "Average",      minutes: 240, icon: "🟠" },
            high:      { label: "High",         minutes: 360, icon: "🔴" },
            very_high: { label: "Very High",    minutes: 480, icon: "⚫" }
        });

        const DEFAULT_EFFORT = "average";
        const DEFAULT_TAG_COLOR = '#F59E0B'; // Default amber color for tags

        // ========================================
        // IMPORT VALIDATION - Limits (Issue #63)
        // ========================================
        const IMPORT_LIMITS = Object.freeze({
            MAX_STRING_LENGTH: 10000,      // Max length for any string field
            MAX_ARRAY_SIZE: 10000,         // Max items in any array (todos, engagements, etc.)
            MAX_COMMENTS_PER_ENGAGEMENT: 1000,  // Max comments per engagement
            MAX_ID_LENGTH: 100             // Max length for ID fields
        });

        // Valid enum values for validation
        const VALID_EFFORT_VALUES = Object.keys(EFFORT_CONFIG);
        const VALID_PRIORITY_VALUES = Object.keys(PRIORITY_TAGS);
        const VALID_ENGAGEMENT_TYPES = ['engagement', 'pre-project', 'project'];
        const VALID_ENGAGEMENT_STATUSES = ['active', 'completed', 'closed', 'dropped', 'requested'];

        // ========================================
        // APP VERSION
        // ========================================
        const APP_VERSION = '1.8.0';

        // ========================================
        // PLANNING SETTINGS - Defaults
        // ========================================
        const DEFAULT_SETTINGS = Object.freeze({
            workdayMinutes: 480,        // 8-hour workday
            bufferPercentage: 15,       // 15% buffer for interruptions
            maxOverdueToShow: 5,        // Limit overdue display
            planningHorizonDays: 14,    // Look-ahead window
            debugLogging: false,        // Console logging disabled by default (Issue-64)
            completedVisibilityDays: 5  // Days to show completed/dropped todos (Issue-97)
        });

        // ========================================
        // WORK CALENDAR - Defaults
        // ========================================
        const DEFAULT_WORK_CALENDAR = Object.freeze({
            // Days of week: 0=Sunday, 1=Monday, ..., 6=Saturday
            workDays: {
                0: { enabled: false, hours: 0 },  // Sunday
                1: { enabled: true, hours: 8 },   // Monday
                2: { enabled: true, hours: 8 },   // Tuesday
                3: { enabled: true, hours: 8 },   // Wednesday
                4: { enabled: true, hours: 8 },   // Thursday
                5: { enabled: true, hours: 8 },   // Friday
                6: { enabled: false, hours: 0 }   // Saturday
            },
            holidays: [],  // Array of ISO date strings
            pto: []        // Array of ISO date strings
        });

        // ========================================
        // INDEXEDDB - State Persistence
        // ========================================
        const DB_NAME = 'TodoManagerDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'appState';
        let db = null;

        // Check if IndexedDB is available
        function isIndexedDBAvailable() {
            try {
                if (!window.indexedDB) {
                    return false;
                }
                // Test if we can actually open a database (fails in private mode on some browsers)
                return true;
            } catch (e) {
                return false;
            }
        }

        // Initialize IndexedDB
        function initDB() {
            return new Promise((resolve, reject) => {
                if (!isIndexedDBAvailable()) {
                    reject(new Error('IndexedDB is not available. Please ensure you are not in private browsing mode.'));
                    return;
                }

                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = (event) => {
                    reject(new Error('Failed to open database: ' + event.target.error));
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    const database = event.target.result;
                    if (!database.objectStoreNames.contains(STORE_NAME)) {
                        database.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    }
                };
            });
        }

        // Save state to IndexedDB
        function saveStateToIndexedDB() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const persistableState = {
                    id: 'state',
                    appVersion: APP_VERSION,
                    todos: state.todos,
                    engagements: state.engagements,
                    people: state.people,
                    roles: state.roles,
                    tags: state.tags,
                    settings: state.settings,
                    workCalendar: state.workCalendar,
                    allocations: state.allocations,
                    meetings: state.meetings,
                    lastModified: new Date().toISOString()
                };

                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(persistableState);

                request.onsuccess = () => resolve();
                request.onerror = () => reject(new Error('Failed to save state'));
            });
        }

        // Load state from IndexedDB
        function loadStateFromIndexedDB() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get('state');

                request.onsuccess = (event) => {
                    const savedState = event.target.result;
                    if (savedState) {
                        resolve(savedState);
                    } else {
                        resolve(null);
                    }
                };

                request.onerror = () => reject(new Error('Failed to load state'));
            });
        }

        // Clear all data from IndexedDB
        function clearIndexedDB() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.clear();

                request.onsuccess = () => resolve();
                request.onerror = () => reject(new Error('Failed to clear database'));
            });
        }

        // Get storage statistics
        async function getStorageStats() {
            const stats = {
                todoCount: state.todos.length,
                engagementCount: state.engagements.length,
                estimatedSize: 0
            };

            // Calculate estimated size
            const dataToMeasure = {
                todos: state.todos,
                engagements: state.engagements,
                people: state.people,
                roles: state.roles,
                tags: state.tags,
                settings: state.settings
            };

            const jsonString = JSON.stringify(dataToMeasure);
            stats.estimatedSize = new Blob([jsonString]).size;

            return stats;
        }

        // Format bytes to human-readable string
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Application state
        const state = {
            todos: [],
            engagements: [],
            people: [],
            roles: [],
            tags: [],
            currentPage: 'landing',
            currentTab: 'home',  // 'home', 'engagements', or 'settings'
            previousTab: 'home',  // Track previous tab for settings return navigation
            settingsSection: 'people',  // Current settings section
            modalOpen: false,
            modalReadOnly: false,  // Issue-101: Track read-only vs edit mode
            engagementModalOpen: false,
            personModalOpen: false,
            confirmModalOpen: false,
            cancelModalOpen: false,
            sidePanelOpen: false,
            editingTodoIndex: null,  // Track which todo is being edited (null = create mode)
            editingPersonIndex: null,  // Track which person is being edited (null = create mode)
            editingTagIndex: null,  // Track which tag is being edited (null = create mode)
            tagModalOpen: false,
            selectedEngagementIndex: null,  // Track which engagement is open in side panel (comments)
            editingEngagementIndex: null,  // Track which engagement is being edited (null = create mode)
            deleteEngagementIndex: null,  // Track which engagement is pending deletion
            deletePersonIndex: null,  // Track which person is pending deletion
            cancelEngagementIndex: null,  // Track which engagement is pending cancellation
            todoActionModalOpen: false,  // Track if todo action modal is open
            todoActionEngagementIndex: null,  // Track which engagement's todos are being handled
            todoActionType: null,  // 'close' or 'cancel' - to continue after handling todos
            // Autocomplete state
            selectedEngagementId: null,  // ID of selected engagement for todo linking
            selectedPersonId: null,  // ID of selected person for engagement contact
            pendingEngagement: null,  // New engagement to create when saving todo
            pendingPerson: null,  // New person to create when saving engagement
            autocompleteOpen: false,
            autocompleteHighlightIndex: -1,
            roleAutocompleteOpen: false,
            roleAutocompleteHighlightIndex: -1,
            contactAutocompleteOpen: false,
            contactAutocompleteHighlightIndex: -1,
            inlineEngFormOpen: false,
            inlinePersonFormOpen: false,
            // Inline person form within inline engagement (in Todo modal)
            inlineEngContactAutocompleteOpen: false,
            inlineEngContactAutocompleteHighlightIndex: -1,
            inlineEngPersonFormOpen: false,
            selectedInlineOppPersonId: null,
            pendingInlineOppPerson: null,
            showArchived: false,
            // Tag assignment state
            selectedTodoTagIds: [],  // Tag IDs selected for current todo
            selectedOppTagIds: [],   // Tag IDs selected for current engagement
            todoTagDropdownOpen: false,
            todoTagHighlightIndex: -1,
            engTagDropdownOpen: false,
            oppTagHighlightIndex: -1,
            // Planning settings
            settings: { ...DEFAULT_SETTINGS },
            // Issue-97: Collapsible sections expanded state
            recentlyCompletedExpanded: false,
            recentlyDroppedExpanded: false,
            // Issue-99: Future todo groups expanded state
            upcomingWeekExpanded: false,
            upcomingTwoWeeksExpanded: false,
            horizonExpanded: false,
            // Priority autocomplete state
            selectedPriority: DEFAULT_PRIORITY,
            priorityDropdownOpen: false,
            priorityHighlightIndex: -1,
            // Lifecycle modal state
            promotePreProjectModalOpen: false,
            promoteProjectModalOpen: false,
            promoteEngagementIndex: null,
            selectedChargeBackMode: 'original',
            // Engagement allocations (Issue-57)
            allocations: [],
            // Inline expansion state (Issue-57)
            expandedEngagementId: null,
            // Unified promote modal state (Issue-57)
            unifiedPromoteModalOpen: false,
            unifiedPromoteEngagementId: null,
            preProjectSectionEnabled: false,
            projectSectionEnabled: false,
            preProjectAllocationPercent: 25,
            projectAllocationPercent: 25,
            preProjectSelectedMonths: [],
            projectStartMonth: null,
            projectEndMonth: null,
            monthTimelineOffset: 0,
            // Search state (Issue-59)
            searchQuery: '',
            // Block todo state (Issue-67)
            blockReasonModalOpen: false,
            todoIndexToBlock: null,
            // Work Calendar (Issue-76)
            workCalendar: JSON.parse(JSON.stringify(DEFAULT_WORK_CALENDAR)),
            // What's New screen state (Issue-76)
            showWhatsNew: false,
            migrationSummary: null,
            // Meetings (Issue-80)
            meetings: [],
            meetingModalOpen: false,
            editingMeetingIndex: null
        };

        // DOM Elements - Landing and Home
        const landingPage = document.getElementById('landing-page');
        const homePage = document.getElementById('home-page');
        const todoList = document.getElementById('todo-list');
        const emptyState = document.getElementById('empty-state');
        const todoShortcutHintFloating = document.getElementById('todo-shortcut-hint-floating');
        const todoModal = document.getElementById('todo-modal');
        const todoModalBackdrop = document.getElementById('todo-modal-backdrop');  // Issue-101
        const todoForm = document.getElementById('todo-form');
        const todoTitleInput = document.getElementById('todo-title');
        const todoDescriptionInput = document.getElementById('todo-description');
        const todoDeadlineInput = document.getElementById('todo-deadline');
        const todoEffortSelect = document.getElementById('todo-effort');
        const todoPriorityInput = document.getElementById('todo-priority');
        const priorityDropdown = document.getElementById('priority-dropdown');
        const modalTitle = document.getElementById('modal-title');
        const todoSaveBtn = document.getElementById('todo-save-btn');
        const todoSaveWrapper = document.getElementById('todo-save-wrapper');
        const todoEditModeBtn = document.getElementById('todo-edit-mode-btn');  // Issue-101
        const todoReadonlyView = document.getElementById('todo-readonly-view');  // Issue-101

        // DOM Elements - Recommendation Panel
        const recommendationPanel = document.getElementById('recommendation-panel');
        const recommendationDateText = document.getElementById('recommendation-date-text');
        const recommendationSummary = document.getElementById('recommendation-summary');
        const warningsSection = document.getElementById('warnings-section');
        const overdueSection = document.getElementById('overdue-section');
        const overdueItems = document.getElementById('overdue-items');
        const overdueCount = document.getElementById('overdue-count');
        const mustDoSection = document.getElementById('must-do-section');
        const mustDoItems = document.getElementById('must-do-items');
        const mustDoCount = document.getElementById('must-do-count');
        const recommendedSection = document.getElementById('recommended-section');
        const recommendedItems = document.getElementById('recommended-items');
        const recommendedCount = document.getElementById('recommended-count');
        const ifTimeSection = document.getElementById('if-time-section');
        const ifTimeItems = document.getElementById('if-time-items');
        const ifTimeCount = document.getElementById('if-time-count');
        const blockedSection = document.getElementById('blocked-section');
        const blockedItems = document.getElementById('blocked-items');
        const blockedCount = document.getElementById('blocked-count');
        const insightsSection = document.getElementById('insights-section');
        const insightsItems = document.getElementById('insights-items');
        const recommendationEmpty = document.getElementById('recommendation-empty');

        // DOM Elements - Autocomplete
        const todoEngagementInput = document.getElementById('todo-engagement');
        const todoEngagementClear = document.getElementById('todo-engagement-clear');
        const engagementDropdown = document.getElementById('engagement-dropdown');
        const inlineEngForm = document.getElementById('inline-eng-form');
        const inlineEngName = document.getElementById('inline-eng-name');
        const inlineEngDescription = document.getElementById('inline-eng-description');
        const inlineEngStartDate = document.getElementById('inline-eng-start-date');
        const inlineEngContact = document.getElementById('inline-eng-contact');
        const inlineEngContactClear = document.getElementById('inline-eng-contact-clear');
        const inlineEngContactDropdown = document.getElementById('inline-eng-contact-dropdown');
        const inlineEngPersonForm = document.getElementById('inline-eng-person-form');
        const inlineEngPersonName = document.getElementById('inline-eng-person-name');
        const inlineEngPersonRole = document.getElementById('inline-eng-person-role');

        // DOM Elements - Horizontal Expansion
        const todoModalContent = document.getElementById('todo-modal-content');
        const todoFormColumns = document.getElementById('todo-form-columns');
        const todoFormLeft = document.getElementById('todo-form-left');
        const todoFormRight = document.getElementById('todo-form-right');
        const columnSeparator = document.getElementById('column-separator');
        const inlineEngAddBtn = document.getElementById('inline-eng-add-btn');
        const inlineEngCancelBtn = document.getElementById('inline-eng-cancel-btn');
        const inlineEngPersonAddBtn = document.getElementById('inline-eng-person-add-btn');

        // DOM Elements - Engagements
        const engagementsPage = document.getElementById('engagements-page');
        const engagementList = document.getElementById('engagement-list');
        const engagementEmptyState = document.getElementById('engagement-empty-state');
        const oppShortcutHintFloating = document.getElementById('opp-shortcut-hint-floating');
        const engagementModal = document.getElementById('engagement-modal');
        const engagementForm = document.getElementById('engagement-form');
        const engNameInput = document.getElementById('eng-name');
        const engDescriptionInput = document.getElementById('eng-description');
        const engStartDateInput = document.getElementById('eng-start-date');
        const engContactInput = document.getElementById('eng-contact');
        const engContactClear = document.getElementById('eng-contact-clear');
        const contactDropdown = document.getElementById('contact-dropdown');
        const inlinePersonForm = document.getElementById('inline-person-form');
        const inlinePersonName = document.getElementById('inline-person-name');
        const inlinePersonRole = document.getElementById('inline-person-role');

        // DOM Elements - Side Panel (Comments Only)
        const sidePanel = document.getElementById('side-panel');
        const sidePanelBackdrop = document.getElementById('side-panel-backdrop');

        // DOM Elements - Promote Modals
        const promotePreProjectModal = document.getElementById('promote-preproject-modal');
        const promotePreProjectName = document.getElementById('promote-preproject-name');
        const preProjectStartedInput = document.getElementById('preproject-started');
        const preProjectExpectedInput = document.getElementById('preproject-expected');
        const promoteProjectModal = document.getElementById('promote-project-modal');
        const promoteProjectName = document.getElementById('promote-project-name');
        const projectFormalizedInput = document.getElementById('project-formalized');
        const projectCodeInput = document.getElementById('project-code');
        const projectFundingInput = document.getElementById('project-funding');
        const projectStartInput = document.getElementById('project-start');
        const projectEndInput = document.getElementById('project-end');
        const projectAllocationInput = document.getElementById('project-allocation');
        const chargeBackOptions = document.getElementById('chargeback-options');

        // DOM Elements - Unified Promotion Modal (Issue-57)
        const unifiedPromoteModal = document.getElementById('unified-promote-modal');
        const unifiedPromoteTitle = document.getElementById('unified-promote-title');
        const preprojectAllocationSection = document.getElementById('preproject-allocation-section');
        const preprojectToggle = document.getElementById('preproject-toggle');
        const preprojectSectionContent = document.getElementById('preproject-section-content');
        const preprojectAllocationInputEl = document.getElementById('preproject-allocation-input');
        const preprojectTimeline = document.getElementById('preproject-timeline');
        const projectAllocationSection = document.getElementById('project-allocation-section');
        const projectToggle = document.getElementById('project-toggle');
        const projectSectionContent = document.getElementById('project-section-content');
        const projectAllocationInputEl = document.getElementById('project-allocation-input');
        const projectTimeline = document.getElementById('project-timeline');
        const unifiedPromoteSaveBtn = document.getElementById('unified-promote-save-btn');

        // DOM Elements - Header and Tabs
        const appHeader = document.getElementById('app-header');
        const tabHome = document.getElementById('tab-home');
        const tabEngagements = document.getElementById('tab-engagements');
        const globalSearchInput = document.getElementById('global-search-input');

        // DOM Elements - Confirmation Modal
        const confirmModal = document.getElementById('confirm-modal');
        const confirmMessage = document.getElementById('confirm-message');

        // DOM Elements - Cancel Modal
        const cancelModal = document.getElementById('cancel-modal');
        const cancelOppName = document.getElementById('cancel-eng-name');
        const cancelReason = document.getElementById('cancel-reason');

        // DOM Elements - Todo Action Modal
        const todoActionModal = document.getElementById('todo-action-modal');
        const todoActionModalTitle = document.getElementById('todo-action-modal-title');
        const todoActionEngName = document.getElementById('todo-action-eng-name');
        const todoActionCount = document.getElementById('todo-action-count');

        // DOM Elements - Comments
        const panelComments = document.getElementById('panel-comments');
        const commentInput = document.getElementById('comment-input');

        // DOM Elements - Archive Toggle
        const showArchivedToggle = document.getElementById('show-archived-toggle');

        // DOM Elements - Settings
        const settingsPage = document.getElementById('settings-page');
        const peopleList = document.getElementById('people-list');
        const peopleEmptyState = document.getElementById('people-empty-state');
        const peopleShortcutHintFloating = document.getElementById('people-shortcut-hint-floating');
        const rolesSection = document.getElementById('roles-section');
        const rolesList = document.getElementById('roles-list');

        // DOM Elements - Tags
        const tagsList = document.getElementById('tags-list');
        const tagsEmptyState = document.getElementById('tags-empty-state');
        const tagsShortcutHintFloating = document.getElementById('tags-shortcut-hint-floating');
        const settingsSectionPeople = document.getElementById('settings-section-people');
        const settingsSectionTags = document.getElementById('settings-section-tags');

        // DOM Elements - Tag Modal
        const tagModal = document.getElementById('tag-modal');
        const tagModalTitle = document.getElementById('tag-modal-title');
        const tagForm = document.getElementById('tag-form');
        const tagNameInput = document.getElementById('tag-name');
        const tagColorInput = document.getElementById('tag-color');
        const tagColorPreview = document.getElementById('tag-color-preview');
        const tagColorValue = document.getElementById('tag-color-value');

        // DOM Elements - Tag Input (Todo form)
        const todoTagInput = document.getElementById('todo-tag-input');
        const todoTagDropdown = document.getElementById('todo-tag-dropdown');
        const todoSelectedTags = document.getElementById('todo-selected-tags');

        // DOM Elements - Tag Input (Engagement form)
        const engTagInput = document.getElementById('opp-tag-input');
        const engTagDropdown = document.getElementById('opp-tag-dropdown');
        const engSelectedTags = document.getElementById('opp-selected-tags');

        // DOM Elements - Person Modal
        const personModal = document.getElementById('person-modal');
        const personModalTitle = document.getElementById('person-modal-title');
        const personForm = document.getElementById('person-form');
        const personNameInput = document.getElementById('person-name');
        const personRoleInput = document.getElementById('person-role');
        const personRoleClear = document.getElementById('person-role-clear');
        const roleDropdown = document.getElementById('role-dropdown');

        // DOM Elements - Delete Person Modal
        const deletePersonModal = document.getElementById('delete-person-modal');
        const deletePersonName = document.getElementById('delete-person-name');

        // Navigation functions
        function navigateTo(page) {
            // Hide all pages
            landingPage.classList.add('hidden');
            landingPage.classList.remove('container');
            homePage.classList.add('hidden');
            engagementsPage.classList.add('hidden');
            settingsPage.classList.add('hidden');
            appHeader.classList.add('hidden');

            // Show requested page
            if (page === 'landing') {
                landingPage.classList.remove('hidden');
                landingPage.classList.add('container');
                document.body.style.display = 'flex';
                document.body.style.alignItems = 'center';
                document.body.style.justifyContent = 'center';
            } else if (page === 'app') {
                // Show app with header and current tab
                appHeader.classList.remove('hidden');
                document.body.style.display = 'block';
                document.body.style.alignItems = '';
                document.body.style.justifyContent = '';
                // Set currentPage before switchTab so render functions pass their guards
                state.currentPage = page;
                switchTab(state.currentTab);
            }

            state.currentPage = page;
        }

        // Tab switching function
        function switchTab(tab) {
            state.currentTab = tab;

            // Clear search when switching tabs (Issue-59)
            state.searchQuery = '';
            globalSearchInput.value = '';

            // Update tab buttons (settings doesn't have a tab button)
            tabHome.classList.toggle('active', tab === 'home');
            tabEngagements.classList.toggle('active', tab === 'engagements');

            // Show/hide pages
            homePage.classList.toggle('hidden', tab !== 'home');
            engagementsPage.classList.toggle('hidden', tab !== 'engagements');
            settingsPage.classList.toggle('hidden', tab !== 'settings');

            // Render content
            if (tab === 'home') {
                renderTodos();
            } else if (tab === 'engagements') {
                renderEngagements();
            } else if (tab === 'settings') {
                renderPeople();
            }
        }

        // Open Settings page
        function openSettings() {
            // Save current tab before navigating to settings
            if (state.currentTab !== 'settings') {
                state.previousTab = state.currentTab;
            }
            switchTab('settings');
        }

        // Close Settings and return to previous page
        function closeSettings() {
            switchTab(state.previousTab);
        }

        // Search functions (Issue-59)
        function handleSearchInput(value) {
            state.searchQuery = value.toLowerCase().trim();
            // Re-render the current list based on tab
            if (state.currentTab === 'home') {
                renderTodos();
            } else if (state.currentTab === 'engagements') {
                renderEngagements();
            }
        }

        function clearSearch() {
            state.searchQuery = '';
            globalSearchInput.value = '';
            globalSearchInput.blur();
            // Re-render the current list
            if (state.currentTab === 'home') {
                renderTodos();
            } else if (state.currentTab === 'engagements') {
                renderEngagements();
            }
        }

        function focusSearch() {
            globalSearchInput.focus();
            globalSearchInput.select();
        }

        function matchesTodo(todo, query) {
            if (!query) return true;

            // Search in title
            if (todo.title && todo.title.toLowerCase().includes(query)) return true;

            // Search in description
            if (todo.description && todo.description.toLowerCase().includes(query)) return true;

            // Search in priority
            const priority = todo.priority || DEFAULT_PRIORITY;
            const priorityConfig = PRIORITY_TAGS[priority];
            if (priorityConfig && priorityConfig.label.toLowerCase().includes(query)) return true;

            // Search in linked engagement name
            if (todo.engagementId) {
                const engagement = state.engagements.find(e => e.id === todo.engagementId);
                if (engagement && engagement.name && engagement.name.toLowerCase().includes(query)) return true;
            }

            // Search in tags
            if (todo.tagIds && todo.tagIds.length > 0) {
                for (const tagId of todo.tagIds) {
                    const tag = state.tags.find(t => t.id === tagId);
                    if (tag && tag.name && tag.name.toLowerCase().includes(query)) return true;
                }
            }

            return false;
        }

        function matchesEngagement(engagement, query) {
            if (!query) return true;

            // Search in name (title)
            if (engagement.name && engagement.name.toLowerCase().includes(query)) return true;

            // Search in description
            if (engagement.description && engagement.description.toLowerCase().includes(query)) return true;

            // Search in status
            if (engagement.status && engagement.status.toLowerCase().includes(query)) return true;

            // Search in contact name
            if (engagement.contact && engagement.contact.toLowerCase().includes(query)) return true;

            // Search in contact person (from people list)
            if (engagement.contactId) {
                const person = state.people.find(p => p.id === engagement.contactId);
                if (person && person.name && person.name.toLowerCase().includes(query)) return true;
            }

            // Search in role
            if (engagement.contactId) {
                const person = state.people.find(p => p.id === engagement.contactId);
                if (person && person.role && person.role.toLowerCase().includes(query)) return true;
            }

            // Search in type (engagement, pre-project, project)
            const displayType = getEngagementDisplayType(engagement);
            const typeName = getTypeDisplayName(displayType);
            if (typeName.toLowerCase().includes(query)) return true;

            // Also match raw type values
            if (engagement.type && engagement.type.toLowerCase().includes(query)) return true;

            return false;
        }

        // Switch settings section
        function switchSettingsSection(section) {
            state.settingsSection = section;

            // Update menu item active state
            const menuItems = document.querySelectorAll('.settings-menu-item');
            menuItems.forEach(item => {
                item.classList.toggle('active', item.dataset.section === section);
            });

            // Toggle section visibility
            const peopleSection = document.getElementById('settings-section-people');
            const tagsSection = document.getElementById('settings-section-tags');
            const planningSection = document.getElementById('settings-section-planning');
            const tasksSection = document.getElementById('settings-section-tasks');
            const calendarSection = document.getElementById('settings-section-calendar');
            const storageSection = document.getElementById('settings-section-storage');

            // Hide all sections
            peopleSection.classList.add('hidden');
            tagsSection.classList.add('hidden');
            planningSection.classList.add('hidden');
            tasksSection.classList.add('hidden');
            calendarSection.classList.add('hidden');
            storageSection.classList.add('hidden');

            if (section === 'people') {
                peopleSection.classList.remove('hidden');
                renderPeople();
            } else if (section === 'tags') {
                tagsSection.classList.remove('hidden');
                renderTags();
            } else if (section === 'planning') {
                planningSection.classList.remove('hidden');
                renderPlanningSettings();
            } else if (section === 'tasks') {
                tasksSection.classList.remove('hidden');
                renderTasksSettings();
            } else if (section === 'calendar') {
                calendarSection.classList.remove('hidden');
                renderCalendarSettings();
            } else if (section === 'storage') {
                storageSection.classList.remove('hidden');
                renderStorageSection();
            }
        }

        function startFromScratch() {
            // Clear data and navigate to app
            state.todos = [];
            state.engagements = [];
            state.people = [];
            state.roles = [];
            state.tags = [];
            state.meetings = [];
            state.settings = { ...DEFAULT_SETTINGS };
            // Reset work calendar to defaults (Mon-Fri 8hrs, no holidays, no PTO)
            state.workCalendar = JSON.parse(JSON.stringify(DEFAULT_WORK_CALENDAR));
            state.currentTab = 'home';
            navigateTo('app');
            // Save initial empty state to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save initial state:', err));
        }

        function continueWorking() {
            // Trigger file input to load previous state (for importing from file)
            document.getElementById('import-file-input').click();
        }

        // Export app state to JSON file
        function exportData() {
            // Collect all data entities from state
            const exportableData = {
                version: '1.0',
                lastModified: new Date().toISOString(),
                settings: state.settings,
                userTags: state.tags,  // Renamed for spec compliance
                todos: state.todos,
                engagements: state.engagements,
                people: state.people,
                roles: state.roles,
                tags: state.tags,  // Keep for backward compatibility
                exportedAt: new Date().toISOString()
            };

            // Create JSON blob
            const jsonString = JSON.stringify(exportableData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });

            // Generate filename with timestamp
            const now = new Date();
            const timestamp = now.toISOString()
                .replace(/T/, '_')
                .replace(/:/g, '-')
                .replace(/\..+/, '');
            const filename = `todoApp_${timestamp}.json`;

            // Create download link and trigger download
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Import app state from JSON file
        function importData(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);

                    // Validate required data structure
                    if (!importedData || typeof importedData !== 'object') {
                        throw new Error('Invalid file format');
                    }

                    // ========================================
                    // Issue #63: Comprehensive input validation
                    // ========================================

                    // Extract and limit array sizes to prevent DoS
                    const rawTodos = Array.isArray(importedData.todos)
                        ? importedData.todos.slice(0, IMPORT_LIMITS.MAX_ARRAY_SIZE) : [];
                    const rawEngagements = Array.isArray(importedData.engagements)
                        ? importedData.engagements.slice(0, IMPORT_LIMITS.MAX_ARRAY_SIZE) : [];
                    const rawPeople = Array.isArray(importedData.people)
                        ? importedData.people.slice(0, IMPORT_LIMITS.MAX_ARRAY_SIZE) : [];
                    const rawRoles = Array.isArray(importedData.roles)
                        ? importedData.roles.slice(0, IMPORT_LIMITS.MAX_ARRAY_SIZE) : [];
                    // Support both old 'tags' and new 'userTags' format
                    const rawTags = Array.isArray(importedData.userTags)
                        ? importedData.userTags.slice(0, IMPORT_LIMITS.MAX_ARRAY_SIZE)
                        : Array.isArray(importedData.tags)
                            ? importedData.tags.slice(0, IMPORT_LIMITS.MAX_ARRAY_SIZE) : [];

                    // Sanitize and validate all entities, filtering out invalid ones
                    state.roles = rawRoles.map(sanitizeRole).filter(r => r !== null);
                    state.people = rawPeople.map(sanitizePerson).filter(p => p !== null);
                    state.tags = rawTags.map(sanitizeTag).filter(t => t !== null);
                    state.engagements = rawEngagements.map(sanitizeEngagement).filter(e => e !== null);
                    state.todos = rawTodos.map(sanitizeTodo).filter(t => t !== null);

                    // Restore planning settings (merge with defaults, validate numeric values)
                    if (importedData.settings && typeof importedData.settings === 'object') {
                        const s = importedData.settings;
                        state.settings = {
                            workdayMinutes: typeof s.workdayMinutes === 'number' && s.workdayMinutes > 0 && s.workdayMinutes <= 1440
                                ? s.workdayMinutes : DEFAULT_SETTINGS.workdayMinutes,
                            bufferPercentage: typeof s.bufferPercentage === 'number' && s.bufferPercentage >= 0 && s.bufferPercentage <= 100
                                ? s.bufferPercentage : DEFAULT_SETTINGS.bufferPercentage,
                            maxOverdueToShow: typeof s.maxOverdueToShow === 'number' && s.maxOverdueToShow >= 0 && s.maxOverdueToShow <= 100
                                ? s.maxOverdueToShow : DEFAULT_SETTINGS.maxOverdueToShow,
                            planningHorizonDays: typeof s.planningHorizonDays === 'number' && s.planningHorizonDays >= 1 && s.planningHorizonDays <= 365
                                ? s.planningHorizonDays : DEFAULT_SETTINGS.planningHorizonDays,
                            completedVisibilityDays: typeof s.completedVisibilityDays === 'number' && s.completedVisibilityDays >= 1 && s.completedVisibilityDays <= 365
                                ? s.completedVisibilityDays : DEFAULT_SETTINGS.completedVisibilityDays
                        };
                    } else {
                        state.settings = { ...DEFAULT_SETTINGS };
                    }

                    // Log import summary for debugging
                    Logger.log(`Import completed: ${state.todos.length} todos, ${state.engagements.length} engagements, ${state.people.length} people, ${state.tags.length} tags, ${state.roles.length} roles`);

                    // Navigate to app and render
                    navigateTo('app');
                    renderTodos();
                    renderEngagements();
                    renderPeople();
                    renderTags();
                    loadPlanningSettings();

                    // Save imported data to IndexedDB
                    saveStateToIndexedDB().catch(err => Logger.error('Failed to save imported state:', err));

                } catch (error) {
                    alert('Error importing file: ' + error.message + '\n\nPlease ensure you selected a valid TodoApp export file.');
                }

                // Reset file input for future imports
                event.target.value = '';
            };

            reader.onerror = function() {
                alert('Error reading file. Please try again.');
                event.target.value = '';
            };

            reader.readAsText(file);
        }

        // Data persistence - saves to IndexedDB
        function saveData() {
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Modal functions
        // Issue-101: Updated to support read-only mode
        function openModal(todoIndex = null, readOnly = false) {
            todoModal.classList.remove('hidden');
            state.modalOpen = true;
            state.editingTodoIndex = todoIndex;
            state.modalReadOnly = readOnly;

            // Issue-101: Handle read-only vs edit mode display
            if (readOnly && todoIndex !== null) {
                // Read-only mode - show read-only view, hide form
                todoForm.classList.add('hidden');
                todoReadonlyView.classList.remove('hidden');
                todoEditModeBtn.classList.remove('hidden');
                modalTitle.textContent = 'View Todo';
                renderTodoReadonlyView(state.todos[todoIndex]);
                return;
            }

            // Edit/Create mode - show form, hide read-only view
            todoForm.classList.remove('hidden');
            todoReadonlyView.classList.add('hidden');
            todoEditModeBtn.classList.add('hidden');

            // Reset form
            todoForm.reset();

            // Reset autocomplete state
            state.selectedEngagementId = null;
            state.pendingEngagement = null;
            state.autocompleteOpen = false;
            state.autocompleteHighlightIndex = -1;
            state.inlineEngFormOpen = false;
            // Reset inline opp person state
            state.inlineEngContactAutocompleteOpen = false;
            state.inlineEngContactAutocompleteHighlightIndex = -1;
            state.inlineEngPersonFormOpen = false;
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;
            todoEngagementInput.value = '';
            todoEngagementClear.classList.remove('visible');
            engagementDropdown.classList.remove('open');
            // Reset inline opp contact fields
            inlineEngContact.value = '';
            inlineEngContactClear.classList.remove('visible');
            inlineEngContactDropdown.classList.remove('open');
            inlineEngPersonForm.classList.remove('open');

            // Reset horizontal expansion state
            todoModalContent.classList.remove('expanded');
            todoFormColumns.classList.remove('expanded');
            todoFormLeft.classList.remove('disabled');
            todoFormRight.classList.remove('animate-in');

            // Reset engagement panel button states
            if (inlineEngAddBtn) inlineEngAddBtn.disabled = false;
            if (inlineEngCancelBtn) inlineEngCancelBtn.disabled = false;

            // Ensure right panel is not tabbable, left panel is tabbable
            setFormTabIndex(todoFormLeft, true);
            setFormTabIndex(todoFormRight, false);

            // Reset tag input state
            state.selectedTodoTagIds = [];
            state.todoTagDropdownOpen = false;
            state.todoTagHighlightIndex = -1;
            todoTagInput.value = '';
            closeTodoTagDropdown();

            // Reset priority state
            state.selectedPriority = DEFAULT_PRIORITY;
            state.priorityDropdownOpen = false;
            state.priorityHighlightIndex = -1;
            closePriorityDropdown();

            // Reset Save button state
            updateTodoSaveButtonState();

            if (todoIndex !== null) {
                // Edit mode - populate with existing todo data
                const todo = state.todos[todoIndex];
                modalTitle.textContent = 'Edit Todo';
                todoTitleInput.value = todo.title || '';
                todoDescriptionInput.value = todo.description || '';

                // Handle deadline (support both new deadline and old dueDate)
                // Use setDeadlineValue to properly update DateTimePicker display (Issue-85)
                if (todo.deadline) {
                    setDeadlineValue(new Date(todo.deadline));
                } else if (todo.dueDate) {
                    // Convert old dueDate to deadline with default time
                    const oldDate = new Date(todo.dueDate);
                    oldDate.setHours(17, 0, 0, 0);
                    setDeadlineValue(oldDate);
                } else {
                    setDeadlineValue(getDefaultDeadlineDate());
                }

                // Set effort
                todoEffortSelect.value = todo.effort || DEFAULT_EFFORT;

                // Set priority
                state.selectedPriority = todo.priority || DEFAULT_PRIORITY;
                todoPriorityInput.value = PRIORITY_TAGS[state.selectedPriority].label;

                // Pre-populate linked engagement
                if (todo.engagementId) {
                    const opp = state.engagements.find(o => o.id === todo.engagementId);
                    if (opp) {
                        state.selectedEngagementId = opp.id;
                        todoEngagementInput.value = opp.name;
                        todoEngagementClear.classList.add('visible');
                    }
                }

                // Pre-populate tags
                if (todo.tagIds && Array.isArray(todo.tagIds)) {
                    state.selectedTodoTagIds = [...todo.tagIds];
                }
            } else {
                // Create mode
                modalTitle.textContent = 'New Todo';
                // Set default deadline to 5 PM today (Issue-85)
                setDeadlineValue(getDefaultDeadlineDate());
                // Set default effort
                todoEffortSelect.value = DEFAULT_EFFORT;
                // Set default priority
                state.selectedPriority = DEFAULT_PRIORITY;
                todoPriorityInput.value = PRIORITY_TAGS[DEFAULT_PRIORITY].label;
            }

            // Render selected tags
            renderTodoSelectedTags();

            // Focus on title input
            setTimeout(() => todoTitleInput.focus(), 100);
        }

        // Issue-101: Render read-only view of a todo
        function renderTodoReadonlyView(todo) {
            // Format deadline
            const deadlineValue = todo.deadline || todo.dueDate;
            const deadlineDisplay = deadlineValue ? formatDeadlineDisplay(deadlineValue) : '';

            // Format effort
            const effort = todo.effort || DEFAULT_EFFORT;
            const effortConfig = EFFORT_CONFIG[effort];
            const effortDisplay = effortConfig ? `${effortConfig.icon} ${formatEffortDisplay(effort)}` : '';

            // Format priority
            const priority = todo.priority || DEFAULT_PRIORITY;
            const priorityTag = PRIORITY_TAGS[priority];
            const priorityDisplay = priorityTag ? priorityTag.label : 'Normal';

            // Format engagement
            let engagementHtml = '<span class="todo-readonly-value empty">None</span>';
            if (todo.engagementId) {
                const opp = state.engagements.find(o => o.id === todo.engagementId);
                if (opp) {
                    engagementHtml = `
                        <span class="todo-readonly-engagement" onclick="navigateToEngagement('${opp.id}')">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"></circle>
                                <polyline points="12 6 12 12 16 14"></polyline>
                            </svg>
                            ${escapeHtml(opp.name)}
                        </span>
                    `;
                }
            }

            // Format tags
            let tagsHtml = '<span class="todo-readonly-value empty">None</span>';
            if (todo.tagIds && todo.tagIds.length > 0) {
                const tagPills = todo.tagIds.map(tagId => {
                    const tag = getTagById(tagId);
                    if (tag) {
                        return `<span class="tag-pill" style="background-color: ${tag.color}; color: #fff;">${escapeHtml(tag.name)}</span>`;
                    }
                    return '';
                }).filter(Boolean);
                if (tagPills.length > 0) {
                    tagsHtml = `<div class="todo-readonly-tags">${tagPills.join('')}</div>`;
                }
            }

            // Build status display
            let statusHtml = '';
            if (todo.blocked) {
                statusHtml = `<span class="priority-pill" style="background: #9E9E9E; color: #fff;">Blocked</span>`;
                if (todo.blockReason) {
                    statusHtml += `<span class="todo-readonly-value" style="margin-left: 8px; font-style: italic;">"${escapeHtml(todo.blockReason)}"</span>`;
                }
            } else if (todo.completed) {
                statusHtml = `<span class="priority-pill" style="background: #4CAF50; color: #fff;">Completed</span>`;
            } else if (todo.dropped) {
                statusHtml = `<span class="priority-pill" style="background: #DC3545; color: #fff;">Dropped</span>`;
            } else {
                statusHtml = `<span class="priority-pill" style="background: #2196F3; color: #fff;">Active</span>`;
            }

            todoReadonlyView.innerHTML = `
                <div class="todo-readonly-field">
                    <div class="todo-readonly-label">Title</div>
                    <div class="todo-readonly-value title">${escapeHtml(todo.title)}</div>
                </div>

                <div class="todo-readonly-field">
                    <div class="todo-readonly-label">Status</div>
                    <div class="todo-readonly-value">${statusHtml}</div>
                </div>

                <div class="todo-readonly-field">
                    <div class="todo-readonly-label">Description</div>
                    <div class="todo-readonly-value ${todo.description ? 'description' : 'empty'}">
                        ${todo.description ? escapeHtml(todo.description) : 'No description'}
                    </div>
                </div>

                <div class="todo-readonly-field">
                    <div class="todo-readonly-label">Deadline</div>
                    <div class="todo-readonly-value ${deadlineDisplay ? '' : 'empty'}">
                        ${deadlineDisplay || 'Not set'}
                    </div>
                </div>

                <div class="todo-readonly-field">
                    <div class="todo-readonly-label">Effort</div>
                    <div class="todo-readonly-value">${effortDisplay}</div>
                </div>

                <div class="todo-readonly-field">
                    <div class="todo-readonly-label">Priority</div>
                    <div class="todo-readonly-value">
                        <span class="priority-pill priority-${priority}">${priorityDisplay}</span>
                    </div>
                </div>

                <div class="todo-readonly-field">
                    <div class="todo-readonly-label">Linked Engagement</div>
                    <div class="todo-readonly-value">${engagementHtml}</div>
                </div>

                <div class="todo-readonly-field">
                    <div class="todo-readonly-label">Tags</div>
                    <div class="todo-readonly-value">${tagsHtml}</div>
                </div>

                <button type="button" class="btn btn-secondary todo-readonly-close-btn" onclick="closeModal()">Close</button>
            `;
        }

        // Issue-101: Switch from read-only to edit mode
        function switchToEditMode() {
            if (state.editingTodoIndex !== null) {
                state.modalReadOnly = false;
                openModal(state.editingTodoIndex, false);
            }
        }

        // Issue-101: Navigate to engagement from read-only view
        function navigateToEngagement(engagementId) {
            closeModal();
            // Navigate to engagements tab and select the engagement
            state.currentTab = 'engagements';
            renderPage();
            // Find and expand the engagement
            const engIndex = state.engagements.findIndex(e => e.id === engagementId);
            if (engIndex !== -1) {
                state.expandedEngagementId = engagementId;
                renderEngagements();
            }
        }

        // Issue-101: Open todo in read-only mode (for clicking on todo cards)
        function viewTodo(index) {
            openModal(index, true);
        }

        // Edit a todo - opens modal in edit mode
        function editTodo(index) {
            openModal(index, false);
        }

        // Get today's date in YYYY-MM-DD format for date input
        function getTodayDate() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function closeModal() {
            todoModal.classList.add('hidden');
            state.modalOpen = false;
            state.editingTodoIndex = null;
            state.selectedEngagementId = null;
            state.pendingEngagement = null;
            state.autocompleteOpen = false;
            state.inlineEngFormOpen = false;
            state.inlineEngPersonFormOpen = false;
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;
            todoForm.reset();
            engagementDropdown.classList.remove('open');

            // Reset horizontal expansion state
            todoModalContent.classList.remove('expanded');
            todoFormColumns.classList.remove('expanded');
            todoFormLeft.classList.remove('disabled');
            todoFormRight.classList.remove('animate-in');
            inlineEngPersonForm.classList.remove('open');

            // Reset button states
            if (inlineEngAddBtn) inlineEngAddBtn.disabled = false;
            if (inlineEngCancelBtn) inlineEngCancelBtn.disabled = false;

            // Reset tab navigation
            setFormTabIndex(todoFormLeft, true);
            setFormTabIndex(todoFormRight, false);
        }

        // Issue-101: Handle backdrop click - close modal only in read-only mode
        function handleTodoModalBackdropClick() {
            if (state.modalReadOnly) {
                closeModal();
            }
            // In edit mode, clicking backdrop does nothing (user must use Save/Cancel)
        }

        // Generate unique ID using cryptographically secure random values (Issue-62)
        function generateId() {
            const array = new Uint32Array(4);
            crypto.getRandomValues(array);
            return Array.from(array, x => x.toString(36)).join('');
        }

        // Save todo (handles both create and update)
        function saveTodo(event) {
            event.preventDefault();

            const title = todoTitleInput.value.trim();
            const description = todoDescriptionInput.value.trim();
            const deadline = todoDeadlineInput.value;
            const effort = todoEffortSelect.value;
            const priority = state.selectedPriority;

            if (!title) return;
            if (!deadline) return;

            // Handle pending engagement creation
            let engagementId = state.selectedEngagementId;
            if (state.pendingEngagement) {
                // First, handle person creation if needed
                let contactPersonId = state.pendingEngagement.contactPersonId;

                // Check for pending person from inline eng form (may be set after engagement was confirmed)
                const pendingPersonData = state.pendingEngagement.pendingPerson || state.pendingInlineOppPerson;

                if (pendingPersonData) {
                    // Create the new person (use the combined pending person data)
                    const pendingPerson = pendingPersonData;

                    // Handle role creation if needed
                    let roleId = null;
                    if (pendingPerson.role) {
                        // Check if role exists
                        const existingRole = state.roles.find(r => r.name.toLowerCase() === pendingPerson.role.toLowerCase());
                        if (existingRole) {
                            roleId = existingRole.id;
                        } else {
                            // Create new role
                            const newRole = {
                                id: generateId(),
                                name: pendingPerson.role,
                                createdAt: new Date().toISOString()
                            };
                            state.roles.push(newRole);
                            roleId = newRole.id;
                        }
                    }

                    // Create the person
                    const newPerson = {
                        id: generateId(),
                        name: pendingPerson.name,
                        roleId: roleId,
                        createdAt: new Date().toISOString()
                    };
                    state.people.push(newPerson);
                    contactPersonId = newPerson.id;
                }

                // Create the new engagement
                const newOpp = {
                    id: generateId(),
                    name: state.pendingEngagement.name,
                    description: state.pendingEngagement.description || null,
                    startDate: state.pendingEngagement.startDate || getTodayDate(),
                    contactId: contactPersonId || null,
                    status: 'requested',
                    comments: [],
                    archived: false,
                    createdAt: new Date().toISOString()
                };
                state.engagements.push(newOpp);
                engagementId = newOpp.id;
            }

            if (state.editingTodoIndex !== null) {
                // Update existing todo
                const todo = state.todos[state.editingTodoIndex];
                todo.title = title;
                todo.description = description || null;
                todo.deadline = new Date(deadline).toISOString();
                todo.effort = effort;
                todo.priority = priority;
                todo.engagementId = engagementId;
                todo.tagIds = [...state.selectedTodoTagIds];
                todo.updatedAt = new Date().toISOString();
                // Preserve id, completed, completedAt, and createdAt
            } else {
                // Create new todo
                const now = new Date().toISOString();
                const newTodo = {
                    id: generateId(),
                    title: title,
                    description: description || null,
                    deadline: new Date(deadline).toISOString(),
                    effort: effort,
                    priority: priority,
                    engagementId: engagementId,
                    tagIds: [...state.selectedTodoTagIds],
                    completed: false,
                    completedAt: null,
                    dropped: false,
                    droppedAt: null,
                    createdAt: now,
                    updatedAt: now
                };
                state.todos.push(newTodo);
            }

            // Auto-update engagement status to Open if todo is linked and not completed
            if (engagementId) {
                updateEngagementAutoStatus(engagementId);
            }

            closeModal();
            renderTodos();
            // Also re-render engagements if on that tab
            if (state.currentTab === 'engagements') {
                renderEngagements();
            }
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Auto-update engagement status based on linked todos
        // Status Flow: Active ↔ Paused (based on undone todos)
        function updateEngagementAutoStatus(engagementId) {
            const opp = state.engagements.find(o => o.id === engagementId);
            if (!opp) return;

            // Don't change completed engagements (final state)
            if (opp.status === 'completed') return;

            // Get all todos linked to this engagement (excluding dropped)
            const linkedTodos = state.todos.filter(t => t.engagementId === engagementId && !t.dropped);

            // Check if any linked todo is not completed
            const hasUndoneTodo = linkedTodos.some(t => !t.completed);

            if (hasUndoneTodo) {
                // Has non-completed todos → Active
                // This also reactivates closed/dropped engagements when a todo is linked
                if (opp.status !== 'active') {
                    opp.status = 'active';
                }
            } else {
                // No undone todos (either all complete or none linked)
                // Only pause active engagements, don't change closed/dropped
                if (opp.status === 'active') {
                    opp.status = 'paused';
                }
            }
        }

        // Update all engagements' pause/resume status based on linked todos
        function updateAllEngagementStatuses() {
            state.engagements.forEach(eng => {
                // Only update active or paused engagements
                if (['completed', 'closed', 'dropped'].includes(eng.status)) return;

                const linkedTodos = state.todos.filter(t => t.engagementId === eng.id && !t.dropped);
                const hasUndoneTodo = linkedTodos.some(t => !t.completed);

                if (hasUndoneTodo) {
                    eng.status = 'active';
                } else {
                    eng.status = 'paused';
                }
            });
        }

        // Render functions
        function renderTodos() {
            if (state.currentPage !== 'app' || state.currentTab !== 'home') return;

            // Clear current list
            todoList.innerHTML = '';

            // Also render recommendation panel
            renderRecommendationPanel();

            // Render Daily Load KPI chart (Issue-74)
            renderDailyLoadChart();

            // Render Meetings list (Issue-80)
            renderMeetingsList();

            // Apply search filter (Issue-59)
            const filteredTodos = state.searchQuery
                ? state.todos.filter(todo => matchesTodo(todo, state.searchQuery))
                : state.todos;

            // Issue-97: Calculate visibility threshold
            const visibilityDays = state.settings.completedVisibilityDays || DEFAULT_SETTINGS.completedVisibilityDays;
            const visibilityThreshold = new Date();
            visibilityThreshold.setDate(visibilityThreshold.getDate() - visibilityDays);
            visibilityThreshold.setHours(0, 0, 0, 0);

            // Issue-97: Helper to check if a todo is within visibility threshold
            function isWithinVisibilityThreshold(todo) {
                const timestamp = todo.completedAt || todo.droppedAt;
                if (!timestamp) return false;
                return new Date(timestamp) >= visibilityThreshold;
            }

            // Issue-99: Helper to get days from today for a deadline
            function getDaysFromToday(deadline) {
                if (!deadline) return Infinity;
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const deadlineDate = new Date(deadline);
                deadlineDate.setHours(0, 0, 0, 0);
                const diffTime = deadlineDate.getTime() - today.getTime();
                return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            }

            // Issue-99: Helper to get the number of days in the current month
            function getDaysInCurrentMonth() {
                const today = new Date();
                // Get next month's first day, then subtract 1 day to get last day of current month
                return new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
            }

            // Issue-99: Categorize active todo by deadline range
            function getDeadlineCategory(todo) {
                const deadline = todo.deadline || todo.dueDate;
                const daysFromToday = getDaysFromToday(deadline);
                const daysInMonth = getDaysInCurrentMonth();

                if (daysFromToday <= 7) {
                    return 'immediate'; // 1-7 days - main active list
                } else if (daysFromToday <= 14) {
                    return 'upcomingWeek'; // 8-14 days
                } else if (daysFromToday <= daysInMonth) {
                    return 'upcomingTwoWeeks'; // 15 days to end of month
                } else {
                    return 'horizon'; // Beyond 1 month
                }
            }

            // Issue-99: Separate todos into categories
            const immediateTodos = [];      // 1-7 days (main active list)
            const upcomingWeekTodos = [];   // 8-14 days
            const upcomingTwoWeeksTodos = []; // 15 days to end of month
            const horizonTodos = [];        // Over 1 month
            const recentlyCompleted = [];
            const recentlyDropped = [];

            filteredTodos.forEach(todo => {
                const originalIndex = state.todos.indexOf(todo);
                if (!todo.completed && !todo.dropped) {
                    // Categorize active todos by deadline
                    const category = getDeadlineCategory(todo);
                    const todoEntry = { todo, originalIndex };
                    if (category === 'immediate') {
                        immediateTodos.push(todoEntry);
                    } else if (category === 'upcomingWeek') {
                        upcomingWeekTodos.push(todoEntry);
                    } else if (category === 'upcomingTwoWeeks') {
                        upcomingTwoWeeksTodos.push(todoEntry);
                    } else {
                        horizonTodos.push(todoEntry);
                    }
                } else if (todo.completed && !todo.dropped && isWithinVisibilityThreshold(todo)) {
                    // Recently completed (within threshold)
                    recentlyCompleted.push({ todo, originalIndex });
                } else if (todo.dropped && isWithinVisibilityThreshold(todo)) {
                    // Recently dropped (within threshold)
                    recentlyDropped.push({ todo, originalIndex });
                }
                // Todos older than threshold are not rendered but remain in state
            });

            // Issue-99: Sort helper for todos by deadline (earliest first)
            function sortByDeadline(a, b) {
                const aDeadline = a.todo.deadline || a.todo.dueDate;
                const bDeadline = b.todo.deadline || b.todo.dueDate;
                const aDate = aDeadline ? new Date(aDeadline).getTime() : Infinity;
                const bDate = bDeadline ? new Date(bDeadline).getTime() : Infinity;
                return aDate - bDate;
            }

            // Sort all todo categories by deadline
            immediateTodos.sort(sortByDeadline);
            upcomingWeekTodos.sort(sortByDeadline);
            upcomingTwoWeeksTodos.sort(sortByDeadline);
            horizonTodos.sort(sortByDeadline);

            // Sort recently completed by completedAt (most recent first)
            recentlyCompleted.sort((a, b) => {
                const aTime = a.todo.completedAt ? new Date(a.todo.completedAt).getTime() : 0;
                const bTime = b.todo.completedAt ? new Date(b.todo.completedAt).getTime() : 0;
                return bTime - aTime;
            });

            // Sort recently dropped by droppedAt (most recent first)
            recentlyDropped.sort((a, b) => {
                const aTime = a.todo.droppedAt ? new Date(a.todo.droppedAt).getTime() : 0;
                const bTime = b.todo.droppedAt ? new Date(b.todo.droppedAt).getTime() : 0;
                return bTime - aTime;
            });

            // Check if there's anything to display
            const hasImmediateTodos = immediateTodos.length > 0;
            const hasUpcomingWeekTodos = upcomingWeekTodos.length > 0;
            const hasUpcomingTwoWeeksTodos = upcomingTwoWeeksTodos.length > 0;
            const hasHorizonTodos = horizonTodos.length > 0;
            const hasRecentlyCompleted = recentlyCompleted.length > 0;
            const hasRecentlyDropped = recentlyDropped.length > 0;
            const hasAnyVisibleTodos = hasImmediateTodos || hasUpcomingWeekTodos || hasUpcomingTwoWeeksTodos || hasHorizonTodos || hasRecentlyCompleted || hasRecentlyDropped;

            if (!hasAnyVisibleTodos) {
                // Show empty state
                todoList.classList.add('hidden');
                emptyState.classList.remove('hidden');
                todoShortcutHintFloating.classList.add('hidden');
            } else {
                // Show todo list
                todoList.classList.remove('hidden');
                emptyState.classList.add('hidden');
                todoShortcutHintFloating.classList.remove('hidden');

                // Render immediate todos (1-7 days) - main active list
                immediateTodos.forEach(({ todo, originalIndex: index }) => {
                    todoList.appendChild(createTodoItemElement(todo, index));
                });

                // Issue-99: Render "Upcoming in a Week" section (8-14 days, collapsed by default)
                if (hasUpcomingWeekTodos) {
                    const upcomingWeekSection = document.createElement('div');
                    upcomingWeekSection.className = 'todo-collapsible-section upcoming-week-section';
                    upcomingWeekSection.id = 'upcoming-week-section';

                    if (state.upcomingWeekExpanded) {
                        upcomingWeekSection.classList.add('expanded');
                    }

                    upcomingWeekSection.innerHTML = `
                        <div class="todo-collapsible-header" onclick="toggleUpcomingWeekSection()">
                            <svg class="todo-collapsible-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="9 18 15 12 9 6"></polyline>
                            </svg>
                            <span class="todo-collapsible-title">Upcoming in a Week</span>
                            <span class="todo-collapsible-count">${upcomingWeekTodos.length}</span>
                        </div>
                        <div class="todo-collapsible-content"></div>
                    `;

                    const upcomingWeekContent = upcomingWeekSection.querySelector('.todo-collapsible-content');
                    upcomingWeekTodos.forEach(({ todo, originalIndex: index }) => {
                        upcomingWeekContent.appendChild(createTodoItemElement(todo, index));
                    });

                    todoList.appendChild(upcomingWeekSection);
                }

                // Issue-99: Render "Upcoming in 2 Weeks" section (15 days to end of month, collapsed by default)
                if (hasUpcomingTwoWeeksTodos) {
                    const upcomingTwoWeeksSection = document.createElement('div');
                    upcomingTwoWeeksSection.className = 'todo-collapsible-section upcoming-two-weeks-section';
                    upcomingTwoWeeksSection.id = 'upcoming-two-weeks-section';

                    if (state.upcomingTwoWeeksExpanded) {
                        upcomingTwoWeeksSection.classList.add('expanded');
                    }

                    upcomingTwoWeeksSection.innerHTML = `
                        <div class="todo-collapsible-header" onclick="toggleUpcomingTwoWeeksSection()">
                            <svg class="todo-collapsible-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="9 18 15 12 9 6"></polyline>
                            </svg>
                            <span class="todo-collapsible-title">Upcoming in 2 Weeks</span>
                            <span class="todo-collapsible-count">${upcomingTwoWeeksTodos.length}</span>
                        </div>
                        <div class="todo-collapsible-content"></div>
                    `;

                    const upcomingTwoWeeksContent = upcomingTwoWeeksSection.querySelector('.todo-collapsible-content');
                    upcomingTwoWeeksTodos.forEach(({ todo, originalIndex: index }) => {
                        upcomingTwoWeeksContent.appendChild(createTodoItemElement(todo, index));
                    });

                    todoList.appendChild(upcomingTwoWeeksSection);
                }

                // Issue-99: Render "In the Horizon" section (over 1 month, collapsed by default)
                if (hasHorizonTodos) {
                    const horizonSection = document.createElement('div');
                    horizonSection.className = 'todo-collapsible-section horizon-section';
                    horizonSection.id = 'horizon-section';

                    if (state.horizonExpanded) {
                        horizonSection.classList.add('expanded');
                    }

                    horizonSection.innerHTML = `
                        <div class="todo-collapsible-header" onclick="toggleHorizonSection()">
                            <svg class="todo-collapsible-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="9 18 15 12 9 6"></polyline>
                            </svg>
                            <span class="todo-collapsible-title">In the Horizon (Over 1 Month)</span>
                            <span class="todo-collapsible-count">${horizonTodos.length}</span>
                        </div>
                        <div class="todo-collapsible-content"></div>
                    `;

                    const horizonContent = horizonSection.querySelector('.todo-collapsible-content');
                    horizonTodos.forEach(({ todo, originalIndex: index }) => {
                        horizonContent.appendChild(createTodoItemElement(todo, index));
                    });

                    todoList.appendChild(horizonSection);
                }

                // Issue-97: Render Recently Completed section (collapsed by default)
                if (hasRecentlyCompleted) {
                    const completedSection = document.createElement('div');
                    completedSection.className = 'todo-collapsible-section completed-section';
                    completedSection.id = 'recently-completed-section';

                    // Check if it was previously expanded
                    if (state.recentlyCompletedExpanded) {
                        completedSection.classList.add('expanded');
                    }

                    completedSection.innerHTML = `
                        <div class="todo-collapsible-header" onclick="toggleRecentlyCompletedSection()">
                            <svg class="todo-collapsible-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="9 18 15 12 9 6"></polyline>
                            </svg>
                            <span class="todo-collapsible-title">Recently Completed</span>
                            <span class="todo-collapsible-count">${recentlyCompleted.length}</span>
                        </div>
                        <div class="todo-collapsible-content"></div>
                    `;

                    const completedContent = completedSection.querySelector('.todo-collapsible-content');
                    recentlyCompleted.forEach(({ todo, originalIndex: index }) => {
                        completedContent.appendChild(createTodoItemElement(todo, index));
                    });

                    todoList.appendChild(completedSection);
                }

                // Issue-97: Render Recently Dropped section (collapsed by default)
                if (hasRecentlyDropped) {
                    const droppedSection = document.createElement('div');
                    droppedSection.className = 'todo-collapsible-section dropped-section';
                    droppedSection.id = 'recently-dropped-section';

                    // Check if it was previously expanded
                    if (state.recentlyDroppedExpanded) {
                        droppedSection.classList.add('expanded');
                    }

                    droppedSection.innerHTML = `
                        <div class="todo-collapsible-header" onclick="toggleRecentlyDroppedSection()">
                            <svg class="todo-collapsible-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="9 18 15 12 9 6"></polyline>
                            </svg>
                            <span class="todo-collapsible-title">Recently Dropped</span>
                            <span class="todo-collapsible-count">${recentlyDropped.length}</span>
                        </div>
                        <div class="todo-collapsible-content"></div>
                    `;

                    const droppedContent = droppedSection.querySelector('.todo-collapsible-content');
                    recentlyDropped.forEach(({ todo, originalIndex: index }) => {
                        droppedContent.appendChild(createTodoItemElement(todo, index));
                    });

                    todoList.appendChild(droppedSection);
                }
            }
        }

        // Issue-97: Helper function to create a todo item element
        function createTodoItemElement(todo, index) {
            const todoItem = document.createElement('div');
            const stateClass = todo.blocked ? 'blocked' : (todo.dropped ? 'dropped' : (todo.completed ? 'completed' : ''));
            todoItem.className = `todo-item ${stateClass}`;
            todoItem.dataset.todoId = todo.id; // For Daily Load chart highlighting (Issue-74)

            // Format deadline (supports both old dueDate and new deadline)
            let dueDateHtml = '';
            const deadlineValue = todo.deadline || todo.dueDate;
            if (deadlineValue) {
                const dueDate = new Date(deadlineValue);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const isOverdue = dueDate < today && !todo.completed && !todo.dropped && !todo.blocked;
                dueDateHtml = `<div class="todo-due-date ${isOverdue ? 'overdue' : ''}">📅 ${formatDeadlineDisplay(deadlineValue)}</div>`;
            }

            // Format effort
            let effortHtml = '';
            const effort = todo.effort || DEFAULT_EFFORT;
            const effortConfig = EFFORT_CONFIG[effort];
            if (effortConfig) {
                effortHtml = `<span class="todo-effort"><span class="todo-effort-icon">${effortConfig.icon}</span> ${formatEffortDisplay(effort)}</span>`;
            }

            // Format priority
            let priorityHtml = '';
            const priority = todo.priority || DEFAULT_PRIORITY;
            if (priority && priority !== 'normal') {
                const priorityTag = PRIORITY_TAGS[priority];
                if (priorityTag) {
                    priorityHtml = `<span class="priority-pill priority-${priority}">${priorityTag.label}</span>`;
                }
            }

            // Format linked engagement
            let engagementHtml = '';
            if (todo.engagementId) {
                const opp = state.engagements.find(o => o.id === todo.engagementId);
                if (opp) {
                    engagementHtml = `
                        <div class="todo-engagement">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"></circle>
                                <polyline points="12 6 12 12 16 14"></polyline>
                            </svg>
                            ${escapeHtml(opp.name)}
                        </div>
                    `;
                }
            }

            // Format tags (combine priority pill with user tags)
            let tagsHtml = '';
            const tagPills = [];

            // Add priority pill first (if not normal)
            if (priorityHtml) {
                tagPills.push(priorityHtml);
            }

            // Add effort badge
            if (effortHtml) {
                tagPills.push(effortHtml);
            }

            // Add user tags
            if (todo.tagIds && todo.tagIds.length > 0) {
                todo.tagIds.forEach(tagId => {
                    const tag = getTagById(tagId);
                    if (tag) {
                        tagPills.push(`<span class="tag-pill" style="background-color: ${tag.color}; color: #fff;">${escapeHtml(tag.name)}</span>`);
                    }
                });
            }

            if (tagPills.length > 0) {
                tagsHtml = `<div class="tags-container">${tagPills.join('')}</div>`;
            }

            // Format description for two-column layout
            let descriptionHtml = '';
            if (todo.description && todo.description.trim()) {
                descriptionHtml = `<div class="todo-description">${escapeHtml(todo.description)}</div>`;
            }

            // Checkbox class and click handler (dropped and blocked todos can't be toggled)
            const checkboxClass = todo.blocked ? 'blocked' : (todo.dropped ? 'dropped' : (todo.completed ? 'checked' : ''));
            const checkboxClick = (todo.dropped || todo.blocked) ? '' : `onclick="toggleTodo(${index})"`;

            // Issue-101: Build action buttons based on state
            // Removed edit button - clicking todo content opens read-only modal instead
            let actionsHtml = '';
            if (todo.blocked) {
                // Blocked: only show Unblock button
                actionsHtml = `
                    <button class="todo-unblock-btn" onclick="event.stopPropagation(); unblockTodo(${index})" title="Unblock">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                        </svg>
                    </button>
                `;
            } else if (!todo.completed && !todo.dropped) {
                // Active: only show Block button (edit via clicking todo content)
                actionsHtml = `
                    <button class="todo-block-btn" onclick="event.stopPropagation(); openBlockReasonModal(${index})" title="Block">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="6" y="4" width="4" height="16"></rect>
                            <rect x="14" y="4" width="4" height="16"></rect>
                        </svg>
                    </button>
                `;
            }
            // Completed or Dropped: no action buttons (edit via clicking todo content)

            todoItem.innerHTML = `
                <div class="todo-checkbox ${checkboxClass}" ${checkboxClick}></div>
                <div class="todo-content" onclick="viewTodo(${index})" style="cursor: pointer;">
                    <div class="todo-info">
                        <div class="todo-title">${escapeHtml(todo.title)}</div>
                        ${dueDateHtml}
                        ${engagementHtml}
                        ${tagsHtml}
                    </div>
                    ${descriptionHtml}
                </div>
                <div class="todo-actions">
                    ${actionsHtml}
                </div>
            `;

            return todoItem;
        }

        // Issue-97: Toggle Recently Completed section
        function toggleRecentlyCompletedSection() {
            const section = document.getElementById('recently-completed-section');
            if (section) {
                section.classList.toggle('expanded');
                state.recentlyCompletedExpanded = section.classList.contains('expanded');
            }
        }

        // Issue-97: Toggle Recently Dropped section
        function toggleRecentlyDroppedSection() {
            const section = document.getElementById('recently-dropped-section');
            if (section) {
                section.classList.toggle('expanded');
                state.recentlyDroppedExpanded = section.classList.contains('expanded');
            }
        }

        // Issue-99: Toggle Upcoming in a Week section
        function toggleUpcomingWeekSection() {
            const section = document.getElementById('upcoming-week-section');
            if (section) {
                section.classList.toggle('expanded');
                state.upcomingWeekExpanded = section.classList.contains('expanded');
            }
        }

        // Issue-99: Toggle Upcoming in 2 Weeks section
        function toggleUpcomingTwoWeeksSection() {
            const section = document.getElementById('upcoming-two-weeks-section');
            if (section) {
                section.classList.toggle('expanded');
                state.upcomingTwoWeeksExpanded = section.classList.contains('expanded');
            }
        }

        // Issue-99: Toggle In the Horizon section
        function toggleHorizonSection() {
            const section = document.getElementById('horizon-section');
            if (section) {
                section.classList.toggle('expanded');
                state.horizonExpanded = section.classList.contains('expanded');
            }
        }

        function toggleTodo(index) {
            const todo = state.todos[index];
            todo.completed = !todo.completed;
            todo.completedAt = todo.completed ? new Date().toISOString() : null;
            todo.updatedAt = new Date().toISOString();

            // Track completion timestamp
            if (todo.completed) {
                todo.completedAt = new Date().toISOString();
            } else {
                todo.completedAt = null;
            }

            // Check and update engagement status if linked
            if (todo.engagementId) {
                updateEngagementAutoStatus(todo.engagementId);
            }

            renderTodos();
            // Re-render engagements if on that tab to update status badges
            if (state.currentTab === 'engagements') {
                renderEngagements();
            }
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // ========================================
        // BLOCK/UNBLOCK TODO FUNCTIONS (Issue-67)
        // ========================================

        // Open the block reason modal
        function openBlockReasonModal(index) {
            const todo = state.todos[index];
            // Can't block completed or dropped todos
            if (todo.completed || todo.dropped) return;

            state.todoIndexToBlock = index;
            state.blockReasonModalOpen = true;

            const modal = document.getElementById('block-reason-modal');
            const todoTitle = document.getElementById('block-todo-title');
            const reasonInput = document.getElementById('block-reason-input');

            todoTitle.textContent = todo.title;
            reasonInput.value = '';

            modal.classList.remove('hidden');
            reasonInput.focus();
        }

        // Close the block reason modal
        function closeBlockReasonModal() {
            state.blockReasonModalOpen = false;
            state.todoIndexToBlock = null;
            document.getElementById('block-reason-modal').classList.add('hidden');
        }

        // Confirm blocking a todo
        function confirmBlockTodo() {
            if (state.todoIndexToBlock === null) return;

            const todo = state.todos[state.todoIndexToBlock];
            const reasonInput = document.getElementById('block-reason-input');
            const reason = reasonInput.value.trim();

            // Set blocked state
            todo.blocked = true;
            todo.blockedAt = new Date().toISOString();
            todo.blockedReason = reason || null;
            todo.updatedAt = new Date().toISOString();

            closeBlockReasonModal();
            renderTodos();
            if (state.currentTab === 'engagements') {
                renderEngagements();
            }
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Unblock a todo
        function unblockTodo(index) {
            const todo = state.todos[index];
            if (!todo.blocked) return;

            todo.blocked = false;
            todo.blockedAt = null;
            todo.blockedReason = null;
            todo.updatedAt = new Date().toISOString();

            renderTodos();
            if (state.currentTab === 'engagements') {
                renderEngagements();
            }
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Block todo from recommendation panel (by ID)
        function blockTodoFromRecommendation(todoId) {
            const index = state.todos.findIndex(t => t.id === todoId);
            if (index !== -1) {
                openBlockReasonModal(index);
            }
        }

        // Unblock todo from recommendation panel (by ID)
        function unblockTodoFromRecommendation(todoId) {
            const index = state.todos.findIndex(t => t.id === todoId);
            if (index !== -1) {
                unblockTodo(index);
            }
        }

        // Utility function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Utility function to validate hex color format (prevents CSS injection)
        function isValidHexColor(color) {
            return typeof color === 'string' && /^#[0-9A-Fa-f]{6}$/.test(color);
        }

        // ========================================
        // IMPORT VALIDATION - Helper Functions (Issue #63)
        // ========================================

        // Validate and truncate string fields
        function sanitizeString(val, maxLength = IMPORT_LIMITS.MAX_STRING_LENGTH) {
            if (val === null || val === undefined) return null;
            if (typeof val !== 'string') return String(val);
            return val.slice(0, maxLength);
        }

        // Validate ID format (non-empty string, reasonable length)
        function isValidId(val) {
            return typeof val === 'string' && val.length > 0 && val.length <= IMPORT_LIMITS.MAX_ID_LENGTH;
        }

        // Validate ISO date string format
        function isValidISODate(val) {
            if (typeof val !== 'string') return false;
            const date = new Date(val);
            return !isNaN(date.getTime());
        }

        // Validate YYYY-MM-DD date format
        function isValidDateString(val) {
            if (typeof val !== 'string') return false;
            return /^\d{4}-\d{2}-\d{2}$/.test(val) && !isNaN(new Date(val).getTime());
        }

        // Sanitize a todo object - returns null if invalid
        function sanitizeTodo(todo) {
            if (!todo || typeof todo !== 'object') return null;
            if (!isValidId(todo.id)) return null;

            return {
                id: todo.id,
                title: sanitizeString(todo.title) || 'Untitled',
                description: sanitizeString(todo.description),
                deadline: isValidISODate(todo.deadline) ? todo.deadline : null,
                effort: VALID_EFFORT_VALUES.includes(todo.effort) ? todo.effort : DEFAULT_EFFORT,
                priority: VALID_PRIORITY_VALUES.includes(todo.priority) ? todo.priority : DEFAULT_PRIORITY,
                engagementId: isValidId(todo.engagementId) ? todo.engagementId : null,
                tagIds: Array.isArray(todo.tagIds) ? todo.tagIds.filter(isValidId).slice(0, 100) : [],
                completed: typeof todo.completed === 'boolean' ? todo.completed : false,
                completedAt: isValidISODate(todo.completedAt) ? todo.completedAt : null,
                dropped: typeof todo.dropped === 'boolean' ? todo.dropped : false,
                droppedAt: isValidISODate(todo.droppedAt) ? todo.droppedAt : null,
                blocked: typeof todo.blocked === 'boolean' ? todo.blocked : false,
                blockedAt: isValidISODate(todo.blockedAt) ? todo.blockedAt : null,
                blockedReason: sanitizeString(todo.blockedReason),
                createdAt: isValidISODate(todo.createdAt) ? todo.createdAt : new Date().toISOString(),
                updatedAt: isValidISODate(todo.updatedAt) ? todo.updatedAt : new Date().toISOString()
            };
        }

        // Sanitize an engagement object - returns null if invalid
        function sanitizeEngagement(eng) {
            if (!eng || typeof eng !== 'object') return null;
            if (!isValidId(eng.id)) return null;

            // Sanitize comments array
            let comments = [];
            if (Array.isArray(eng.comments)) {
                comments = eng.comments
                    .slice(0, IMPORT_LIMITS.MAX_COMMENTS_PER_ENGAGEMENT)
                    .filter(c => c && typeof c === 'object')
                    .map(c => ({
                        id: isValidId(c.id) ? c.id : generateId(),
                        text: sanitizeString(c.text) || '',
                        createdAt: isValidISODate(c.createdAt) ? c.createdAt : new Date().toISOString()
                    }));
            }

            return {
                id: eng.id,
                name: sanitizeString(eng.name) || 'Unnamed Engagement',
                description: sanitizeString(eng.description),
                startDate: isValidDateString(eng.startDate) ? eng.startDate : getTodayDate(),
                contact: sanitizeString(eng.contact),
                contactId: isValidId(eng.contactId) ? eng.contactId : null,
                tagIds: Array.isArray(eng.tagIds) ? eng.tagIds.filter(isValidId).slice(0, 100) : [],
                type: VALID_ENGAGEMENT_TYPES.includes(eng.type) ? eng.type : 'engagement',
                status: VALID_ENGAGEMENT_STATUSES.includes(eng.status) ? eng.status : 'active',
                comments: comments,
                archived: typeof eng.archived === 'boolean' ? eng.archived : false,
                createdAt: isValidISODate(eng.createdAt) ? eng.createdAt : new Date().toISOString(),
                // Preserve lifecycle data if present (validated separately)
                preProject: eng.preProject && typeof eng.preProject === 'object' ? eng.preProject : null,
                project: eng.project && typeof eng.project === 'object' ? eng.project : null
            };
        }

        // Sanitize a person object - returns null if invalid
        function sanitizePerson(person) {
            if (!person || typeof person !== 'object') return null;
            if (!isValidId(person.id)) return null;

            return {
                id: person.id,
                name: sanitizeString(person.name) || 'Unnamed Person',
                roleId: isValidId(person.roleId) ? person.roleId : null,
                createdAt: isValidISODate(person.createdAt) ? person.createdAt : new Date().toISOString()
            };
        }

        // Sanitize a tag object - returns null if invalid
        function sanitizeTag(tag) {
            if (!tag || typeof tag !== 'object') return null;
            if (!isValidId(tag.id)) return null;

            return {
                id: tag.id,
                name: sanitizeString(tag.name) || 'Unnamed Tag',
                color: isValidHexColor(tag.color) ? tag.color : DEFAULT_TAG_COLOR,
                createdAt: isValidISODate(tag.createdAt) ? tag.createdAt : new Date().toISOString()
            };
        }

        // Sanitize a role object - returns null if invalid
        function sanitizeRole(role) {
            if (!role || typeof role !== 'object') return null;
            if (!isValidId(role.id)) return null;

            return {
                id: role.id,
                name: sanitizeString(role.name) || 'Unnamed Role'
            };
        }

        // Format date for display
        function formatDate(dateString) {
            const date = new Date(dateString);
            const options = { year: 'numeric', month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        // Engagement Modal functions
        function openEngagementModal() {
            engagementModal.classList.remove('hidden');
            state.engagementModalOpen = true;
            state.editingEngagementIndex = null;  // Create mode

            // Update modal title
            const modalTitle = engagementModal.querySelector('.modal-title');
            if (modalTitle) modalTitle.textContent = 'New Engagement';

            // Reset form
            engagementForm.reset();
            // Set default start date to today
            engStartDateInput.value = getTodayDate();

            // Reset contact autocomplete state
            state.selectedPersonId = null;
            state.pendingPerson = null;
            state.contactAutocompleteOpen = false;
            state.contactAutocompleteHighlightIndex = -1;
            state.inlinePersonFormOpen = false;
            engContactClear.classList.remove('visible');
            contactDropdown.classList.remove('open');
            inlinePersonForm.classList.remove('open');

            // Reset tag input state
            state.selectedOppTagIds = [];
            state.engTagDropdownOpen = false;
            state.oppTagHighlightIndex = -1;
            engTagInput.value = '';
            closeOppTagDropdown();
            renderOppSelectedTags();

            // Focus on name input
            setTimeout(() => engNameInput.focus(), 100);
        }

        // Open engagement modal in edit mode
        function openEditEngagement(index) {
            const eng = state.engagements[index];
            if (!eng) return;

            engagementModal.classList.remove('hidden');
            state.engagementModalOpen = true;
            state.editingEngagementIndex = index;

            // Update modal title
            const modalTitle = engagementModal.querySelector('.modal-title');
            if (modalTitle) modalTitle.textContent = 'Edit Engagement';

            // Reset form first
            engagementForm.reset();

            // Populate form with existing data
            engNameInput.value = eng.name || '';
            engDescriptionInput.value = eng.description || '';
            engStartDateInput.value = eng.startDate || '';

            // Handle contact
            if (eng.contactId) {
                const person = state.people.find(p => p.id === eng.contactId);
                if (person) {
                    state.selectedPersonId = eng.contactId;
                    engContactInput.value = person.name;
                    engContactClear.classList.add('visible');
                } else {
                    state.selectedPersonId = null;
                    engContactInput.value = eng.contact || '';
                    engContactClear.classList.remove('visible');
                }
            } else if (eng.contact) {
                state.selectedPersonId = null;
                engContactInput.value = eng.contact;
                engContactClear.classList.remove('visible');
            } else {
                state.selectedPersonId = null;
                engContactInput.value = '';
                engContactClear.classList.remove('visible');
            }

            // Reset autocomplete state
            state.pendingPerson = null;
            state.contactAutocompleteOpen = false;
            state.contactAutocompleteHighlightIndex = -1;
            state.inlinePersonFormOpen = false;
            contactDropdown.classList.remove('open');
            inlinePersonForm.classList.remove('open');

            // Handle tags
            state.selectedOppTagIds = eng.tagIds ? [...eng.tagIds] : [];
            state.engTagDropdownOpen = false;
            state.oppTagHighlightIndex = -1;
            engTagInput.value = '';
            closeOppTagDropdown();
            renderOppSelectedTags();

            // Focus on name input
            setTimeout(() => engNameInput.focus(), 100);
        }

        function closeEngagementModal() {
            engagementModal.classList.add('hidden');
            state.engagementModalOpen = false;
            state.selectedPersonId = null;
            state.pendingPerson = null;
            state.contactAutocompleteOpen = false;
            state.inlinePersonFormOpen = false;
            engagementForm.reset();
            contactDropdown.classList.remove('open');
            inlinePersonForm.classList.remove('open');
        }

        // Save engagement
        function saveEngagement(event) {
            event.preventDefault();

            const name = engNameInput.value.trim();
            const description = engDescriptionInput.value.trim();
            const startDate = engStartDateInput.value;
            const contactName = engContactInput.value.trim();

            if (!name) return;

            // Handle pending person creation
            let contactId = state.selectedPersonId;
            if (state.pendingPerson) {
                // Create the pending person
                const roleId = getOrCreateRole(state.pendingPerson.role);
                const newPerson = {
                    id: generateId(),
                    name: state.pendingPerson.name,
                    roleId: roleId
                };
                state.people.push(newPerson);
                contactId = newPerson.id;
            }

            if (state.editingEngagementIndex !== null) {
                // Edit mode - update existing engagement
                const eng = state.engagements[state.editingEngagementIndex];
                if (eng) {
                    eng.name = name;
                    eng.description = description || null;
                    eng.startDate = startDate || eng.startDate;
                    eng.contact = contactName || null;
                    eng.contactId = contactId || null;
                    eng.tagIds = [...state.selectedOppTagIds];
                    // Don't change status, comments, archived, createdAt
                }
            } else {
                // Create mode - add new engagement
                const newEngagement = {
                    id: generateId(),
                    name: name,
                    description: description || null,
                    startDate: startDate || getTodayDate(),
                    contact: contactName || null,  // Keep text for display
                    contactId: contactId || null,  // Link to person
                    tagIds: [...state.selectedOppTagIds],
                    type: 'engagement',  // Default type (engagement | pre-project | project)
                    status: 'active',  // Default status (active | completed | closed | dropped)
                    comments: [],
                    archived: false,
                    createdAt: new Date().toISOString(),
                    // Lifecycle data (null until promoted)
                    preProject: null,
                    project: null
                };
                state.engagements.push(newEngagement);
            }

            closeEngagementModal();
            renderEngagements();
            renderPeople();  // Refresh people list if new person was created

            // Update side panel if open and editing the same engagement
            if (state.sidePanelOpen && state.selectedEngagementIndex === state.editingEngagementIndex) {
                openSidePanel(state.selectedEngagementIndex);
            }

            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Toggle show archived engagements
        function toggleShowArchived() {
            state.showArchived = showArchivedToggle.checked;
            renderEngagements();
        }

        // Render engagements list
        function renderEngagements() {
            if (state.currentPage !== 'app' || state.currentTab !== 'engagements') return;

            // Clear current list
            engagementList.innerHTML = '';

            // Filter engagements based on archived state and search query (Issue-59)
            const filteredEngagements = state.engagements.filter(opp => {
                // First apply archived filter
                if (!state.showArchived && opp.archived) return false;
                // Then apply search filter
                if (state.searchQuery && !matchesEngagement(opp, state.searchQuery)) return false;
                return true;
            });

            if (filteredEngagements.length === 0) {
                // Show empty state
                engagementList.classList.add('hidden');
                engagementEmptyState.classList.remove('hidden');
                oppShortcutHintFloating.classList.add('hidden');
            } else {
                // Show engagement list
                engagementList.classList.remove('hidden');
                engagementEmptyState.classList.add('hidden');
                oppShortcutHintFloating.classList.remove('hidden');

                filteredEngagements.forEach((opp) => {
                    // Find original index in state.engagements
                    const index = state.engagements.indexOf(opp);
                    const oppItem = document.createElement('div');
                    oppItem.className = 'engagement-item' + (opp.archived ? ' archived' : '');

                    const statusClass = `status-${opp.status}`;
                    // Use dynamic type based on allocation dates (Issue-57)
                    const displayType = getEngagementDisplayType(opp);
                    const typeClass = `type-${displayType}`;
                    const typeName = getTypeDisplayName(displayType);

                    // Build action buttons based on status
                    let actionButtons = '';
                    if (!opp.archived) {
                        const isActiveOrPaused = opp.status === 'active' || opp.status === 'paused';

                        // Edit button - always shown for non-archived
                        const editBtn = `
                            <button class="opp-action-btn edit-btn" onclick="event.stopPropagation(); openEditEngagement(${index})" title="Edit Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                        `;

                        // Complete button (checkmark) - only for active/paused
                        const completeBtn = isActiveOrPaused ? `
                            <button class="opp-action-btn complete-btn" onclick="event.stopPropagation(); completeEngagement(${index})" title="Complete Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                            </button>
                        ` : '';

                        // Close button (minus) - only for active/paused
                        const closeBtn = isActiveOrPaused ? `
                            <button class="opp-action-btn close-btn" onclick="event.stopPropagation(); closeEngagementAction(${index})" title="Close Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                </svg>
                            </button>
                        ` : '';

                        // Cancel button (X in circle) - only for active/paused
                        const cancelBtn = isActiveOrPaused ? `
                            <button class="opp-action-btn cancel-btn" onclick="event.stopPropagation(); openCancelConfirmation(${index})" title="Cancel Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="15" y1="9" x2="9" y2="15"></line>
                                    <line x1="9" y1="9" x2="15" y2="15"></line>
                                </svg>
                            </button>
                        ` : '';

                        // Reactivate button - only for closed
                        const reactivateBtn = opp.status === 'closed' ? `
                            <button class="opp-action-btn reactivate-btn" onclick="event.stopPropagation(); reactivateEngagement(${index})" title="Reactivate Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M23 4v6h-6"></path>
                                    <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                                </svg>
                            </button>
                        ` : '';

                        // Uncancel button - only for dropped
                        const uncancelBtn = opp.status === 'dropped' ? `
                            <button class="opp-action-btn uncancel-btn" onclick="event.stopPropagation(); uncancelEngagement(${index})" title="Uncancel Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M23 4v6h-6"></path>
                                    <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                                </svg>
                            </button>
                        ` : '';

                        // Delete button - always shown
                        const deleteBtn = `
                            <button class="opp-action-btn delete-btn" onclick="event.stopPropagation(); openDeleteConfirmation(${index})" title="Delete Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                    <line x1="10" y1="11" x2="10" y2="17"></line>
                                    <line x1="14" y1="11" x2="14" y2="17"></line>
                                </svg>
                            </button>
                        `;

                        actionButtons = editBtn + completeBtn + closeBtn + cancelBtn + reactivateBtn + uncancelBtn + deleteBtn;
                    }
                    // No buttons for archived engagements

                    // Format tags for engagement
                    let oppTagsHtml = '';
                    if (opp.tagIds && opp.tagIds.length > 0) {
                        const tagPills = opp.tagIds.map(tagId => {
                            const tag = getTagById(tagId);
                            if (tag) {
                                return `<span class="tag-pill" style="background-color: ${tag.color}; color: #fff;">${escapeHtml(tag.name)}</span>`;
                            }
                            return '';
                        }).filter(Boolean).join('');
                        if (tagPills) {
                            oppTagsHtml = `<div class="tags-container">${tagPills}</div>`;
                        }
                    }

                    // Check if this engagement is expanded (Issue-57)
                    const isExpanded = state.expandedEngagementId === opp.id;
                    if (isExpanded) {
                        oppItem.classList.add('expanded');
                    }

                    // Build expanded content (Issue-57)
                    const expandedContent = renderEngagementExpandedContent(opp, index);

                    // Build allocation timeline bar (Issue-69)
                    const allocationTimelineHtml = renderAllocationTimelineBar(opp);

                    oppItem.innerHTML = `
                        <div class="engagement-header" onclick="toggleEngagementExpansion('${opp.id}')">
                            <div class="engagement-content">
                                <div class="engagement-type-indicator">
                                    <span class="engagement-type-badge ${typeClass}">${typeName}</span>
                                </div>
                                <div class="engagement-name">${escapeHtml(opp.name)}</div>
                                ${opp.contact ? `<div class="engagement-contact">${escapeHtml(opp.contact)}</div>` : ''}
                                ${oppTagsHtml}
                            </div>
                            ${allocationTimelineHtml}
                            ${getStatusBadgeWithTooltip(opp.status, statusClass)}
                            <div class="engagement-actions" onclick="event.stopPropagation()">
                                ${actionButtons}
                            </div>
                        </div>
                        <div class="engagement-expanded-content">
                            ${expandedContent}
                        </div>
                    `;
                    engagementList.appendChild(oppItem);
                });
            }
        }

        // ========================================
        // ENGAGEMENT EXPANSION FUNCTIONS (Issue-57)
        // ========================================

        // Toggle engagement expansion
        function toggleEngagementExpansion(engagementId) {
            // Accordion behavior: if already expanded, collapse; otherwise expand this one
            if (state.expandedEngagementId === engagementId) {
                state.expandedEngagementId = null;
            } else {
                state.expandedEngagementId = engagementId;
            }
            renderEngagements();
        }

        // Collapse engagement expansion (called when clicking outside)
        function collapseEngagementExpansion() {
            if (state.expandedEngagementId) {
                state.expandedEngagementId = null;
                renderEngagements();
            }
        }

        // Render expanded content for an engagement
        function renderEngagementExpandedContent(opp, index) {
            // Get contact info
            let contactName = '';
            let contactRole = '';
            if (opp.contactId) {
                const person = state.people.find(p => p.id === opp.contactId);
                if (person) {
                    contactName = person.name;
                    const role = state.roles.find(r => r.id === person.roleId);
                    contactRole = role ? role.name : '';
                }
            } else if (opp.contact) {
                contactName = opp.contact;
            }

            // Format start date as month/year
            const startMonth = opp.startDate ? formatMonthFull(opp.startDate.substring(0, 7)) : 'Not set';

            // Get comments count
            const commentsCount = (opp.comments || []).length;

            // Check if allocation exists
            const allocation = getAllocationForEngagement(opp.id);
            const hasAllocation = allocation && (allocation.preProject || allocation.project);
            const promoteButtonText = hasAllocation ? 'Allocation' : 'Promote to Project';

            // Render linked todos
            const todosHtml = renderEngagementTodos(opp.id);

            return `
                <div class="engagement-expanded-panes">
                    <div class="engagement-left-pane">
                        <div class="engagement-detail-row">
                            <div class="engagement-detail-group">
                                <div class="engagement-detail-label">Contact:</div>
                                <div class="engagement-detail-value">${escapeHtml(contactName) || 'Not set'}</div>
                                ${contactRole ? `<div class="engagement-detail-subtitle">${escapeHtml(contactRole)}</div>` : ''}
                            </div>
                            <div class="engagement-detail-group">
                                <div class="engagement-detail-label">Start Month:</div>
                                <div class="engagement-detail-value">${startMonth}</div>
                            </div>
                        </div>
                        <div class="engagement-description-section">
                            <div class="engagement-description-label">Description</div>
                            <div class="engagement-description-text">${opp.description ? escapeHtml(opp.description) : 'No description'}</div>
                        </div>
                        <div class="engagement-action-row">
                            <button class="engagement-promote-btn" onclick="event.stopPropagation(); openUnifiedPromoteModal('${opp.id}')">${promoteButtonText}</button>
                            <button class="engagement-comments-btn" onclick="event.stopPropagation(); openCommentsPanel('${opp.id}')">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                                </svg>
                                <span class="engagement-comments-count">${commentsCount}</span>
                            </button>
                        </div>
                    </div>
                    <div class="engagement-right-pane">
                        ${todosHtml}
                    </div>
                </div>
            `;
        }

        // Render linked todos for an engagement (Issue-57)
        function renderEngagementTodos(engagementId) {
            const linkedTodos = state.todos.filter(t => t.engagementId === engagementId);

            if (linkedTodos.length === 0) {
                return '<div class="engagement-todos-empty">No todos linked to this engagement</div>';
            }

            // Sort: open first, then blocked, then by priority, then completed, then dropped
            const priorityOrder = { 'urgent': 0, 'high': 1, 'normal': 2, 'low': 3, 'someday': 4 };
            linkedTodos.sort((a, b) => {
                // Active (not completed, dropped, or blocked) first
                const aActive = !a.completed && !a.dropped && !a.blocked;
                const bActive = !b.completed && !b.dropped && !b.blocked;
                if (aActive && !bActive) return -1;
                if (!aActive && bActive) return 1;

                // Blocked before completed/dropped
                if (a.blocked && !b.blocked) return -1;
                if (!a.blocked && b.blocked) return 1;

                // Among active, sort by priority
                if (aActive && bActive) {
                    return (priorityOrder[a.priority] || 2) - (priorityOrder[b.priority] || 2);
                }

                return 0;
            });

            const effortLabels = {
                'very_low': '30 min',
                'low': '2 hrs',
                'average': '4 hrs',
                'high': '6 hrs',
                'very_high': '8 hrs'
            };

            const priorityLabels = {
                'urgent': 'Urgent',
                'high': 'High Priority',
                'normal': 'Normal',
                'low': 'Low',
                'someday': 'Someday'
            };

            return `
                <div class="engagement-todo-list">
                    ${linkedTodos.map(todo => {
                        const statusClass = todo.blocked ? 'blocked' : (todo.dropped ? 'dropped' : (todo.completed ? 'done' : 'open'));
                        const itemClass = todo.blocked ? 'blocked' : (todo.dropped ? 'dropped' : (todo.completed ? 'completed' : ''));
                        const effortText = effortLabels[todo.effort] || '4 hrs';
                        const priorityText = priorityLabels[todo.priority] || 'Normal';

                        // Status icon
                        let statusIcon = '';
                        if (todo.blocked) {
                            statusIcon = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>`;
                        } else if (todo.dropped) {
                            statusIcon = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
                        } else if (todo.completed) {
                            statusIcon = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
                        } else {
                            statusIcon = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle></svg>`;
                        }

                        // Blocked overlay (Issue-67)
                        const blockedOverlay = todo.blocked ? `<div class="blocked-overlay"><span class="blocked-overlay-text">Blocked</span></div>` : '';

                        return `
                            <div class="engagement-todo-item ${itemClass}">
                                <div class="engagement-todo-status ${statusClass}">${statusIcon}</div>
                                <div class="engagement-todo-title">${escapeHtml(todo.title)}</div>
                                <span class="engagement-todo-priority ${todo.priority || 'normal'}">${priorityText}</span>
                                <span class="engagement-todo-effort">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
                                    ${effortText}
                                </span>
                                ${blockedOverlay}
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        // ========================================
        // UNIFIED PROMOTION MODAL FUNCTIONS (Issue-57)
        // ========================================

        // Open unified promote modal
        function openUnifiedPromoteModal(engagementId) {
            const eng = state.engagements.find(e => e.id === engagementId);
            if (!eng) return;

            state.unifiedPromoteModalOpen = true;
            state.unifiedPromoteEngagementId = engagementId;

            // Load existing allocation if any
            const allocation = getAllocationForEngagement(engagementId);

            // Reset state
            state.preProjectSectionEnabled = false;
            state.projectSectionEnabled = false;
            state.preProjectAllocationPercent = 25;
            state.projectAllocationPercent = 25;
            state.preProjectSelectedMonths = [];
            state.projectStartMonth = null;
            state.projectEndMonth = null;
            state.monthTimelineOffset = 0;

            // Pre-fill from existing allocation
            if (allocation) {
                if (allocation.preProject) {
                    state.preProjectSectionEnabled = true;
                    state.preProjectAllocationPercent = allocation.preProject.allocationPercentage || 25;
                    state.preProjectSelectedMonths = [...(allocation.preProject.months || [])];
                }
                if (allocation.project) {
                    state.projectSectionEnabled = true;
                    state.projectAllocationPercent = allocation.project.allocationPercentage || 25;
                    state.projectStartMonth = allocation.project.startMonth || null;
                    state.projectEndMonth = allocation.project.endMonth || null;
                }
            }

            // Update modal title
            const hasAllocation = allocation && (allocation.preProject || allocation.project);
            unifiedPromoteTitle.textContent = hasAllocation ? 'Allocation' : 'Promote Engagement';

            // Update UI
            updateUnifiedModalUI();

            // Show modal
            unifiedPromoteModal.classList.remove('hidden');
        }

        // Close unified promote modal
        function closeUnifiedPromoteModal() {
            state.unifiedPromoteModalOpen = false;
            state.unifiedPromoteEngagementId = null;
            unifiedPromoteModal.classList.add('hidden');
        }

        // Update unified modal UI
        function updateUnifiedModalUI() {
            // Update pre-project section
            if (state.preProjectSectionEnabled) {
                preprojectToggle.classList.add('enabled');
                preprojectAllocationSection.classList.add('expanded');
            } else {
                preprojectToggle.classList.remove('enabled');
                preprojectAllocationSection.classList.remove('expanded');
            }

            // Update project section
            if (state.projectSectionEnabled) {
                projectToggle.classList.add('enabled');
                projectAllocationSection.classList.add('expanded');
            } else {
                projectToggle.classList.remove('enabled');
                projectAllocationSection.classList.remove('expanded');
            }

            // Update allocation inputs
            preprojectAllocationInputEl.value = state.preProjectAllocationPercent + '%';
            projectAllocationInputEl.value = state.projectAllocationPercent + '%';

            // Render timelines
            renderPreProjectTimeline();
            renderProjectTimeline();

            // Update save button state
            updateUnifiedSaveButtonState();
        }

        // Toggle pre-project section
        function togglePreProjectSection() {
            state.preProjectSectionEnabled = !state.preProjectSectionEnabled;
            if (!state.preProjectSectionEnabled) {
                state.preProjectSelectedMonths = [];
            }
            updateUnifiedModalUI();
        }

        // Toggle project section
        function toggleProjectSection() {
            state.projectSectionEnabled = !state.projectSectionEnabled;
            if (!state.projectSectionEnabled) {
                state.projectStartMonth = null;
                state.projectEndMonth = null;
            }
            updateUnifiedModalUI();
        }

        // Update pre-project allocation value
        function updatePreProjectAllocationValue(value) {
            const num = parseInt(value.replace('%', ''), 10);
            if (!isNaN(num) && num >= 1 && num <= 100) {
                state.preProjectAllocationPercent = num;
            }
            updateUnifiedSaveButtonState();
        }

        // Update project allocation value
        function updateProjectAllocationValue(value) {
            const num = parseInt(value.replace('%', ''), 10);
            if (!isNaN(num) && num >= 1 && num <= 100) {
                state.projectAllocationPercent = num;
            }
            updateUnifiedSaveButtonState();
        }

        // Render pre-project timeline
        function renderPreProjectTimeline() {
            preprojectTimeline.innerHTML = renderMonthTimeline('preproject');
        }

        // Render project timeline
        function renderProjectTimeline() {
            projectTimeline.innerHTML = renderMonthTimeline('project');
        }

        // Render month timeline for a section
        function renderMonthTimeline(section) {
            const currentMonth = getCurrentMonth();
            const [currentYear, currentMonthNum] = currentMonth.split('-').map(Number);

            // Generate 18 months from 6 months ago to 12 months in future
            const months = [];
            for (let offset = -6 + state.monthTimelineOffset; offset < 12 + state.monthTimelineOffset; offset++) {
                let year = currentYear;
                let month = currentMonthNum + offset;

                while (month > 12) {
                    month -= 12;
                    year++;
                }
                while (month < 1) {
                    month += 12;
                    year--;
                }

                const monthStr = `${year}-${String(month).padStart(2, '0')}`;
                months.push(monthStr);
            }

            // Group months by year for display
            const yearGroups = {};
            months.forEach(m => {
                const year = getYearFromMonth(m);
                if (!yearGroups[year]) {
                    yearGroups[year] = [];
                }
                yearGroups[year].push(m);
            });

            // Determine disabled months for project section
            const disabledMonths = new Set();
            if (section === 'project' && state.preProjectSelectedMonths.length > 0) {
                // All months up to and including the last pre-project month are disabled
                const sortedPreProject = [...state.preProjectSelectedMonths].sort();
                const lastPreProjectMonth = sortedPreProject[sortedPreProject.length - 1];
                months.forEach(m => {
                    if (m <= lastPreProjectMonth) {
                        disabledMonths.add(m);
                    }
                });
            }

            // Determine selected months
            const selectedMonths = new Set();
            if (section === 'preproject') {
                state.preProjectSelectedMonths.forEach(m => selectedMonths.add(m));
            } else if (section === 'project' && state.projectStartMonth && state.projectEndMonth) {
                const projectMonths = generateMonthRange(state.projectStartMonth, state.projectEndMonth);
                projectMonths.forEach(m => selectedMonths.add(m));
            }

            // Build years row HTML
            let yearsHtml = '';
            Object.keys(yearGroups).sort().forEach(year => {
                const monthCount = yearGroups[year].length;
                // Calculate width based on number of months (each month is ~55px including gap)
                yearsHtml += `<div class="month-timeline-year" style="width: ${monthCount * 55}px;">${year}</div>`;
            });

            // Build months row HTML
            let monthsHtml = months.map(m => {
                const isSelected = selectedMonths.has(m);
                const isDisabled = disabledMonths.has(m);
                const sectionClass = section === 'preproject' ? 'preproject' : 'project';

                let classes = 'month-timeline-month';
                if (isSelected) classes += ' selected ' + sectionClass;
                if (isDisabled) classes += ' disabled';

                const monthName = formatMonthShort(m);
                const onclick = isDisabled ? '' : `onclick="handleMonthClick('${section}', '${m}', event)"`;

                return `<div class="${classes}" data-month="${m}" ${onclick}>${monthName}</div>`;
            }).join('');

            return `
                <div class="month-timeline-nav">
                    <button class="month-timeline-arrow" onclick="scrollTimelineLeft()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="15 18 9 12 15 6"></polyline>
                        </svg>
                    </button>
                    <div class="month-timeline-scroll">
                        <div class="month-timeline-years">${yearsHtml}</div>
                        <div class="month-timeline-months">${monthsHtml}</div>
                    </div>
                    <button class="month-timeline-arrow" onclick="scrollTimelineRight()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="9 18 15 12 9 6"></polyline>
                        </svg>
                    </button>
                </div>
            `;
        }

        // Scroll timeline left
        function scrollTimelineLeft() {
            state.monthTimelineOffset -= 3;
            renderPreProjectTimeline();
            renderProjectTimeline();
        }

        // Scroll timeline right
        function scrollTimelineRight() {
            state.monthTimelineOffset += 3;
            renderPreProjectTimeline();
            renderProjectTimeline();
        }

        // Handle month click in timeline
        function handleMonthClick(section, month, event) {
            if (section === 'preproject') {
                handlePreProjectMonthClick(month, event);
            } else if (section === 'project') {
                handleProjectMonthClick(month, event);
            }
        }

        // Handle pre-project month click (allows gaps with Shift+Click)
        function handlePreProjectMonthClick(month, event) {
            const isShiftClick = event && event.shiftKey;

            if (isShiftClick && state.preProjectSelectedMonths.includes(month)) {
                // Shift+Click on selected month: deselect it
                state.preProjectSelectedMonths = state.preProjectSelectedMonths.filter(m => m !== month);
            } else if (state.preProjectSelectedMonths.includes(month)) {
                // Regular click on selected: deselect
                state.preProjectSelectedMonths = state.preProjectSelectedMonths.filter(m => m !== month);
            } else {
                // Click on unselected: select it
                if (state.preProjectSelectedMonths.length === 0) {
                    // First selection
                    state.preProjectSelectedMonths = [month];
                } else {
                    // Already have selections - fill range if needed
                    const sorted = [...state.preProjectSelectedMonths, month].sort();
                    const first = sorted[0];
                    const last = sorted[sorted.length - 1];
                    // Auto-fill range
                    state.preProjectSelectedMonths = generateMonthRange(first, last);
                }
            }

            updateUnifiedModalUI();
        }

        // Handle project month click (continuous range only)
        function handleProjectMonthClick(month, event) {
            if (!state.projectStartMonth) {
                // First click: set start
                state.projectStartMonth = month;
                state.projectEndMonth = month;
            } else if (state.projectStartMonth === state.projectEndMonth && state.projectStartMonth === month) {
                // Click on same month: deselect
                state.projectStartMonth = null;
                state.projectEndMonth = null;
            } else if (month < state.projectStartMonth) {
                // Click before start: reset with new start
                state.projectStartMonth = month;
                state.projectEndMonth = month;
            } else {
                // Click after start: extend to this month
                state.projectEndMonth = month;
            }

            updateUnifiedModalUI();
        }

        // Update save button state
        function updateUnifiedSaveButtonState() {
            let canSave = false;

            // Check if at least one section is properly configured
            if (state.preProjectSectionEnabled) {
                const validPercent = state.preProjectAllocationPercent >= 1 && state.preProjectAllocationPercent <= 100;
                const hasMonths = state.preProjectSelectedMonths.length > 0;
                if (validPercent && hasMonths) {
                    canSave = true;
                }
            }

            if (state.projectSectionEnabled) {
                const validPercent = state.projectAllocationPercent >= 1 && state.projectAllocationPercent <= 100;
                const hasRange = state.projectStartMonth && state.projectEndMonth;
                if (validPercent && hasRange) {
                    canSave = true;
                }
            }

            unifiedPromoteSaveBtn.disabled = !canSave;
        }

        // Save unified promotion
        function saveUnifiedPromotion() {
            if (!state.unifiedPromoteEngagementId) return;

            const allocation = {
                id: state.unifiedPromoteEngagementId,
                updatedAt: new Date().toISOString()
            };

            if (state.preProjectSectionEnabled && state.preProjectSelectedMonths.length > 0) {
                allocation.preProject = {
                    allocationPercentage: state.preProjectAllocationPercent,
                    months: [...state.preProjectSelectedMonths].sort()
                };
            }

            if (state.projectSectionEnabled && state.projectStartMonth && state.projectEndMonth) {
                allocation.project = {
                    allocationPercentage: state.projectAllocationPercent,
                    startMonth: state.projectStartMonth,
                    endMonth: state.projectEndMonth
                };
            }

            saveAllocation(allocation)
                .then(() => {
                    closeUnifiedPromoteModal();
                    renderEngagements();
                })
                .catch(err => Logger.error('Failed to save allocation:', err));
        }

        // Open comments panel for an engagement (Issue-57)
        function openCommentsPanel(engagementId) {
            const index = state.engagements.findIndex(e => e.id === engagementId);
            if (index >= 0) {
                openSidePanel(index);
            }
        }

        // Capitalize first letter
        function capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        // Generate status tooltip HTML
        function getStatusTooltipHtml(currentStatus) {
            const statusDescriptions = {
                active: {
                    brief: 'Currently being worked on',
                    detail: 'Default state for new engagements with linked Todos. Transitions to Paused (auto, when no undone Todos), Completed (Complete action), Closed (Close action), or Dropped (Cancel action).'
                },
                paused: {
                    brief: 'No active Todos linked',
                    detail: 'Auto-triggered when an Active engagement has no undone Todos linked. Auto-resumes to Active when an undone Todo is linked.'
                },
                completed: {
                    brief: 'Successfully finished',
                    detail: 'Transitioned from Active via the Complete action. Indicates all deliverables were met successfully. This is a final state.'
                },
                closed: {
                    brief: 'Ended normally',
                    detail: 'Transitioned from Active via the Close action. Ended normally but not necessarily with full delivery. Can be reactivated if needed.'
                },
                dropped: {
                    brief: 'Cancelled or abandoned',
                    detail: 'Transitioned from Active via the Cancel action. Cancelled or abandoned before completion due to changing priorities or external factors.'
                }
            };

            const currentDesc = statusDescriptions[currentStatus] || statusDescriptions.active;

            return `
                <div class="status-tooltip" onclick="event.stopPropagation();">
                    <div class="status-tooltip-header">Status: ${capitalizeFirst(currentStatus)}</div>
                    <div class="status-tooltip-brief">${currentDesc.brief}</div>
                    <span class="status-tooltip-link" onclick="event.stopPropagation(); event.preventDefault(); expandStatusTooltip(this);">Read more</span>
                    <div class="status-tooltip-expanded">
                        <div class="status-item">
                            <div class="status-item-name">Active</div>
                            <div class="status-item-desc">${statusDescriptions.active.detail}</div>
                        </div>
                        <div class="status-item">
                            <div class="status-item-name">Paused</div>
                            <div class="status-item-desc">${statusDescriptions.paused.detail}</div>
                        </div>
                        <div class="status-item">
                            <div class="status-item-name">Completed</div>
                            <div class="status-item-desc">${statusDescriptions.completed.detail}</div>
                        </div>
                        <div class="status-item">
                            <div class="status-item-name">Closed</div>
                            <div class="status-item-desc">${statusDescriptions.closed.detail}</div>
                        </div>
                        <div class="status-item">
                            <div class="status-item-name">Dropped</div>
                            <div class="status-item-desc">${statusDescriptions.dropped.detail}</div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Expand status tooltip
        function expandStatusTooltip(linkElement) {
            const tooltip = linkElement.closest('.status-tooltip');
            if (tooltip) {
                tooltip.classList.add('expanded');
            }
        }

        // Collapse all expanded status tooltips
        function collapseAllStatusTooltips() {
            document.querySelectorAll('.status-tooltip.expanded').forEach(tooltip => {
                tooltip.classList.remove('expanded');
            });
        }

        // Generate status badge with tooltip
        function getStatusBadgeWithTooltip(status, statusClass) {
            return `
                <div class="status-tooltip-container">
                    <span class="status-badge ${statusClass}">${capitalizeFirst(status)}</span>
                    ${getStatusTooltipHtml(status)}
                </div>
            `;
        }

        // Side Panel functions (Comments Only)
        function openSidePanel(index) {
            state.selectedEngagementIndex = index;
            state.sidePanelOpen = true;

            const opp = state.engagements[index];

            // Set engagement name in header
            const engNameEl = document.getElementById('side-panel-engagement-name');
            if (engNameEl) {
                engNameEl.textContent = opp.name || 'Unnamed Engagement';
            }

            // Render comments only
            renderCommentsInPanel(opp);

            // Show panel
            sidePanel.classList.add('open');
            sidePanelBackdrop.classList.add('open');
        }

        function closeSidePanel() {
            state.sidePanelOpen = false;
            state.selectedEngagementIndex = null;

            sidePanel.classList.remove('open');
            sidePanelBackdrop.classList.remove('open');
        }

        // Archive engagement (for closed/cancelled engagements)
        function archiveEngagement(index) {
            const opp = state.engagements[index];
            // Allow archiving for closed, completed, or dropped engagements
            if (opp.status !== 'closed' && opp.status !== 'completed' && opp.status !== 'dropped') return;

            opp.archived = true;

            // Close side panel if this engagement was open
            if (state.sidePanelOpen && state.selectedEngagementIndex === index) {
                closeSidePanel();
            }

            // Re-render engagements list
            renderEngagements();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Close engagement action (set status to Closed)
        function closeEngagementAction(index) {
            const opp = state.engagements[index];
            // Allow closing from active or paused status
            if (opp.status !== 'active' && opp.status !== 'paused') return;

            // Check for linked undone todos
            const undoneTodos = state.todos.filter(t =>
                t.engagementId === opp.id && !t.completed && !t.dropped
            );

            if (undoneTodos.length > 0) {
                // Show todo action modal to handle linked todos
                openTodoActionModal(index, 'close');
                return;
            }

            // No linked todos - proceed with close directly
            opp.status = 'closed';
            renderEngagements();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Complete engagement action (set status to Completed - final state)
        function completeEngagement(index) {
            const opp = state.engagements[index];
            // Allow completing from active or paused status
            if (opp.status !== 'active' && opp.status !== 'paused') return;

            opp.status = 'completed';

            // Auto-complete all linked todos that are not already completed or dropped
            const now = new Date().toISOString();
            state.todos.forEach(todo => {
                if (todo.engagementId === opp.id && !todo.completed && !todo.dropped) {
                    todo.completed = true;
                    todo.completedAt = now;
                    todo.updatedAt = now;
                }
            });

            renderEngagements();
            renderTodos();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Reactivate engagement (from Closed to Paused)
        function reactivateEngagement(index) {
            const opp = state.engagements[index];
            // Only allow reactivating from closed status
            if (opp.status !== 'closed') return;

            opp.status = 'paused';
            renderEngagements();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Uncancel engagement (from Dropped to Paused)
        function uncancelEngagement(index) {
            const opp = state.engagements[index];
            // Only allow uncancelling from dropped status
            if (opp.status !== 'dropped') return;

            opp.status = 'paused';
            renderEngagements();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // ========================================
        // ENGAGEMENT LIFECYCLE MANAGEMENT
        // ========================================

        // Get type display name
        function getTypeDisplayName(type) {
            const names = {
                'engagement': 'Engagement',
                'pre-project': 'Pre-Project',
                'project': 'Project'
            };
            return names[type] || 'Engagement';
        }

        // Get type CSS class
        function getTypeClass(type) {
            return `type-${type}`;
        }

        // Render lifecycle section in side panel
        function renderLifecycleSection(eng) {
            // Update type badge using dynamic type based on allocation dates (Issue-57)
            const displayType = getEngagementDisplayType(eng);
            panelEngTypeBadge.textContent = getTypeDisplayName(displayType);
            panelEngTypeBadge.className = `engagement-type-badge ${getTypeClass(displayType)}`;

            // Render action buttons based on type and status
            renderLifecycleActions(eng);

            // Show/hide sections based on type
            if (eng.type === 'engagement') {
                panelPreProjectSection.style.display = 'none';
                panelProjectSection.style.display = 'none';
            } else if (eng.type === 'pre-project') {
                panelPreProjectSection.style.display = 'block';
                panelProjectSection.style.display = 'none';
                renderPreProjectSection(eng);
            } else if (eng.type === 'project') {
                panelPreProjectSection.style.display = 'block';  // Show pre-project history
                panelProjectSection.style.display = 'block';
                renderPreProjectSection(eng);
                renderProjectSection(eng);
            }
        }

        // Render lifecycle action buttons
        function renderLifecycleActions(eng) {
            let buttons = '';

            if (eng.status === 'active') {
                if (eng.type === 'engagement') {
                    buttons = `
                        <button class="lifecycle-action-btn promote" onclick="openPromotePreProjectModal(${state.selectedEngagementIndex})">
                            Promote to Pre-Project
                        </button>
                    `;
                } else if (eng.type === 'pre-project') {
                    buttons = `
                        <button class="lifecycle-action-btn promote" onclick="openPromoteProjectModal(${state.selectedEngagementIndex})">
                            Promote to Project
                        </button>
                        <button class="lifecycle-action-btn secondary" onclick="revertToEngagement(${state.selectedEngagementIndex})">
                            Revert
                        </button>
                    `;
                } else if (eng.type === 'project') {
                    buttons = `
                        <button class="lifecycle-action-btn promote" onclick="completeProject(${state.selectedEngagementIndex})">
                            Complete Project
                        </button>
                    `;
                }
            }

            lifecycleActions.innerHTML = buttons;
        }

        // Render pre-project section
        function renderPreProjectSection(eng) {
            if (!eng.preProject) return;

            panelPreProjectStarted.value = eng.preProject.startedAt || '';
            panelPreProjectExpected.value = eng.preProject.expectedFormalization || '';

            // Render allocations table
            const tbody = panelPreProjectAllocations.querySelector('tbody');
            tbody.innerHTML = '';

            const allocations = eng.preProject.allocations || [];
            if (allocations.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: #6C757D;">No allocations yet</td></tr>';
            } else {
                allocations.forEach((alloc, idx) => {
                    const statusBadge = alloc.chargedToProject
                        ? '<span class="allocation-charged-badge">Charged</span>'
                        : '<span class="allocation-pending-badge">Pending</span>';

                    tbody.innerHTML += `
                        <tr>
                            <td>
                                <input type="month" value="${alloc.month}"
                                    onchange="updatePreProjectAllocation(${idx}, 'month', this.value)"
                                    ${alloc.chargedToProject ? 'disabled' : ''}>
                            </td>
                            <td>
                                <input type="number" value="${alloc.percentage}" min="0" max="100" style="width: 50px;"
                                    onchange="updatePreProjectAllocation(${idx}, 'percentage', this.value)"
                                    ${alloc.chargedToProject ? 'disabled' : ''}>
                            </td>
                            <td>
                                <input type="number" value="${alloc.hours || ''}" min="0" style="width: 50px;"
                                    onchange="updatePreProjectAllocation(${idx}, 'hours', this.value)"
                                    ${alloc.chargedToProject ? 'disabled' : ''}>
                            </td>
                            <td>${statusBadge}</td>
                            <td>
                                ${!alloc.chargedToProject ? `
                                    <button class="allocation-delete-btn" onclick="deletePreProjectAllocation(${idx})" title="Delete">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                                            <line x1="18" y1="6" x2="6" y2="18"></line>
                                            <line x1="6" y1="6" x2="18" y2="18"></line>
                                        </svg>
                                    </button>
                                ` : ''}
                            </td>
                        </tr>
                    `;
                });

                // Render summary
                renderPreProjectSummary(allocations);
            }
        }

        // Render pre-project allocation summary
        function renderPreProjectSummary(allocations) {
            if (allocations.length === 0) {
                panelPreProjectSummary.style.display = 'none';
                return;
            }

            const totalMonths = allocations.length;
            const totalPercentage = allocations.reduce((sum, a) => sum + (a.percentage || 0), 0);
            const avgPercentage = totalMonths > 0 ? Math.round(totalPercentage / totalMonths) : 0;
            const chargedMonths = allocations.filter(a => a.chargedToProject).length;
            const pendingMonths = totalMonths - chargedMonths;

            panelPreProjectSummary.innerHTML = `
                <div class="allocation-summary-row">
                    <span class="allocation-summary-label">Total Months</span>
                    <span class="allocation-summary-value">${totalMonths}</span>
                </div>
                <div class="allocation-summary-row">
                    <span class="allocation-summary-label">Average Allocation</span>
                    <span class="allocation-summary-value">${avgPercentage}%</span>
                </div>
                <div class="allocation-summary-row">
                    <span class="allocation-summary-label">Charged to Project</span>
                    <span class="allocation-summary-value">${chargedMonths}</span>
                </div>
                <div class="allocation-summary-row">
                    <span class="allocation-summary-label">Pending Charge-Back</span>
                    <span class="allocation-summary-value">${pendingMonths}</span>
                </div>
            `;
            panelPreProjectSummary.style.display = 'block';
        }

        // Render project section
        function renderProjectSection(eng) {
            if (!eng.project) return;

            panelProjectFormalized.value = eng.project.formalizedAt || '';
            panelProjectCode.value = eng.project.projectCode || '';
            panelProjectFunding.value = eng.project.fundingSource || '';

            if (eng.project.timeline) {
                panelProjectStart.value = eng.project.timeline.startDate || '';
                panelProjectEnd.value = eng.project.timeline.endDate || '';

                // Render project allocations
                const tbody = panelProjectAllocations.querySelector('tbody');
                tbody.innerHTML = '';

                const allocations = eng.project.timeline.allocations || [];
                if (allocations.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #6C757D;">No allocation periods</td></tr>';
                } else {
                    allocations.forEach((alloc, idx) => {
                        const statusOptions = ['planned', 'active', 'completed', 'cancelled']
                            .map(s => `<option value="${s}" ${alloc.status === s ? 'selected' : ''}>${capitalizeFirst(s)}</option>`)
                            .join('');

                        tbody.innerHTML += `
                            <tr>
                                <td>${formatDate(alloc.periodStart)} - ${formatDate(alloc.periodEnd)}</td>
                                <td>${alloc.percentage}%</td>
                                <td>
                                    <select onchange="updateProjectAllocationStatus(${idx}, this.value)">
                                        ${statusOptions}
                                    </select>
                                </td>
                                <td>
                                    <button class="allocation-delete-btn" onclick="deleteProjectAllocation(${idx})" title="Delete">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                                            <line x1="18" y1="6" x2="6" y2="18"></line>
                                            <line x1="6" y1="6" x2="18" y2="18"></line>
                                        </svg>
                                    </button>
                                </td>
                            </tr>
                        `;
                    });
                }
            }

            // Render charge-back section if applicable
            renderChargeBackSection(eng);
        }

        // Render charge-back section
        function renderChargeBackSection(eng) {
            if (!eng.project || !eng.project.preProjectMonthsCharged || eng.project.preProjectMonthsCharged.length === 0) {
                panelChargeBackSection.style.display = 'none';
                return;
            }

            const chargebacks = eng.project.preProjectMonthsCharged;
            const totalCharged = chargebacks.reduce((sum, cb) => sum + cb.chargedPercentage, 0);

            panelChargeBackSummary.textContent = `${chargebacks.length} months charged back (total: ${totalCharged}% allocation-months)`;

            let listHtml = '';
            chargebacks.forEach(cb => {
                listHtml += `
                    <div class="chargeback-item">
                        <span>${formatMonth(cb.originalMonth)}: ${cb.originalPercentage}% → ${cb.chargedPercentage}%</span>
                        <span style="color: #6C757D; font-size: 11px;">${formatDate(cb.chargedAt)}</span>
                    </div>
                `;
            });
            panelChargeBackList.innerHTML = listHtml;

            panelChargeBackSection.style.display = 'block';
        }

        // Format month for display
        function formatMonth(monthStr) {
            if (!monthStr) return '';
            const [year, month] = monthStr.split('-');
            const date = new Date(year, parseInt(month) - 1, 1);
            return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
        }

        // Add pre-project allocation
        function addPreProjectAllocation() {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.preProject) return;

            // Default to current month
            const now = new Date();
            const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;

            eng.preProject.allocations = eng.preProject.allocations || [];
            eng.preProject.allocations.push({
                month: currentMonth,
                percentage: 0,
                hours: null,
                notes: null,
                chargedToProject: false,
                chargedAt: null
            });

            renderPreProjectSection(eng);
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Update pre-project allocation field
        function updatePreProjectAllocation(idx, field, value) {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.preProject || !eng.preProject.allocations[idx]) return;

            const alloc = eng.preProject.allocations[idx];
            if (field === 'percentage' || field === 'hours') {
                alloc[field] = value ? parseInt(value) : null;
            } else {
                alloc[field] = value;
            }

            renderPreProjectSummary(eng.preProject.allocations);
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Delete pre-project allocation
        function deletePreProjectAllocation(idx) {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.preProject || !eng.preProject.allocations[idx]) return;

            eng.preProject.allocations.splice(idx, 1);
            renderPreProjectSection(eng);
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Save pre-project field
        function savePreProjectField(field, value) {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.preProject) return;

            eng.preProject[field] = value || null;
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Save project field
        function saveProjectField(field, value) {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.project) return;

            eng.project[field] = value || null;
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Save project timeline field
        function saveProjectTimelineField(field, value) {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.project || !eng.project.timeline) return;

            eng.project.timeline[field] = value || null;
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Add project allocation period
        function addProjectAllocation() {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.project || !eng.project.timeline) return;

            // Default to project start/end dates or current month
            const startDate = eng.project.timeline.startDate || getTodayDate();
            const endDate = eng.project.timeline.endDate || getTodayDate();

            eng.project.timeline.allocations = eng.project.timeline.allocations || [];
            eng.project.timeline.allocations.push({
                periodStart: startDate,
                periodEnd: endDate,
                percentage: 25,
                status: 'planned'
            });

            renderProjectSection(eng);
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Update project allocation status
        function updateProjectAllocationStatus(idx, status) {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.project || !eng.project.timeline || !eng.project.timeline.allocations[idx]) return;

            eng.project.timeline.allocations[idx].status = status;
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Delete project allocation
        function deleteProjectAllocation(idx) {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.project || !eng.project.timeline || !eng.project.timeline.allocations[idx]) return;

            eng.project.timeline.allocations.splice(idx, 1);
            renderProjectSection(eng);
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // ========================================
        // PROMOTE TO PRE-PROJECT
        // ========================================

        function openPromotePreProjectModal(index) {
            state.promoteEngagementIndex = index;
            state.promotePreProjectModalOpen = true;

            const eng = state.engagements[index];
            promotePreProjectName.textContent = `"${eng.name}"`;

            // Default start date to engagement start date or today
            preProjectStartedInput.value = eng.startDate || getTodayDate();
            preProjectExpectedInput.value = '';

            promotePreProjectModal.classList.remove('hidden');
        }

        function closePromotePreProjectModal() {
            promotePreProjectModal.classList.add('hidden');
            state.promotePreProjectModalOpen = false;
            state.promoteEngagementIndex = null;
        }

        function confirmPromoteToPreProject() {
            if (state.promoteEngagementIndex === null) return;

            const eng = state.engagements[state.promoteEngagementIndex];
            const startedAt = preProjectStartedInput.value;
            const expectedFormalization = preProjectExpectedInput.value;

            if (!startedAt) {
                alert('Please select a start date');
                return;
            }

            // Update engagement
            eng.type = 'pre-project';
            eng.preProject = {
                startedAt: startedAt,
                expectedFormalization: expectedFormalization || null,
                allocations: []
            };

            closePromotePreProjectModal();
            renderEngagements();

            // Refresh side panel if open
            if (state.sidePanelOpen && state.selectedEngagementIndex === state.promoteEngagementIndex) {
                openSidePanel(state.promoteEngagementIndex);
            }

            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // ========================================
        // PROMOTE TO PROJECT
        // ========================================

        function openPromoteProjectModal(index) {
            state.promoteEngagementIndex = index;
            state.promoteProjectModalOpen = true;
            state.selectedChargeBackMode = 'original';

            const eng = state.engagements[index];
            promoteProjectName.textContent = `"${eng.name}"`;

            // Default formalization date to today
            projectFormalizedInput.value = getTodayDate();
            projectCodeInput.value = '';
            projectFundingInput.value = '';
            projectStartInput.value = getTodayDate();
            projectEndInput.value = '';
            projectAllocationInput.value = '25';

            // Show charge-back options if there are pre-project allocations
            if (eng.preProject && eng.preProject.allocations && eng.preProject.allocations.length > 0) {
                chargeBackOptions.style.display = 'block';
                // Reset to original mode
                selectChargeBackMode('original');
            } else {
                chargeBackOptions.style.display = 'none';
            }

            promoteProjectModal.classList.remove('hidden');
        }

        function closePromoteProjectModal() {
            promoteProjectModal.classList.add('hidden');
            state.promoteProjectModalOpen = false;
            state.promoteEngagementIndex = null;
        }

        function selectChargeBackMode(mode) {
            state.selectedChargeBackMode = mode;

            // Update UI
            document.querySelectorAll('.chargeback-mode-option').forEach(opt => {
                opt.classList.remove('selected');
                const radio = opt.querySelector('input[type="radio"]');
                if (radio && radio.value === mode) {
                    opt.classList.add('selected');
                    radio.checked = true;
                }
            });
        }

        function confirmPromoteToProject() {
            if (state.promoteEngagementIndex === null) return;

            const eng = state.engagements[state.promoteEngagementIndex];
            const formalizedAt = projectFormalizedInput.value;
            const projectCode = projectCodeInput.value.trim();
            const fundingSource = projectFundingInput.value.trim();
            const startDate = projectStartInput.value;
            const endDate = projectEndInput.value;
            const allocation = parseInt(projectAllocationInput.value) || 25;

            if (!formalizedAt || !startDate) {
                alert('Please fill in the formalization date and project start date');
                return;
            }

            // Process charge-back for pre-project allocations
            const chargeBackRecords = [];
            if (eng.preProject && eng.preProject.allocations && state.selectedChargeBackMode !== 'none') {
                eng.preProject.allocations.forEach(alloc => {
                    if (!alloc.chargedToProject && alloc.month < startDate.substring(0, 7)) {
                        const chargedPercentage = state.selectedChargeBackMode === 'project_rate'
                            ? allocation
                            : alloc.percentage;

                        chargeBackRecords.push({
                            originalMonth: alloc.month,
                            originalPercentage: alloc.percentage,
                            chargedPercentage: chargedPercentage,
                            chargedAt: new Date().toISOString(),
                            notes: `Charged via ${state.selectedChargeBackMode} mode`
                        });

                        // Mark original allocation as charged
                        alloc.chargedToProject = true;
                        alloc.chargedAt = new Date().toISOString();
                    }
                });
            }

            // Update engagement to project
            eng.type = 'project';
            eng.project = {
                formalizedAt: formalizedAt,
                projectCode: projectCode || null,
                fundingSource: fundingSource || null,
                timeline: {
                    startDate: startDate,
                    endDate: endDate || null,
                    actualEndDate: null,
                    allocations: [{
                        periodStart: startDate,
                        periodEnd: endDate || startDate,
                        percentage: allocation,
                        status: 'active'
                    }]
                },
                preProjectMonthsCharged: chargeBackRecords
            };

            closePromoteProjectModal();
            renderEngagements();

            // Refresh side panel if open
            if (state.sidePanelOpen && state.selectedEngagementIndex === state.promoteEngagementIndex) {
                openSidePanel(state.promoteEngagementIndex);
            }

            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Revert pre-project back to engagement
        function revertToEngagement(index) {
            const eng = state.engagements[index];
            if (eng.type !== 'pre-project') return;

            if (!confirm('Are you sure you want to revert this pre-project back to an engagement? All pre-project allocation data will be lost.')) {
                return;
            }

            eng.type = 'engagement';
            eng.preProject = null;

            renderEngagements();

            // Refresh side panel if open
            if (state.sidePanelOpen && state.selectedEngagementIndex === index) {
                openSidePanel(index);
            }

            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Complete project
        function completeProject(index) {
            const eng = state.engagements[index];
            if (eng.type !== 'project' || eng.status !== 'active') return;

            eng.status = 'completed';
            if (eng.project && eng.project.timeline) {
                eng.project.timeline.actualEndDate = getTodayDate();
            }

            // Mark all active allocations as completed
            if (eng.project && eng.project.timeline && eng.project.timeline.allocations) {
                eng.project.timeline.allocations.forEach(alloc => {
                    if (alloc.status === 'active' || alloc.status === 'planned') {
                        alloc.status = 'completed';
                    }
                });
            }

            renderEngagements();

            // Refresh side panel if open
            if (state.sidePanelOpen && state.selectedEngagementIndex === index) {
                openSidePanel(index);
            }

            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Open delete confirmation modal
        function openDeleteConfirmation(index) {
            state.deleteEngagementIndex = index;
            state.confirmModalOpen = true;

            const opp = state.engagements[index];
            confirmMessage.textContent = `Are you sure you want to delete "${opp.name}"? This action cannot be undone.`;

            confirmModal.classList.remove('hidden');
        }

        // Close confirmation modal
        function closeConfirmModal() {
            confirmModal.classList.add('hidden');
            state.confirmModalOpen = false;
            state.deleteEngagementIndex = null;
        }

        // Confirm and execute engagement deletion
        function confirmDeleteEngagement() {
            if (state.deleteEngagementIndex === null) return;

            const oppId = state.engagements[state.deleteEngagementIndex].id;

            // Remove engagement link from all associated todos
            state.todos.forEach(todo => {
                if (todo.engagementId === oppId) {
                    todo.engagementId = null;
                }
            });

            // Remove the engagement
            state.engagements.splice(state.deleteEngagementIndex, 1);

            // Close side panel if the deleted engagement was open
            if (state.sidePanelOpen && state.selectedEngagementIndex === state.deleteEngagementIndex) {
                closeSidePanel();
            } else if (state.sidePanelOpen && state.selectedEngagementIndex > state.deleteEngagementIndex) {
                // Adjust index if needed
                state.selectedEngagementIndex--;
            }

            // Close confirmation modal
            closeConfirmModal();

            // Re-render both lists
            renderEngagements();
            renderTodos();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // =============================================
        // Cancel Engagement Functions
        // =============================================

        // Open cancel confirmation modal
        function openCancelConfirmation(index, skipTodoCheck = false) {
            const opp = state.engagements[index];

            // Check for linked undone todos (unless we already handled them)
            if (!skipTodoCheck) {
                const undoneTodos = state.todos.filter(t =>
                    t.engagementId === opp.id && !t.completed && !t.dropped
                );

                if (undoneTodos.length > 0) {
                    // Show todo action modal to handle linked todos
                    openTodoActionModal(index, 'cancel');
                    return;
                }
            }

            // No linked todos or already handled - show cancel reason modal
            state.cancelEngagementIndex = index;
            state.cancelModalOpen = true;

            cancelOppName.textContent = `"${opp.name}"`;
            cancelReason.value = '';

            cancelModal.classList.remove('hidden');
            setTimeout(() => cancelReason.focus(), 100);
        }

        // Close cancel modal
        function closeCancelModal() {
            cancelModal.classList.add('hidden');
            state.cancelModalOpen = false;
            state.cancelEngagementIndex = null;
            cancelReason.value = '';
        }

        // Confirm and execute engagement cancellation
        function confirmCancelEngagement() {
            if (state.cancelEngagementIndex === null) return;

            const reason = cancelReason.value.trim();
            if (!reason) {
                cancelReason.focus();
                return;
            }

            const opp = state.engagements[state.cancelEngagementIndex];

            // Initialize comments array if not exists (for backwards compatibility)
            if (!opp.comments) {
                opp.comments = [];
            }

            // Add cancellation comment
            opp.comments.push({
                text: reason,
                timestamp: new Date().toISOString(),
                type: 'cancellation'
            });

            // Set status to dropped (new lifecycle model)
            opp.status = 'dropped';

            // Refresh comments in side panel if open
            if (state.sidePanelOpen && state.selectedEngagementIndex === state.cancelEngagementIndex) {
                renderCommentsInPanel(opp);
            }

            // Close cancel modal
            closeCancelModal();

            // Re-render engagements and todos list
            renderEngagements();
            renderTodos();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // ========================================
        // TODO ACTION MODAL (for Close/Cancel with linked todos)
        // ========================================

        // Get linked undone todos for an engagement
        function getLinkedUndoneTodos(engagementId) {
            return state.todos.filter(t =>
                t.engagementId === engagementId && !t.completed && !t.dropped
            );
        }

        // Open Todo Action Modal
        function openTodoActionModal(index, actionType) {
            const opp = state.engagements[index];
            const undoneTodos = getLinkedUndoneTodos(opp.id);

            state.todoActionModalOpen = true;
            state.todoActionEngagementIndex = index;
            state.todoActionType = actionType;

            todoActionModalTitle.textContent = actionType === 'close'
                ? 'Close Engagement'
                : 'Cancel Engagement';
            todoActionEngName.textContent = `"${opp.name}"`;
            todoActionCount.textContent = `${undoneTodos.length} linked todo${undoneTodos.length !== 1 ? 's' : ''} will be affected`;

            todoActionModal.classList.remove('hidden');
        }

        // Close Todo Action Modal
        function closeTodoActionModal() {
            todoActionModal.classList.add('hidden');
            state.todoActionModalOpen = false;
            state.todoActionEngagementIndex = null;
            state.todoActionType = null;
        }

        // Todo Action: Complete all linked todos
        function todoActionComplete() {
            if (state.todoActionEngagementIndex === null) return;

            const opp = state.engagements[state.todoActionEngagementIndex];
            const now = new Date().toISOString();

            // Complete all linked undone todos
            state.todos.forEach(todo => {
                if (todo.engagementId === opp.id && !todo.completed && !todo.dropped) {
                    todo.completed = true;
                    todo.completedAt = now;
                    todo.updatedAt = now;
                }
            });

            // Continue with the close/cancel action
            finishEngagementAction();
        }

        // Todo Action: Drop all linked todos
        function todoActionDrop() {
            if (state.todoActionEngagementIndex === null) return;

            const opp = state.engagements[state.todoActionEngagementIndex];
            const now = new Date().toISOString();

            // Drop all linked undone todos
            state.todos.forEach(todo => {
                if (todo.engagementId === opp.id && !todo.completed && !todo.dropped) {
                    todo.dropped = true;
                    todo.droppedAt = now;
                    todo.updatedAt = now;
                }
            });

            // Continue with the close/cancel action
            finishEngagementAction();
        }

        // Todo Action: Delete all linked todos
        function todoActionDelete() {
            if (state.todoActionEngagementIndex === null) return;

            const opp = state.engagements[state.todoActionEngagementIndex];

            // Delete all linked undone todos
            state.todos = state.todos.filter(todo =>
                !(todo.engagementId === opp.id && !todo.completed && !todo.dropped)
            );

            // Continue with the close/cancel action
            finishEngagementAction();
        }

        // Finish the engagement close/cancel action after handling todos
        function finishEngagementAction() {
            const index = state.todoActionEngagementIndex;
            const actionType = state.todoActionType;

            closeTodoActionModal();

            if (actionType === 'close') {
                // Direct close without modal
                const opp = state.engagements[index];
                opp.status = 'closed';
            } else if (actionType === 'cancel') {
                // Open cancel modal for reason (skip todo check since we just handled them)
                openCancelConfirmation(index, true);
                return; // Don't save or render yet - wait for cancel confirmation
            }

            renderEngagements();
            renderTodos();
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Format datetime for display
        function formatDateTime(isoString) {
            const date = new Date(isoString);
            const options = {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            };
            return date.toLocaleString('en-US', options);
        }

        // Render comments in side panel
        function renderCommentsInPanel(opp) {
            // Initialize comments array if not exists
            const comments = opp.comments || [];

            if (comments.length === 0) {
                panelComments.innerHTML = '<p class="no-comments">No comments yet</p>';
                return;
            }

            panelComments.innerHTML = comments.map((comment, index) => {
                const isCancellation = comment.type === 'cancellation';
                const badge = isCancellation ? '<span class="comment-badge cancellation">Cancellation</span>' : '';
                return `
                    <div class="comment-item ${isCancellation ? 'cancellation' : ''}">
                        <div class="comment-header">
                            <div class="comment-timestamp">${formatDateTime(comment.timestamp)}${badge}</div>
                            <button class="comment-delete-btn" onclick="deleteComment(${index})" title="Delete comment">&times;</button>
                        </div>
                        <div class="comment-text">${escapeHtml(comment.text)}</div>
                    </div>
                `;
            }).join('');
        }

        // Add a new comment to the current engagement
        function addComment() {
            if (state.selectedEngagementIndex === null) return;

            const text = commentInput.value.trim();
            if (!text) return;

            const opp = state.engagements[state.selectedEngagementIndex];

            // Initialize comments array if not exists
            if (!opp.comments) {
                opp.comments = [];
            }

            // Add new standard comment
            opp.comments.push({
                text: text,
                timestamp: new Date().toISOString(),
                type: 'standard'
            });

            // Clear input
            commentInput.value = '';

            // Re-render comments
            renderCommentsInPanel(opp);
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Delete a comment from the current engagement
        function deleteComment(commentIndex) {
            if (state.selectedEngagementIndex === null) return;

            const opp = state.engagements[state.selectedEngagementIndex];
            if (!opp || !opp.comments || commentIndex < 0 || commentIndex >= opp.comments.length) return;

            // Remove the comment
            opp.comments.splice(commentIndex, 1);

            // Re-render comments
            renderCommentsInPanel(opp);
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // =============================================
        // Autocomplete Functions for Todo-Engagement Linking
        // =============================================

        // Filter engagements based on search query
        function filterEngagements(query) {
            if (!query || query.trim() === '') return [];
            const lowerQuery = query.toLowerCase().trim();
            return state.engagements.filter(opp => {
                const nameMatches = opp.name.toLowerCase().includes(lowerQuery);
                if (!nameMatches) return false;

                // Filter out closed and dropped engagements unless exact match
                const isClosedOrDropped = opp.status === 'closed' || opp.status === 'dropped';
                if (isClosedOrDropped) {
                    // Only show if exact match (case insensitive)
                    return opp.name.toLowerCase() === lowerQuery;
                }
                return true;
            });
        }

        // Render autocomplete dropdown
        function renderAutocompleteDropdown(query) {
            const matches = filterEngagements(query);
            engagementDropdown.innerHTML = '';

            if (matches.length > 0) {
                matches.forEach((opp, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.setAttribute('data-index', index);
                    item.setAttribute('data-id', opp.id);
                    item.innerHTML = `
                        <div class="autocomplete-item-name">${escapeHtml(opp.name)}</div>
                        ${opp.contact ? `<div class="autocomplete-item-contact">${escapeHtml(opp.contact)}</div>` : ''}
                    `;
                    item.onclick = () => selectEngagement(opp);
                    engagementDropdown.appendChild(item);
                });
            } else if (query && query.trim() !== '') {
                // Show hint to create new
                const hint = document.createElement('div');
                hint.className = 'autocomplete-empty';
                hint.textContent = 'No matches found';
                engagementDropdown.appendChild(hint);

                const createHint = document.createElement('div');
                createHint.className = 'autocomplete-create-hint';
                createHint.textContent = 'Press Enter to create new engagement';
                engagementDropdown.appendChild(createHint);
            }

            // Update highlight
            state.autocompleteHighlightIndex = -1;
            updateAutocompleteHighlight();
        }

        // Update autocomplete item highlight
        function updateAutocompleteHighlight() {
            const items = engagementDropdown.querySelectorAll('.autocomplete-item');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.autocompleteHighlightIndex);
            });
        }

        // Select an engagement from dropdown
        function selectEngagement(opp) {
            state.selectedEngagementId = opp.id;
            state.pendingEngagement = null;
            todoEngagementInput.value = opp.name;
            todoEngagementClear.classList.add('visible');
            closeAutocompleteDropdown();
            closeInlineOppForm();
        }

        // Clear engagement selection
        function clearEngagementSelection() {
            state.selectedEngagementId = null;
            state.pendingEngagement = null;
            todoEngagementInput.value = '';
            todoEngagementClear.classList.remove('visible');
            closeAutocompleteDropdown();
            closeInlineOppForm();
        }

        // Open autocomplete dropdown
        function openAutocompleteDropdown() {
            state.autocompleteOpen = true;
            engagementDropdown.classList.add('open');
        }

        // Close autocomplete dropdown
        function closeAutocompleteDropdown() {
            state.autocompleteOpen = false;
            state.autocompleteHighlightIndex = -1;
            engagementDropdown.classList.remove('open');
        }

        // Update Todo Save button state based on inline forms
        function updateTodoSaveButtonState() {
            const isInlineFormOpen = state.inlineEngFormOpen || state.inlineEngPersonFormOpen;

            if (isInlineFormOpen) {
                todoSaveBtn.disabled = true;
                todoSaveBtn.classList.add('btn-disabled');
                todoSaveWrapper.setAttribute('data-tooltip', 'Complete or cancel the inline form first');
            } else {
                todoSaveBtn.disabled = false;
                todoSaveBtn.classList.remove('btn-disabled');
                todoSaveWrapper.removeAttribute('data-tooltip');
            }
        }

        // Toggle tabindex on focusable elements inside a form container
        // When enabled=false, sets tabindex=-1 to remove from tab order
        // When enabled=true, removes tabindex to restore default tab behavior
        function setFormTabIndex(formElement, enabled, excludeSelector = null) {
            if (!formElement) return; // Guard against null elements
            const focusables = formElement.querySelectorAll('input, button, select, textarea, [tabindex]');
            focusables.forEach(el => {
                // Skip elements that match the exclude selector
                if (excludeSelector && el.closest(excludeSelector)) return;

                if (enabled) {
                    el.removeAttribute('tabindex');
                } else {
                    el.setAttribute('tabindex', '-1');
                }
            });
        }

        // Open inline engagement form with slide animation
        function openInlineEngForm(name) {
            state.inlineEngFormOpen = true;
            updateTodoSaveButtonState();
            inlineEngName.value = name;
            inlineEngDescription.value = '';
            inlineEngStartDate.value = getTodayDate();
            inlineEngContact.value = '';
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;
            inlineEngContactClear.classList.remove('visible');
            closeAutocompleteDropdown();

            // Expand dialog horizontally
            todoModalContent.classList.add('expanded');
            todoFormColumns.classList.add('expanded');
            todoFormLeft.classList.add('disabled');
            todoFormRight.classList.add('animate-in');

            // Enable tab navigation for right panel, but exclude nested person form
            setFormTabIndex(todoFormRight, true, '#inline-eng-person-form');

            // Disable tab navigation for left form (except engagement field which shows selection)
            setFormTabIndex(todoFormLeft, false);

            // Focus on description after animation (150ms as per spec)
            setTimeout(() => inlineEngDescription.focus(), 150);
        }

        // Close inline engagement form
        function closeInlineOppForm() {
            state.inlineEngFormOpen = false;
            updateTodoSaveButtonState();

            // Also close nested person form if open
            if (state.inlineEngPersonFormOpen) {
                closeInlineOppPersonForm();
            }

            // Collapse dialog horizontally
            todoModalContent.classList.remove('expanded');
            todoFormColumns.classList.remove('expanded');
            todoFormLeft.classList.remove('disabled');
            todoFormRight.classList.remove('animate-in');

            // Disable tab navigation for all elements inside right panel
            setFormTabIndex(todoFormRight, false);

            // Re-enable tab navigation for left form
            setFormTabIndex(todoFormLeft, true);
        }

        // Cancel inline engagement creation
        function cancelInlineEngagement() {
            state.pendingEngagement = null;
            todoEngagementInput.value = '';
            todoEngagementClear.classList.remove('visible');
            closeInlineOppForm();
            // Focus back to engagement field
            setTimeout(() => todoEngagementInput.focus(), 150);
        }

        // Confirm inline engagement creation
        function confirmInlineEngagement() {
            const name = inlineEngName.value.trim();
            if (!name) return;

            // Store pending engagement data (will be created when todo is saved)
            state.pendingEngagement = {
                name: name,
                description: inlineEngDescription.value.trim(),
                startDate: inlineEngStartDate.value,
                contact: inlineEngContact.value.trim(),
                // Include person data for the contact
                contactPersonId: state.selectedInlineOppPersonId,
                pendingPerson: state.pendingInlineOppPerson
            };

            // Update UI to show it's selected
            todoEngagementInput.value = name + ' (new)';
            todoEngagementClear.classList.add('visible');
            closeInlineOppForm();
            // Focus on Tags field after collapse
            setTimeout(() => todoTagInput.focus(), 150);
        }

        // Handle autocomplete input events
        todoEngagementInput.addEventListener('input', (e) => {
            const query = e.target.value;

            // Reset selection when typing
            state.selectedEngagementId = null;
            state.pendingEngagement = null;

            // Show/hide clear button
            todoEngagementClear.classList.toggle('visible', query.length > 0);

            // Close inline form if open
            if (state.inlineEngFormOpen) {
                closeInlineOppForm();
            }

            // Render and open dropdown
            if (query.trim() !== '') {
                renderAutocompleteDropdown(query);
                openAutocompleteDropdown();
                // Auto-highlight first match when typing
                const matches = filterEngagements(query);
                if (matches.length > 0) {
                    state.autocompleteHighlightIndex = 0;
                    updateAutocompleteHighlight();
                }
            } else {
                closeAutocompleteDropdown();
            }
        });

        // Handle autocomplete keyboard navigation
        todoEngagementInput.addEventListener('keydown', (e) => {
            const items = engagementDropdown.querySelectorAll('.autocomplete-item');
            const matches = filterEngagements(todoEngagementInput.value);
            const query = todoEngagementInput.value.trim();

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.autocompleteOpen && items.length > 0) {
                    state.autocompleteHighlightIndex = Math.min(state.autocompleteHighlightIndex + 1, items.length - 1);
                    updateAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.autocompleteOpen && items.length > 0) {
                    state.autocompleteHighlightIndex = Math.max(state.autocompleteHighlightIndex - 1, 0);
                    updateAutocompleteHighlight();
                }
            } else if (e.key === 'Tab' && !e.shiftKey) {
                // Tab behavior (forward only, let Shift+Tab work naturally):
                // 1. If matches exist, select first/highlighted and move to Tags
                // 2. If no matches but text entered, open inline creation
                // 3. If no text, natural tab
                if (matches.length > 0) {
                    e.preventDefault();
                    const indexToSelect = state.autocompleteHighlightIndex >= 0 ? state.autocompleteHighlightIndex : 0;
                    selectEngagement(matches[indexToSelect]);
                    todoTagInput.focus();
                } else if (query && !state.inlineEngFormOpen) {
                    e.preventDefault();
                    openInlineEngForm(query);
                }
                // If no text entered, let Tab naturally move to next control
            } else if (e.key === 'Enter') {
                e.preventDefault();

                // Check for exact match (case-insensitive)
                const exactMatch = matches.find(opp => opp.name.toLowerCase() === query.toLowerCase());

                if (state.autocompleteHighlightIndex >= 0 && matches.length > 0) {
                    // Select highlighted item
                    selectEngagement(matches[state.autocompleteHighlightIndex]);
                } else if (exactMatch) {
                    // Exact match - select it and move to next field
                    selectEngagement(exactMatch);
                    todoTagInput.focus();
                } else if (query && !state.inlineEngFormOpen) {
                    // Partial match or no matches - open inline creation form
                    openInlineEngForm(query);
                }
            } else if (e.key === 'Escape') {
                if (state.autocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeAutocompleteDropdown();
                }
            }
        });

        // Handle inline engagement description Enter key - move to Contact field
        inlineEngDescription.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                // Move focus to Contact field and scroll
                inlineEngContact.focus();
                setTimeout(() => {
                    inlineEngContact.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        });

        // Handle inline engagement name Enter key - move to Description field
        inlineEngName.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                inlineEngDescription.focus();
            }
        });

        // Handle inline engagement start date Enter key - move to Contact field
        inlineEngStartDate.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                inlineEngContact.focus();
                setTimeout(() => {
                    inlineEngContact.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        });

        // =============================================
        // People Management Functions
        // =============================================

        // Render people list
        function renderPeople() {
            peopleList.innerHTML = '';

            if (state.people.length === 0) {
                // Show empty state
                peopleList.classList.add('hidden');
                peopleEmptyState.classList.remove('hidden');
                peopleShortcutHintFloating.classList.add('hidden');
                rolesSection.classList.add('hidden');
            } else {
                // Show people list
                peopleList.classList.remove('hidden');
                peopleEmptyState.classList.add('hidden');
                peopleShortcutHintFloating.classList.remove('hidden');

                state.people.forEach((person, index) => {
                    const personItem = document.createElement('div');
                    personItem.className = 'person-item';

                    const roleName = person.roleId ? getRoleName(person.roleId) : '';

                    personItem.innerHTML = `
                        <div class="person-info">
                            <div class="person-name">${escapeHtml(person.name)}</div>
                            ${roleName ? `<span class="person-role-badge">${escapeHtml(roleName)}</span>` : ''}
                        </div>
                        <div class="person-actions">
                            <button class="action-btn" onclick="event.stopPropagation(); openPersonModal(${index})" title="Edit">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                            <button class="action-btn action-btn-danger" onclick="event.stopPropagation(); openDeletePersonModal(${index})" title="Delete">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                            </button>
                        </div>
                    `;

                    peopleList.appendChild(personItem);
                });

                // Show roles section if there are roles
                if (state.roles.length > 0) {
                    rolesSection.classList.remove('hidden');
                    renderRoles();
                } else {
                    rolesSection.classList.add('hidden');
                }
            }

            saveData();
        }

        // Render roles list
        function renderRoles() {
            rolesList.innerHTML = '';
            state.roles.forEach(role => {
                const roleTag = document.createElement('span');
                roleTag.className = 'role-tag';
                roleTag.textContent = role.name;
                rolesList.appendChild(roleTag);
            });
        }

        // Render tags list in Settings
        function renderTags() {
            tagsList.innerHTML = '';

            if (state.tags.length === 0) {
                // Show empty state
                tagsList.classList.add('hidden');
                tagsEmptyState.classList.remove('hidden');
                tagsShortcutHintFloating.classList.add('hidden');
            } else {
                // Show tags list
                tagsList.classList.remove('hidden');
                tagsEmptyState.classList.add('hidden');
                tagsShortcutHintFloating.classList.remove('hidden');

                state.tags.forEach((tag, index) => {
                    const tagItem = document.createElement('div');
                    tagItem.className = 'tag-item';

                    tagItem.innerHTML = `
                        <div class="tag-info">
                            <div class="tag-color-preview" style="background-color: ${tag.color}"></div>
                            <div class="tag-name">${escapeHtml(tag.name)}</div>
                        </div>
                        <div class="tag-actions">
                            <button class="action-btn" onclick="event.stopPropagation(); openTagModal(${index})" title="Edit">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                            <button class="action-btn action-btn-danger" onclick="event.stopPropagation(); deleteTag(${index})" title="Delete">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                            </button>
                        </div>
                    `;

                    tagsList.appendChild(tagItem);
                });
            }

            saveData();
        }

        // Open tag modal
        function openTagModal(tagIndex = null) {
            state.tagModalOpen = true;
            state.editingTagIndex = tagIndex;

            if (tagIndex !== null) {
                // Edit mode
                const tag = state.tags[tagIndex];
                tagModalTitle.textContent = 'Edit Tag';
                tagNameInput.value = tag.name;
                tagColorInput.value = tag.color;
                updateColorPreview(tag.color);
            } else {
                // Create mode
                tagModalTitle.textContent = 'New Tag';
                tagNameInput.value = '';
                tagColorInput.value = '#F59E0B';
                updateColorPreview('#F59E0B');
            }

            tagModal.classList.remove('hidden');
            setTimeout(() => tagNameInput.focus(), 100);
        }

        // Close tag modal
        function closeTagModal() {
            state.tagModalOpen = false;
            state.editingTagIndex = null;
            tagModal.classList.add('hidden');
            tagForm.reset();
        }

        // Update color preview
        function updateColorPreview(color) {
            tagColorPreview.style.backgroundColor = color;
            tagColorValue.textContent = color.toUpperCase();
        }

        // Save tag
        function saveTag(e) {
            e.preventDefault();

            const name = tagNameInput.value.trim();
            if (!name) return;

            const color = tagColorInput.value;

            if (state.editingTagIndex !== null) {
                // Update existing tag
                state.tags[state.editingTagIndex].name = name;
                state.tags[state.editingTagIndex].color = color;
            } else {
                // Create new tag
                const newTag = {
                    id: generateId(),
                    name: name,
                    color: color,
                    createdAt: new Date().toISOString()
                };
                state.tags.push(newTag);
            }

            closeTagModal();
            renderTags();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Delete tag
        function deleteTag(index) {
            const tag = state.tags[index];

            // Remove tag from all todos and engagements
            state.todos.forEach(todo => {
                if (todo.tagIds) {
                    todo.tagIds = todo.tagIds.filter(id => id !== tag.id);
                }
            });
            state.engagements.forEach(opp => {
                if (opp.tagIds) {
                    opp.tagIds = opp.tagIds.filter(id => id !== tag.id);
                }
            });

            // Remove tag from array
            state.tags.splice(index, 1);
            renderTags();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Get tag by ID
        function getTagById(tagId) {
            return state.tags.find(t => t.id === tagId);
        }

        // Get or create tag by name (for inline creation)
        function getOrCreateTag(tagName) {
            if (!tagName || tagName.trim() === '') return null;
            const trimmedName = tagName.trim();
            const existingTag = state.tags.find(t => t.name.toLowerCase() === trimmedName.toLowerCase());
            if (existingTag) return existingTag.id;

            // Create new tag with default color
            const defaultColors = ['#F59E0B', '#10B981', '#3B82F6', '#8B5CF6', '#EC4899', '#EF4444'];
            const colorIndex = state.tags.length % defaultColors.length;
            const newTag = {
                id: generateId(),
                name: trimmedName,
                color: defaultColors[colorIndex],
                createdAt: new Date().toISOString()
            };
            state.tags.push(newTag);
            return newTag.id;
        }

        // ==================== Tag Input Functions ====================

        // Render selected tags for Todo form
        function renderTodoSelectedTags() {
            todoSelectedTags.innerHTML = '';
            state.selectedTodoTagIds.forEach(tagId => {
                const tag = getTagById(tagId);
                if (tag) {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'selected-tag';
                    tagEl.style.backgroundColor = tag.color;
                    tagEl.innerHTML = `
                        ${escapeHtml(tag.name)}
                        <button type="button" class="remove-tag" onclick="removeTodoTag('${tagId}')">×</button>
                    `;
                    todoSelectedTags.appendChild(tagEl);
                }
            });
        }

        // Render selected tags for Engagement form
        function renderOppSelectedTags() {
            engSelectedTags.innerHTML = '';
            state.selectedOppTagIds.forEach(tagId => {
                const tag = getTagById(tagId);
                if (tag) {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'selected-tag';
                    tagEl.style.backgroundColor = tag.color;
                    tagEl.innerHTML = `
                        ${escapeHtml(tag.name)}
                        <button type="button" class="remove-tag" onclick="removeOppTag('${tagId}')">×</button>
                    `;
                    engSelectedTags.appendChild(tagEl);
                }
            });
        }

        // Remove tag from Todo
        function removeTodoTag(tagId) {
            state.selectedTodoTagIds = state.selectedTodoTagIds.filter(id => id !== tagId);
            renderTodoSelectedTags();
        }

        // Remove tag from Engagement
        function removeOppTag(tagId) {
            state.selectedOppTagIds = state.selectedOppTagIds.filter(id => id !== tagId);
            renderOppSelectedTags();
        }

        // Render tag dropdown for Todo
        function renderTodoTagDropdown(filter = '') {
            todoTagDropdown.innerHTML = '';
            const filterLower = filter.toLowerCase();

            // Filter tags not already selected and matching the filter
            const availableTags = state.tags.filter(tag =>
                !state.selectedTodoTagIds.includes(tag.id) &&
                tag.name.toLowerCase().includes(filterLower)
            );

            availableTags.forEach((tag, index) => {
                const item = document.createElement('div');
                item.className = 'tag-dropdown-item' + (index === state.todoTagHighlightIndex ? ' highlighted' : '');
                item.innerHTML = `
                    <span class="tag-color-dot" style="background-color: ${tag.color}"></span>
                    ${escapeHtml(tag.name)}
                `;
                item.onclick = () => selectTodoTag(tag.id);
                todoTagDropdown.appendChild(item);
            });

            // Show "create new" option if filter doesn't match existing tag exactly
            if (filter.trim() && !state.tags.some(t => t.name.toLowerCase() === filterLower)) {
                const createItem = document.createElement('div');
                createItem.className = 'tag-dropdown-item create-new' + (availableTags.length === state.todoTagHighlightIndex ? ' highlighted' : '');
                createItem.innerHTML = `
                    <span class="tag-color-dot"></span>
                    Create "${escapeHtml(filter.trim())}"
                `;
                createItem.onclick = () => createAndSelectTodoTag(filter.trim());
                todoTagDropdown.appendChild(createItem);
            }

            if (todoTagDropdown.children.length > 0) {
                todoTagDropdown.classList.add('open');
                state.todoTagDropdownOpen = true;
            } else {
                todoTagDropdown.classList.remove('open');
                state.todoTagDropdownOpen = false;
            }
        }

        // Render tag dropdown for Engagement
        function renderOppTagDropdown(filter = '') {
            engTagDropdown.innerHTML = '';
            const filterLower = filter.toLowerCase();

            // Filter tags not already selected and matching the filter
            const availableTags = state.tags.filter(tag =>
                !state.selectedOppTagIds.includes(tag.id) &&
                tag.name.toLowerCase().includes(filterLower)
            );

            availableTags.forEach((tag, index) => {
                const item = document.createElement('div');
                item.className = 'tag-dropdown-item' + (index === state.oppTagHighlightIndex ? ' highlighted' : '');
                item.innerHTML = `
                    <span class="tag-color-dot" style="background-color: ${tag.color}"></span>
                    ${escapeHtml(tag.name)}
                `;
                item.onclick = () => selectOppTag(tag.id);
                engTagDropdown.appendChild(item);
            });

            // Show "create new" option if filter doesn't match existing tag exactly
            if (filter.trim() && !state.tags.some(t => t.name.toLowerCase() === filterLower)) {
                const createItem = document.createElement('div');
                createItem.className = 'tag-dropdown-item create-new' + (availableTags.length === state.oppTagHighlightIndex ? ' highlighted' : '');
                createItem.innerHTML = `
                    <span class="tag-color-dot"></span>
                    Create "${escapeHtml(filter.trim())}"
                `;
                createItem.onclick = () => createAndSelectOppTag(filter.trim());
                engTagDropdown.appendChild(createItem);
            }

            if (engTagDropdown.children.length > 0) {
                engTagDropdown.classList.add('open');
                state.engTagDropdownOpen = true;
            } else {
                engTagDropdown.classList.remove('open');
                state.engTagDropdownOpen = false;
            }
        }

        // Select existing tag for Todo
        function selectTodoTag(tagId) {
            if (!state.selectedTodoTagIds.includes(tagId)) {
                state.selectedTodoTagIds.push(tagId);
                renderTodoSelectedTags();
            }
            todoTagInput.value = '';
            closeTodoTagDropdown();
        }

        // Select existing tag for Engagement
        function selectOppTag(tagId) {
            if (!state.selectedOppTagIds.includes(tagId)) {
                state.selectedOppTagIds.push(tagId);
                renderOppSelectedTags();
            }
            engTagInput.value = '';
            closeOppTagDropdown();
        }

        // Create new tag and select it for Todo
        function createAndSelectTodoTag(name) {
            const tagId = getOrCreateTag(name);
            if (tagId) {
                selectTodoTag(tagId);
            }
        }

        // Create new tag and select it for Engagement
        function createAndSelectOppTag(name) {
            const tagId = getOrCreateTag(name);
            if (tagId) {
                selectOppTag(tagId);
            }
        }

        // Close Todo tag dropdown
        function closeTodoTagDropdown() {
            todoTagDropdown.classList.remove('open');
            state.todoTagDropdownOpen = false;
            state.todoTagHighlightIndex = -1;
        }

        // Close Engagement tag dropdown
        function closeOppTagDropdown() {
            engTagDropdown.classList.remove('open');
            state.engTagDropdownOpen = false;
            state.oppTagHighlightIndex = -1;
        }

        // Setup tag input event listeners
        function setupTagInputListeners() {
            // Todo tag input
            todoTagInput.addEventListener('input', (e) => {
                renderTodoTagDropdown(e.target.value);
                // Auto-highlight first item when typing
                const items = todoTagDropdown.querySelectorAll('.tag-dropdown-item');
                if (items.length > 0) {
                    state.todoTagHighlightIndex = 0;
                    renderTodoTagDropdown(e.target.value);
                } else {
                    state.todoTagHighlightIndex = -1;
                }
            });

            todoTagInput.addEventListener('focus', () => {
                // Only show dropdown if there's text (don't auto-open on focus)
                if (todoTagInput.value.trim()) {
                    renderTodoTagDropdown(todoTagInput.value);
                }
            });

            todoTagInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    e.stopPropagation();
                    closeTodoTagDropdown();
                    todoTagInput.value = '';
                    return;
                }

                if (e.key === 'Tab' && !e.shiftKey) {
                    // Tab (forward only): only select if user typed text
                    const items = todoTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (todoTagInput.value.trim() && items.length > 0) {
                        // User typed text and there are matches - select the highlighted/first item
                        e.preventDefault();
                        const indexToSelect = state.todoTagHighlightIndex >= 0 ? state.todoTagHighlightIndex : 0;
                        items[indexToSelect].click();
                    } else if (todoTagInput.value.trim()) {
                        // User typed text but no matches - create new tag
                        e.preventDefault();
                        createAndSelectTodoTag(todoTagInput.value.trim());
                    }
                    // If no text entered, let Tab naturally move to Save button
                    return;
                }

                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.stopPropagation(); // Prevent form submission
                    const items = todoTagDropdown.querySelectorAll('.tag-dropdown-item');
                    const inputText = todoTagInput.value.trim();

                    if (inputText) {
                        // Check for exact match first
                        const exactMatch = Array.from(items).find(item =>
                            item.textContent.trim().toLowerCase() === inputText.toLowerCase()
                        );

                        if (exactMatch) {
                            // Exact match found - select it
                            exactMatch.click();
                        } else if (items.length > 0 && state.todoTagHighlightIndex >= 0) {
                            // Highlighted item exists - select it
                            items[state.todoTagHighlightIndex].click();
                        } else {
                            // No exact match - create new tag
                            createAndSelectTodoTag(inputText);
                        }
                        // Focus Save button after tag action
                        closeTodoTagDropdown();
                        document.getElementById('todo-save-btn').focus();
                    }
                    return;
                }

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const items = todoTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (items.length > 0) {
                        state.todoTagHighlightIndex = Math.min(state.todoTagHighlightIndex + 1, items.length - 1);
                        renderTodoTagDropdown(todoTagInput.value);
                    }
                    return;
                }

                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (state.todoTagHighlightIndex > 0) {
                        state.todoTagHighlightIndex--;
                        renderTodoTagDropdown(todoTagInput.value);
                    }
                    return;
                }
            });

            // Engagement tag input
            engTagInput.addEventListener('input', (e) => {
                renderOppTagDropdown(e.target.value);
                // Auto-highlight first item when typing
                const items = engTagDropdown.querySelectorAll('.tag-dropdown-item');
                if (items.length > 0) {
                    state.oppTagHighlightIndex = 0;
                    renderOppTagDropdown(e.target.value);
                } else {
                    state.oppTagHighlightIndex = -1;
                }
            });

            engTagInput.addEventListener('focus', () => {
                renderOppTagDropdown(engTagInput.value);
            });

            engTagInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    e.stopPropagation();
                    closeOppTagDropdown();
                    engTagInput.value = '';
                    return;
                }

                if (e.key === 'Tab' && !e.shiftKey) {
                    // Tab (forward only) with dropdown open: select first/highlighted item and move on
                    const items = engTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (items.length > 0) {
                        e.preventDefault();
                        const indexToSelect = state.oppTagHighlightIndex >= 0 ? state.oppTagHighlightIndex : 0;
                        items[indexToSelect].click();
                    } else if (engTagInput.value.trim()) {
                        // If text entered but no matches, create tag and move on
                        e.preventDefault();
                        createAndSelectOppTag(engTagInput.value.trim());
                    }
                    // If nothing, let Tab naturally move to next control
                    return;
                }

                if (e.key === 'Enter') {
                    e.preventDefault();
                    const items = engTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (items.length > 0) {
                        const indexToSelect = state.oppTagHighlightIndex >= 0 ? state.oppTagHighlightIndex : 0;
                        items[indexToSelect].click();
                    } else if (engTagInput.value.trim()) {
                        createAndSelectOppTag(engTagInput.value.trim());
                    }
                    return;
                }

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const items = engTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (items.length > 0) {
                        state.oppTagHighlightIndex = Math.min(state.oppTagHighlightIndex + 1, items.length - 1);
                        renderOppTagDropdown(engTagInput.value);
                    }
                    return;
                }

                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (state.oppTagHighlightIndex > 0) {
                        state.oppTagHighlightIndex--;
                        renderOppTagDropdown(engTagInput.value);
                    }
                    return;
                }
            });

            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#todo-tag-container')) {
                    closeTodoTagDropdown();
                }
                if (!e.target.closest('#opp-tag-container')) {
                    closeOppTagDropdown();
                }
            });
        }

        // Initialize tag input listeners
        setupTagInputListeners();

        // ==================== End Tag Input Functions ====================

        // Get role name by ID
        function getRoleName(roleId) {
            const role = state.roles.find(r => r.id === roleId);
            return role ? role.name : '';
        }

        // Get or create role by name
        function getOrCreateRole(roleName) {
            if (!roleName || roleName.trim() === '') return null;
            const trimmedName = roleName.trim();
            const existingRole = state.roles.find(r => r.name.toLowerCase() === trimmedName.toLowerCase());
            if (existingRole) return existingRole.id;

            // Create new role
            const newRole = {
                id: generateId(),
                name: trimmedName
            };
            state.roles.push(newRole);
            return newRole.id;
        }

        // Open person modal
        function openPersonModal(personIndex = null) {
            state.personModalOpen = true;
            state.editingPersonIndex = personIndex;
            state.roleAutocompleteOpen = false;
            state.roleAutocompleteHighlightIndex = -1;

            personRoleInput.value = '';
            personRoleClear.classList.remove('visible');
            roleDropdown.classList.remove('open');

            if (personIndex !== null) {
                // Edit mode
                const person = state.people[personIndex];
                personModalTitle.textContent = 'Edit Person';
                personNameInput.value = person.name;
                if (person.roleId) {
                    personRoleInput.value = getRoleName(person.roleId);
                    personRoleClear.classList.add('visible');
                }
            } else {
                // Create mode
                personModalTitle.textContent = 'New Person';
                personNameInput.value = '';
            }

            personModal.classList.remove('hidden');
            setTimeout(() => personNameInput.focus(), 100);
        }

        // Close person modal
        function closePersonModal() {
            state.personModalOpen = false;
            state.editingPersonIndex = null;
            state.roleAutocompleteOpen = false;
            personModal.classList.add('hidden');
            personForm.reset();
            roleDropdown.classList.remove('open');
        }

        // Save person
        function savePerson(e) {
            e.preventDefault();

            const name = personNameInput.value.trim();
            if (!name) return;

            const roleName = personRoleInput.value.trim();
            const roleId = getOrCreateRole(roleName);

            if (state.editingPersonIndex !== null) {
                // Update existing person
                state.people[state.editingPersonIndex].name = name;
                state.people[state.editingPersonIndex].roleId = roleId;
            } else {
                // Create new person
                const newPerson = {
                    id: generateId(),
                    name: name,
                    roleId: roleId
                };
                state.people.push(newPerson);
            }

            closePersonModal();
            renderPeople();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
        }

        // Open delete person modal
        function openDeletePersonModal(index) {
            state.deletePersonIndex = index;
            const person = state.people[index];
            deletePersonName.textContent = person.name;
            deletePersonModal.classList.remove('hidden');
        }

        // Close delete person modal
        function closeDeletePersonModal() {
            state.deletePersonIndex = null;
            deletePersonModal.classList.add('hidden');
        }

        // Confirm delete person
        function confirmDeletePerson() {
            if (state.deletePersonIndex !== null) {
                const personId = state.people[state.deletePersonIndex].id;

                // Remove person from array
                state.people.splice(state.deletePersonIndex, 1);

                // Update engagements that referenced this person
                state.engagements.forEach(opp => {
                    if (opp.contactId === personId) {
                        opp.contactId = null;
                        opp.contact = ''; // Clear the text contact as well
                    }
                });

                closeDeletePersonModal();
                renderPeople();
                renderEngagements();
                // Auto-save to IndexedDB
                saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));
            }
        }

        // Clear person role input
        function clearPersonRole() {
            personRoleInput.value = '';
            personRoleClear.classList.remove('visible');
            roleDropdown.classList.remove('open');
            state.roleAutocompleteOpen = false;
        }

        // Filter roles based on search query
        function filterRoles(query) {
            if (!query || query.trim() === '') return [];
            const lowerQuery = query.toLowerCase().trim();
            return state.roles.filter(role =>
                role.name.toLowerCase().includes(lowerQuery)
            );
        }

        // Render role autocomplete dropdown
        function renderRoleDropdown(query) {
            const matches = filterRoles(query);
            roleDropdown.innerHTML = '';

            if (matches.length > 0) {
                matches.forEach((role, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.setAttribute('data-index', index);
                    item.setAttribute('data-id', role.id);
                    item.innerHTML = `<div class="autocomplete-item-name">${escapeHtml(role.name)}</div>`;
                    item.onclick = () => selectRole(role);
                    roleDropdown.appendChild(item);
                });
            } else if (query && query.trim() !== '') {
                // Show create option
                const createItem = document.createElement('div');
                createItem.className = 'autocomplete-item autocomplete-create';
                createItem.innerHTML = `
                    <div class="autocomplete-item-name">Create "${escapeHtml(query.trim())}"</div>
                `;
                createItem.onclick = () => {
                    personRoleInput.value = query.trim();
                    personRoleClear.classList.add('visible');
                    closeRoleDropdown();
                };
                roleDropdown.appendChild(createItem);
            }

            state.roleAutocompleteHighlightIndex = -1;
            updateRoleAutocompleteHighlight();
        }

        // Update role autocomplete highlight
        function updateRoleAutocompleteHighlight() {
            const items = roleDropdown.querySelectorAll('.autocomplete-item');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.roleAutocompleteHighlightIndex);
            });
        }

        // Select role from autocomplete
        function selectRole(role) {
            personRoleInput.value = role.name;
            personRoleClear.classList.add('visible');
            closeRoleDropdown();
        }

        // Open role dropdown
        function openRoleDropdown() {
            state.roleAutocompleteOpen = true;
            roleDropdown.classList.add('open');
        }

        // Close role dropdown
        function closeRoleDropdown() {
            state.roleAutocompleteOpen = false;
            roleDropdown.classList.remove('open');
            state.roleAutocompleteHighlightIndex = -1;
        }

        // Person role input event handlers
        personRoleInput.addEventListener('input', (e) => {
            const query = e.target.value;

            // Show/hide clear button
            personRoleClear.classList.toggle('visible', query.length > 0);

            // Render and open dropdown
            if (query.trim() !== '') {
                renderRoleDropdown(query);
                openRoleDropdown();
                // Auto-highlight first match when typing
                const matches = filterRoles(query);
                if (matches.length > 0) {
                    state.roleAutocompleteHighlightIndex = 0;
                    updateRoleAutocompleteHighlight();
                }
            } else {
                closeRoleDropdown();
            }
        });

        personRoleInput.addEventListener('focus', () => {
            const query = personRoleInput.value;
            if (query.trim() !== '') {
                renderRoleDropdown(query);
                openRoleDropdown();
            }
        });

        personRoleInput.addEventListener('keydown', (e) => {
            const items = roleDropdown.querySelectorAll('.autocomplete-item');
            const matches = filterRoles(personRoleInput.value);

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.roleAutocompleteOpen && items.length > 0) {
                    state.roleAutocompleteHighlightIndex = Math.min(state.roleAutocompleteHighlightIndex + 1, items.length - 1);
                    updateRoleAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.roleAutocompleteOpen && items.length > 0) {
                    state.roleAutocompleteHighlightIndex = Math.max(state.roleAutocompleteHighlightIndex - 1, 0);
                    updateRoleAutocompleteHighlight();
                }
            } else if (e.key === 'Tab' && !e.shiftKey) {
                // Tab (forward only) with dropdown open: select first/highlighted match and move on
                if (state.roleAutocompleteOpen && matches.length > 0) {
                    e.preventDefault();
                    const indexToSelect = state.roleAutocompleteHighlightIndex >= 0 ? state.roleAutocompleteHighlightIndex : 0;
                    selectRole(matches[indexToSelect]);
                }
                // If no matches, let Tab naturally move to next control
            } else if (e.key === 'Enter') {
                e.preventDefault();
                const query = personRoleInput.value.trim();

                if (state.roleAutocompleteOpen && matches.length > 0) {
                    // Select first/highlighted item
                    const indexToSelect = state.roleAutocompleteHighlightIndex >= 0 ? state.roleAutocompleteHighlightIndex : 0;
                    selectRole(matches[indexToSelect]);
                } else if (query) {
                    // Just accept the typed value
                    personRoleClear.classList.add('visible');
                    closeRoleDropdown();
                }
            } else if (e.key === 'Escape') {
                if (state.roleAutocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeRoleDropdown();
                }
            }
        });

        // =============================================
        // Contact Autocomplete Functions (Engagement Modal)
        // =============================================

        // Filter people based on search query
        function filterPeople(query) {
            if (!query || query.trim() === '') return [];
            const lowerQuery = query.toLowerCase().trim();
            return state.people.filter(person =>
                person.name.toLowerCase().includes(lowerQuery)
            );
        }

        // Render contact autocomplete dropdown
        function renderContactDropdown(query) {
            const matches = filterPeople(query);
            contactDropdown.innerHTML = '';

            if (matches.length > 0) {
                matches.forEach((person, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.setAttribute('data-index', index);
                    item.setAttribute('data-id', person.id);
                    const roleName = person.roleId ? getRoleName(person.roleId) : '';
                    item.innerHTML = `
                        <div class="autocomplete-item-name">${escapeHtml(person.name)}</div>
                        ${roleName ? `<div class="autocomplete-item-contact">${escapeHtml(roleName)}</div>` : ''}
                    `;
                    item.onclick = () => selectContact(person);
                    contactDropdown.appendChild(item);
                });
            } else if (query && query.trim() !== '') {
                // Show create option
                const createItem = document.createElement('div');
                createItem.className = 'autocomplete-item autocomplete-create';
                createItem.innerHTML = `
                    <div class="autocomplete-item-name">Create "${escapeHtml(query.trim())}" - press Enter</div>
                `;
                createItem.onclick = () => openInlinePersonForm(query.trim());
                contactDropdown.appendChild(createItem);
            }

            state.contactAutocompleteHighlightIndex = -1;
            updateContactAutocompleteHighlight();
        }

        // Update contact autocomplete highlight
        function updateContactAutocompleteHighlight() {
            const items = contactDropdown.querySelectorAll('.autocomplete-item');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.contactAutocompleteHighlightIndex);
            });
        }

        // Select contact from autocomplete
        function selectContact(person) {
            state.selectedPersonId = person.id;
            state.pendingPerson = null;
            engContactInput.value = person.name;
            engContactClear.classList.add('visible');
            closeContactDropdown();
            closeInlinePersonForm();
        }

        // Open contact dropdown
        function openContactDropdown() {
            state.contactAutocompleteOpen = true;
            contactDropdown.classList.add('open');
        }

        // Close contact dropdown
        function closeContactDropdown() {
            state.contactAutocompleteOpen = false;
            contactDropdown.classList.remove('open');
            state.contactAutocompleteHighlightIndex = -1;
        }

        // Clear engagement contact input
        function clearOppContact() {
            state.selectedPersonId = null;
            state.pendingPerson = null;
            engContactInput.value = '';
            engContactClear.classList.remove('visible');
            closeContactDropdown();
            closeInlinePersonForm();
        }

        // Open inline person form
        function openInlinePersonForm(name) {
            state.inlinePersonFormOpen = true;
            inlinePersonName.value = name;
            inlinePersonRole.value = '';
            inlinePersonForm.classList.add('open');
            closeContactDropdown();

            // Enable tab navigation for person form elements
            setFormTabIndex(inlinePersonForm, true);

            // Focus on role after animation
            setTimeout(() => inlinePersonRole.focus(), 350);
        }

        // Close inline person form
        function closeInlinePersonForm() {
            state.inlinePersonFormOpen = false;
            inlinePersonForm.classList.remove('open');

            // Disable tab navigation for person form elements
            setFormTabIndex(inlinePersonForm, false);
        }

        // Cancel inline person creation
        function cancelInlinePerson() {
            state.pendingPerson = null;
            engContactInput.value = '';
            engContactClear.classList.remove('visible');
            closeInlinePersonForm();
        }

        // Confirm inline person creation
        function confirmInlinePerson() {
            const name = inlinePersonName.value.trim();
            const role = inlinePersonRole.value.trim();

            if (!name) {
                inlinePersonName.focus();
                return;
            }

            // Store as pending person
            state.pendingPerson = { name, role };
            state.selectedPersonId = null;

            // Update the contact input to show the name
            engContactInput.value = name;
            engContactClear.classList.add('visible');

            closeInlinePersonForm();
        }

        // ============================================
        // Inline Person Creation within Inline Engagement (Todo Modal)
        // ============================================

        // Render inline opp contact dropdown
        function renderInlineOppContactDropdown(query) {
            const matches = filterPeople(query);
            inlineEngContactDropdown.innerHTML = '';

            if (matches.length === 0) {
                const item = document.createElement('div');
                item.className = 'autocomplete-item autocomplete-no-match';
                item.textContent = `Press Enter to create "${query}"`;
                inlineEngContactDropdown.appendChild(item);
            } else {
                matches.forEach((person, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.dataset.index = index;

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'autocomplete-item-name';
                    nameSpan.textContent = person.name;
                    item.appendChild(nameSpan);

                    if (person.roleId) {
                        const role = state.roles.find(r => r.id === person.roleId);
                        if (role) {
                            const roleSpan = document.createElement('span');
                            roleSpan.className = 'autocomplete-item-role';
                            roleSpan.textContent = role.name;
                            item.appendChild(roleSpan);
                        }
                    }

                    item.addEventListener('click', () => selectInlineOppContact(person));
                    inlineEngContactDropdown.appendChild(item);
                });
            }
        }

        // Open inline opp contact dropdown
        function openInlineOppContactDropdown() {
            state.inlineEngContactAutocompleteOpen = true;
            state.inlineEngContactAutocompleteHighlightIndex = -1;
            inlineEngContactDropdown.classList.add('open');
        }

        // Close inline opp contact dropdown
        function closeInlineOppContactDropdown() {
            state.inlineEngContactAutocompleteOpen = false;
            state.inlineEngContactAutocompleteHighlightIndex = -1;
            inlineEngContactDropdown.classList.remove('open');
        }

        // Select contact for inline engagement
        function selectInlineOppContact(person) {
            state.selectedInlineOppPersonId = person.id;
            state.pendingInlineOppPerson = null;
            inlineEngContact.value = person.name;
            inlineEngContactClear.classList.add('visible');
            closeInlineOppContactDropdown();
            closeInlineOppPersonForm();
        }

        // Clear inline opp contact selection
        function clearInlineOppContact() {
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;
            inlineEngContact.value = '';
            inlineEngContactClear.classList.remove('visible');
            closeInlineOppContactDropdown();
            closeInlineOppPersonForm();
        }

        // Open inline person form within inline engagement
        function openInlineOppPersonForm(name) {
            state.inlineEngPersonFormOpen = true;
            updateTodoSaveButtonState();
            inlineEngPersonName.value = name;
            inlineEngPersonRole.value = '';
            inlineEngPersonForm.classList.add('open');
            closeInlineOppContactDropdown();

            // Disable engagement form buttons while person form is open
            if (inlineEngAddBtn) inlineEngAddBtn.disabled = true;
            if (inlineEngCancelBtn) inlineEngCancelBtn.disabled = true;

            // Enable tab navigation for person form elements
            setFormTabIndex(inlineEngPersonForm, true);

            // Focus on role field after animation
            setTimeout(() => {
                inlineEngPersonRole.focus();
            }, 150);
        }

        // Close inline person form within inline engagement
        function closeInlineOppPersonForm() {
            state.inlineEngPersonFormOpen = false;
            inlineEngPersonForm.classList.remove('open');
            updateTodoSaveButtonState();

            // Re-enable engagement form buttons
            if (inlineEngAddBtn) inlineEngAddBtn.disabled = false;
            if (inlineEngCancelBtn) inlineEngCancelBtn.disabled = false;

            // Disable tab navigation for person form elements
            setFormTabIndex(inlineEngPersonForm, false);
        }

        // Cancel inline person creation within inline engagement
        function cancelInlineOppPerson() {
            state.pendingInlineOppPerson = null;
            inlineEngContact.value = '';
            inlineEngContactClear.classList.remove('visible');
            closeInlineOppPersonForm();
            // Focus back to contact field
            setTimeout(() => inlineEngContact.focus(), 150);
        }

        // Confirm inline person creation within inline engagement
        function confirmInlineOppPerson() {
            const name = inlineEngPersonName.value.trim();
            const role = inlineEngPersonRole.value.trim();

            if (!name) {
                inlineEngPersonName.focus();
                return;
            }

            // Store as pending person for inline engagement
            state.pendingInlineOppPerson = { name, role };
            state.selectedInlineOppPersonId = null;

            // Update the contact input to show the name
            inlineEngContact.value = name;
            inlineEngContactClear.classList.add('visible');

            closeInlineOppPersonForm();
            // Focus on engagement Add button after collapse
            setTimeout(() => {
                if (inlineEngAddBtn) inlineEngAddBtn.focus();
            }, 150);
        }

        // Update autocomplete highlight for inline opp contact
        function updateInlineOppContactAutocompleteHighlight() {
            const items = inlineEngContactDropdown.querySelectorAll('.autocomplete-item:not(.autocomplete-no-match)');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.inlineEngContactAutocompleteHighlightIndex);
            });
        }

        // Inline opp contact input event handlers
        inlineEngContact.addEventListener('input', (e) => {
            const query = e.target.value;

            // Clear selected person if user types
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;

            // Show/hide clear button
            inlineEngContactClear.classList.toggle('visible', query.length > 0);

            // Close inline form if open
            if (state.inlineEngPersonFormOpen) {
                closeInlineOppPersonForm();
            }

            // Render and open dropdown
            if (query.trim() !== '') {
                renderInlineOppContactDropdown(query);
                openInlineOppContactDropdown();
            } else {
                closeInlineOppContactDropdown();
            }
        });

        inlineEngContact.addEventListener('focus', (e) => {
            const query = inlineEngContact.value;
            if (query.trim() !== '' && !state.selectedInlineOppPersonId && !state.pendingInlineOppPerson) {
                renderInlineOppContactDropdown(query);
                openInlineOppContactDropdown();
            }
            // Scroll to make contact field visible
            setTimeout(() => {
                inlineEngContact.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
        });

        inlineEngContact.addEventListener('keydown', (e) => {
            const items = inlineEngContactDropdown.querySelectorAll('.autocomplete-item:not(.autocomplete-no-match)');
            const matches = filterPeople(inlineEngContact.value);
            const query = inlineEngContact.value.trim();

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.inlineEngContactAutocompleteOpen && items.length > 0) {
                    state.inlineEngContactAutocompleteHighlightIndex = Math.min(state.inlineEngContactAutocompleteHighlightIndex + 1, items.length - 1);
                    updateInlineOppContactAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.inlineEngContactAutocompleteOpen && items.length > 0) {
                    state.inlineEngContactAutocompleteHighlightIndex = Math.max(state.inlineEngContactAutocompleteHighlightIndex - 1, 0);
                    updateInlineOppContactAutocompleteHighlight();
                }
            } else if (e.key === 'Tab' && !e.shiftKey) {
                // Tab (forward only) behavior:
                // 1. If contact already selected, confirm inline opp and move to Tags
                // 2. If matches exist, select first/highlighted and move on
                // 3. If no matches but text entered, open inline person form
                // 4. If no text, natural tab
                if (state.selectedInlineOppPersonId || state.pendingInlineOppPerson) {
                    // Contact is selected - confirm the inline engagement and move to Tags
                    e.preventDefault();
                    confirmInlineEngagement();
                    todoTagInput.focus();
                } else if (matches.length > 0) {
                    e.preventDefault();
                    const indexToSelect = state.inlineEngContactAutocompleteHighlightIndex >= 0 ? state.inlineEngContactAutocompleteHighlightIndex : 0;
                    selectInlineOppContact(matches[indexToSelect]);
                } else if (query && !state.inlineEngPersonFormOpen) {
                    e.preventDefault();
                    openInlineOppPersonForm(query);
                }
                // If no text entered, let Tab naturally move
            } else if (e.key === 'Enter') {
                e.preventDefault();

                // Check for exact match (case-insensitive)
                const exactMatch = matches.find(person => person.name.toLowerCase() === query.toLowerCase());

                if (state.selectedInlineOppPersonId || state.pendingInlineOppPerson) {
                    // Contact is selected - confirm the inline engagement and move to Tags
                    confirmInlineEngagement();
                    todoTagInput.focus();
                } else if (state.inlineEngContactAutocompleteHighlightIndex >= 0 && matches.length > 0) {
                    // Select highlighted item
                    selectInlineOppContact(matches[state.inlineEngContactAutocompleteHighlightIndex]);
                } else if (exactMatch) {
                    // Exact match - select it
                    selectInlineOppContact(exactMatch);
                } else if (query && !state.inlineEngPersonFormOpen) {
                    // Partial match or no matches - open inline creation form for new person
                    openInlineOppPersonForm(query);
                } else if (state.inlineEngContactAutocompleteOpen) {
                    // Just close dropdown
                    closeInlineOppContactDropdown();
                }
            } else if (e.key === 'Escape') {
                if (state.inlineEngContactAutocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeInlineOppContactDropdown();
                }
            }
        });

        // Handle inline eng person form Enter key - confirm person AND engagement
        inlineEngPersonForm.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target.tagName === 'INPUT') {
                e.preventDefault();
                // First confirm the person
                confirmInlineOppPerson();
                // Then confirm the engagement (which will include the person)
                confirmInlineEngagement();
            }
        });

        // Contact input event handlers
        engContactInput.addEventListener('input', (e) => {
            const query = e.target.value;

            // Clear selected person if user types
            state.selectedPersonId = null;
            state.pendingPerson = null;

            // Show/hide clear button
            engContactClear.classList.toggle('visible', query.length > 0);

            // Close inline form if open
            if (state.inlinePersonFormOpen) {
                closeInlinePersonForm();
            }

            // Render and open dropdown
            if (query.trim() !== '') {
                renderContactDropdown(query);
                openContactDropdown();
                // Auto-highlight first match when typing
                const matches = filterPeople(query);
                if (matches.length > 0) {
                    state.contactAutocompleteHighlightIndex = 0;
                    updateContactAutocompleteHighlight();
                }
            } else {
                closeContactDropdown();
            }
        });

        engContactInput.addEventListener('focus', () => {
            const query = engContactInput.value;
            if (query.trim() !== '' && !state.selectedPersonId && !state.pendingPerson) {
                renderContactDropdown(query);
                openContactDropdown();
            }
        });

        engContactInput.addEventListener('keydown', (e) => {
            const items = contactDropdown.querySelectorAll('.autocomplete-item');
            const matches = filterPeople(engContactInput.value);
            const query = engContactInput.value.trim();

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.contactAutocompleteOpen && items.length > 0) {
                    state.contactAutocompleteHighlightIndex = Math.min(state.contactAutocompleteHighlightIndex + 1, items.length - 1);
                    updateContactAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.contactAutocompleteOpen && items.length > 0) {
                    state.contactAutocompleteHighlightIndex = Math.max(state.contactAutocompleteHighlightIndex - 1, 0);
                    updateContactAutocompleteHighlight();
                }
            } else if (e.key === 'Tab' && !e.shiftKey) {
                // Tab (forward only) behavior:
                // 1. If matches exist, select first/highlighted and move to Tags
                // 2. If no matches but text entered, open inline creation
                // 3. If no text, natural tab
                if (matches.length > 0) {
                    e.preventDefault();
                    const indexToSelect = state.contactAutocompleteHighlightIndex >= 0 ? state.contactAutocompleteHighlightIndex : 0;
                    selectContact(matches[indexToSelect]);
                    engTagInput.focus();
                } else if (query && !state.inlinePersonFormOpen) {
                    e.preventDefault();
                    openInlinePersonForm(query);
                }
                // If no text entered, let Tab naturally move to next control
            } else if (e.key === 'Enter') {
                e.preventDefault();

                // Check for exact match (case-insensitive)
                const exactMatch = matches.find(person => person.name.toLowerCase() === query.toLowerCase());

                if (state.contactAutocompleteHighlightIndex >= 0 && matches.length > 0) {
                    // Select highlighted item
                    selectContact(matches[state.contactAutocompleteHighlightIndex]);
                } else if (exactMatch) {
                    // Exact match - select it and move to next field
                    selectContact(exactMatch);
                    engTagInput.focus();
                } else if (query && !state.inlinePersonFormOpen) {
                    // Partial match or no matches - open inline creation form
                    openInlinePersonForm(query);
                }
            } else if (e.key === 'Escape') {
                if (state.contactAutocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeContactDropdown();
                }
            }
        });

        // Handle inline person form Enter key
        inlinePersonForm.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target.tagName === 'INPUT') {
                e.preventDefault();
                confirmInlinePerson();
            }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.autocomplete-wrapper') && state.autocompleteOpen) {
                closeAutocompleteDropdown();
            }
            if (!e.target.closest('.autocomplete-wrapper') && state.contactAutocompleteOpen) {
                closeContactDropdown();
            }
            if (!e.target.closest('.autocomplete-wrapper') && state.roleAutocompleteOpen) {
                closeRoleDropdown();
            }
            if (!e.target.closest('.autocomplete-wrapper') && state.inlineEngContactAutocompleteOpen) {
                closeInlineOppContactDropdown();
            }
        });

        // Add keyboard navigation (capture phase to intercept browser shortcuts)
        document.addEventListener('keydown', (e) => {
            // Skip if any modal is open and it's not Escape
            const anyModalOpen = state.modalOpen || state.engagementModalOpen || state.personModalOpen || state.blockReasonModalOpen || state.meetingModalOpen;

            // Handle Shift+Spacebar to focus search (Issue-59)
            // Only on Todos or Engagements page, no modals open, side panel not open
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.code === 'Space' &&
                state.currentPage === 'app' && (state.currentTab === 'home' || state.currentTab === 'engagements') &&
                !anyModalOpen && !state.sidePanelOpen) {
                e.preventDefault();
                focusSearch();
                return;
            }

            // Handle Shift+N to open todo modal (only on home tab)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'home' && !anyModalOpen) {
                e.preventDefault();
                openModal();
                return;
            }

            // Handle Shift+N to open engagement modal (only on engagements tab)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'engagements' && !anyModalOpen) {
                e.preventDefault();
                openEngagementModal();
                return;
            }

            // Handle Shift+N to open person modal (only on settings page with people section)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'settings' && state.settingsSection === 'people' && !anyModalOpen) {
                e.preventDefault();
                openPersonModal();
                return;
            }

            // Handle Shift+N to open tag modal (only on settings page with tags section)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'settings' && state.settingsSection === 'tags' && !anyModalOpen) {
                e.preventDefault();
                openTagModal();
                return;
            }

            // Handle Shift+M to open meeting modal (only on home tab) - Issue-80
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'm' &&
                state.currentPage === 'app' && state.currentTab === 'home' && !anyModalOpen) {
                e.preventDefault();
                openMeetingModal();
                return;
            }

            // Handle Escape key to close modals or side panel
            // Priority: innermost inline form first, then modals, then side panel
            if (e.key === 'Escape') {
                if (state.blockReasonModalOpen) {
                    e.preventDefault();
                    closeBlockReasonModal();
                    return;
                }
                if (state.cancelModalOpen) {
                    e.preventDefault();
                    closeCancelModal();
                    return;
                }
                if (state.confirmModalOpen) {
                    e.preventDefault();
                    closeConfirmModal();
                    return;
                }
                // Handle inline forms within todo modal (innermost first)
                if (state.modalOpen) {
                    // First check if person inline form is open within engagement inline
                    if (state.inlineEngPersonFormOpen) {
                        e.preventDefault();
                        cancelInlineOppPerson();
                        return;
                    }
                    // Then check if engagement inline form is open
                    if (state.inlineEngFormOpen) {
                        e.preventDefault();
                        cancelInlineEngagement();
                        return;
                    }
                    // Issue-101: In read-only mode, Escape closes the modal
                    // In edit mode, Escape does nothing (user must use Save/Cancel buttons)
                    if (state.modalReadOnly) {
                        e.preventDefault();
                        closeModal();
                        return;
                    }
                    // Edit mode - don't close on Escape
                    return;
                }
                if (state.engagementModalOpen) {
                    // Check for inline person form in engagement modal
                    if (state.inlinePersonFormOpen) {
                        e.preventDefault();
                        cancelInlinePerson();
                        return;
                    }
                    e.preventDefault();
                    closeEngagementModal();
                    return;
                }
                if (state.personModalOpen) {
                    e.preventDefault();
                    closePersonModal();
                    return;
                }
                if (state.tagModalOpen) {
                    e.preventDefault();
                    closeTagModal();
                    return;
                }
                if (state.meetingModalOpen) {
                    e.preventDefault();
                    closeMeetingModal();
                    return;
                }
                if (state.deletePersonIndex !== null) {
                    e.preventDefault();
                    closeDeletePersonModal();
                    return;
                }
                if (state.sidePanelOpen) {
                    e.preventDefault();
                    closeSidePanel();
                    return;
                }
                // Clear search if active or search input is focused (Issue-59)
                if (state.searchQuery || document.activeElement === globalSearchInput) {
                    e.preventDefault();
                    clearSearch();
                    return;
                }
            }

            // Landing page keyboard shortcuts
            if (state.currentPage === 'landing') {
                if (e.key === '1') {
                    startFromScratch();
                } else if (e.key === '2') {
                    continueWorking();
                }
            }
        }, true);  // Use capture phase to intercept before browser handles it

        // Migrate existing contacts to people
        function migrateContactsToPeople() {
            // Get all unique contacts from engagements that don't have a contactId
            const contactsToMigrate = new Map();

            state.engagements.forEach(opp => {
                if (opp.contact && !opp.contactId) {
                    const normalizedContact = opp.contact.trim().toLowerCase();
                    if (!contactsToMigrate.has(normalizedContact)) {
                        contactsToMigrate.set(normalizedContact, opp.contact.trim());
                    }
                }
            });

            // Create people for unique contacts
            contactsToMigrate.forEach((originalName, normalizedName) => {
                // Check if person already exists
                const existingPerson = state.people.find(p => p.name.toLowerCase() === normalizedName);
                if (!existingPerson) {
                    const newPerson = {
                        id: generateId(),
                        name: originalName,
                        roleId: null
                    };
                    state.people.push(newPerson);
                }
            });

            // Update engagements to reference the person
            state.engagements.forEach(opp => {
                if (opp.contact && !opp.contactId) {
                    const normalizedContact = opp.contact.trim().toLowerCase();
                    const person = state.people.find(p => p.name.toLowerCase() === normalizedContact);
                    if (person) {
                        opp.contactId = person.id;
                    }
                }
            });
        }

        // Migrate engagements to new lifecycle model
        function migrateEngagementLifecycle() {
            state.engagements.forEach(eng => {
                // Add type field if missing (default to 'engagement')
                if (!eng.type) {
                    eng.type = 'engagement';
                }

                // Migrate old status values to new model
                // Valid statuses: active, paused, completed, closed, dropped
                if (!['active', 'paused', 'completed', 'closed', 'dropped'].includes(eng.status)) {
                    // Map old statuses to new ones
                    const statusMap = {
                        'requested': 'active',
                        'open': 'active',
                        'closed': 'closed',
                        'cancelled': 'dropped'
                    };
                    eng.status = statusMap[eng.status] || 'active';
                }

                // Ensure preProject and project fields exist
                if (eng.preProject === undefined) {
                    eng.preProject = null;
                }
                if (eng.project === undefined) {
                    eng.project = null;
                }
            });
        }

        // Migrate existing engagement preProject/project data to new allocations format (Issue-57)
        function migrateEngagementAllocations() {
            state.engagements.forEach(eng => {
                // Check if this engagement already has an allocation entry
                const existingAllocation = getAllocationForEngagement(eng.id);
                if (existingAllocation) return; // Already migrated

                // Only migrate if there's preProject or project data to migrate
                if (!eng.preProject && !eng.project) return;

                const allocation = {
                    id: eng.id,
                    updatedAt: new Date().toISOString()
                };

                // Migrate preProject data
                if (eng.preProject && eng.preProject.allocations && eng.preProject.allocations.length > 0) {
                    const months = eng.preProject.allocations.map(a => a.month).sort();
                    const avgPercentage = Math.round(
                        eng.preProject.allocations.reduce((sum, a) => sum + (a.percentage || 0), 0) /
                        eng.preProject.allocations.length
                    );
                    allocation.preProject = {
                        allocationPercentage: avgPercentage || 25,
                        months: months
                    };
                }

                // Migrate project data
                if (eng.project && eng.project.timeline) {
                    const timeline = eng.project.timeline;
                    const avgPercentage = timeline.allocations && timeline.allocations.length > 0
                        ? Math.round(timeline.allocations.reduce((sum, a) => sum + (a.percentage || 0), 0) / timeline.allocations.length)
                        : 25;

                    // Convert dates to YYYY-MM format
                    const startMonth = timeline.startDate ? timeline.startDate.substring(0, 7) : null;
                    const endMonth = timeline.endDate ? timeline.endDate.substring(0, 7) : null;

                    if (startMonth && endMonth) {
                        allocation.project = {
                            allocationPercentage: avgPercentage,
                            startMonth: startMonth,
                            endMonth: endMonth
                        };
                    }
                }

                // Only add if there's actual allocation data
                if (allocation.preProject || allocation.project) {
                    state.allocations.push(allocation);
                }
            });
        }

        // ========================================
        // ALLOCATION HELPER FUNCTIONS (Issue-57)
        // ========================================

        // Get allocation for an engagement by ID
        function getAllocationForEngagement(engagementId) {
            return state.allocations.find(a => a.id === engagementId) || null;
        }

        // Save or update an allocation
        function saveAllocation(allocation) {
            const existingIndex = state.allocations.findIndex(a => a.id === allocation.id);
            allocation.updatedAt = new Date().toISOString();

            if (existingIndex >= 0) {
                state.allocations[existingIndex] = allocation;
            } else {
                state.allocations.push(allocation);
            }

            return saveStateToIndexedDB();
        }

        // Delete an allocation by engagement ID
        function deleteAllocation(engagementId) {
            const index = state.allocations.findIndex(a => a.id === engagementId);
            if (index >= 0) {
                state.allocations.splice(index, 1);
                return saveStateToIndexedDB();
            }
            return Promise.resolve();
        }

        // Get current month in YYYY-MM format
        function getCurrentMonth() {
            const now = new Date();
            return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        }

        // Check if a month is within an array of months (for pre-project with gaps)
        function isMonthInArray(month, monthsArray) {
            return monthsArray.includes(month);
        }

        // Check if a month is within a range (for project continuous range)
        function isMonthInRange(month, startMonth, endMonth) {
            return month >= startMonth && month <= endMonth;
        }

        // Get the display type for an engagement based on allocations and current date
        function getEngagementDisplayType(engagement) {
            const allocation = getAllocationForEngagement(engagement.id);
            const currentMonth = getCurrentMonth();

            if (!allocation) {
                return 'engagement';
            }

            // Check project allocation first (takes priority)
            if (allocation.project && allocation.project.startMonth && allocation.project.endMonth) {
                if (isMonthInRange(currentMonth, allocation.project.startMonth, allocation.project.endMonth)) {
                    return 'project';
                }
            }

            // Check pre-project allocation
            if (allocation.preProject && allocation.preProject.months && allocation.preProject.months.length > 0) {
                if (isMonthInArray(currentMonth, allocation.preProject.months)) {
                    return 'pre-project';
                }
            }

            // Has allocation but current month is not within any allocation period
            return 'engagement';
        }

        // Generate array of months between start and end (inclusive)
        function generateMonthRange(startMonth, endMonth) {
            const months = [];
            let current = startMonth;

            while (current <= endMonth) {
                months.push(current);
                // Increment month
                const [year, month] = current.split('-').map(Number);
                const nextMonth = month === 12 ? 1 : month + 1;
                const nextYear = month === 12 ? year + 1 : year;
                current = `${nextYear}-${String(nextMonth).padStart(2, '0')}`;
            }

            return months;
        }

        // Format month for display (e.g., "2025-01" -> "January")
        function formatMonthShort(monthStr) {
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const [year, month] = monthStr.split('-').map(Number);
            return monthNames[month - 1];
        }

        // Format month for display with year (e.g., "2025-01" -> "January, 2025")
        function formatMonthFull(monthStr) {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
            const [year, month] = monthStr.split('-').map(Number);
            return `${monthNames[month - 1]}, ${year}`;
        }

        // Get year from month string
        function getYearFromMonth(monthStr) {
            return monthStr.split('-')[0];
        }

        // ========================================
        // ALLOCATION TIMELINE BAR (Issue-69)
        // ========================================

        // Track timeline offsets for each engagement (not persisted)
        const engagementTimelineOffsets = {};

        // Render allocation timeline bar for engagement list (Issue-69)
        function renderAllocationTimelineBar(engagement) {
            const allocation = getAllocationForEngagement(engagement.id);
            if (!allocation) {
                return ''; // No allocation data, don't show timeline
            }

            // Collect all allocation months
            const preProjectMonths = allocation.preProject?.months || [];
            const projectMonths = (allocation.project?.startMonth && allocation.project?.endMonth)
                ? generateMonthRange(allocation.project.startMonth, allocation.project.endMonth)
                : [];

            // If no months at all, don't show
            if (preProjectMonths.length === 0 && projectMonths.length === 0) {
                return '';
            }

            // Create sets for quick lookup
            const preProjectSet = new Set(preProjectMonths);
            const projectSet = new Set(projectMonths);

            // Combine and sort all months
            const allMonths = [...new Set([...preProjectMonths, ...projectMonths])].sort();

            // Get offset for this engagement's timeline
            const offset = engagementTimelineOffsets[engagement.id] || 0;

            // Determine visible months (18 at a time) - Issue-72
            const visibleMonths = allMonths.slice(offset, offset + 18);
            const canScrollLeft = offset > 0;
            const canScrollRight = offset + 18 < allMonths.length;
            const needsArrows = allMonths.length > 18;

            // Build pebbles HTML
            const pebblesHtml = visibleMonths.map(month => {
                const isPreProject = preProjectSet.has(month);
                const isProject = projectSet.has(month);
                // Project takes priority if a month is in both
                const type = isProject ? 'project' : (isPreProject ? 'preproject' : 'empty');

                // Get percentage for display
                let pctLabel = '';
                if (isPreProject && !isProject && allocation.preProject?.allocationPercentage) {
                    pctLabel = `${allocation.preProject.allocationPercentage}%`;
                } else if (isProject) {
                    // Use project allocation percentage, default to 25% if not set
                    const projectPct = allocation.project?.allocationPercentage || 25;
                    pctLabel = `${projectPct}%`;
                }

                return `
                    <div class="allocation-pebble">
                        <div class="allocation-pebble-dot ${type}">${pctLabel}</div>
                        <div class="allocation-pebble-label">${formatMonthShort(month)}</div>
                    </div>
                `;
            }).join('');

            // Build arrow buttons if needed
            const leftArrow = needsArrows ? `
                <button class="allocation-timeline-nav-btn"
                        onclick="event.stopPropagation(); scrollEngagementTimeline('${engagement.id}', -1)"
                        ${canScrollLeft ? '' : 'disabled'}>
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="15 18 9 12 15 6"></polyline>
                    </svg>
                </button>
            ` : '';

            const rightArrow = needsArrows ? `
                <button class="allocation-timeline-nav-btn"
                        onclick="event.stopPropagation(); scrollEngagementTimeline('${engagement.id}', 1)"
                        ${canScrollRight ? '' : 'disabled'}>
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="9 18 15 12 9 6"></polyline>
                    </svg>
                </button>
            ` : '';

            return `
                <div class="allocation-timeline-bar" onclick="event.stopPropagation()">
                    ${leftArrow}
                    <div class="allocation-timeline-months">
                        ${pebblesHtml}
                    </div>
                    ${rightArrow}
                </div>
            `;
        }

        // Scroll engagement timeline (Issue-69)
        function scrollEngagementTimeline(engagementId, direction) {
            engagementTimelineOffsets[engagementId] = (engagementTimelineOffsets[engagementId] || 0) + direction;
            // Clamp to valid range
            const allocation = getAllocationForEngagement(engagementId);
            if (allocation) {
                const preProjectMonths = allocation.preProject?.months || [];
                const projectMonths = (allocation.project?.startMonth && allocation.project?.endMonth)
                    ? generateMonthRange(allocation.project.startMonth, allocation.project.endMonth)
                    : [];
                const allMonths = [...new Set([...preProjectMonths, ...projectMonths])].sort();
                const maxOffset = Math.max(0, allMonths.length - 18);
                engagementTimelineOffsets[engagementId] = Math.max(0, Math.min(engagementTimelineOffsets[engagementId], maxOffset));
            }
            renderEngagements();
        }

        // ========================================
        // SCORING ALGORITHM FUNCTIONS
        // ========================================

        function getDaysUntilDeadline(deadline, currentDate = new Date()) {
            const deadlineDate = new Date(deadline);
            const today = new Date(currentDate);

            // Reset to start of day for comparison
            today.setHours(0, 0, 0, 0);
            const deadlineDay = new Date(deadlineDate);
            deadlineDay.setHours(0, 0, 0, 0);

            const msPerDay = 24 * 60 * 60 * 1000;
            return Math.floor((deadlineDay - today) / msPerDay);
        }

        function calculateDeadlineScore(todo, currentDate = new Date()) {
            if (!todo.deadline) return 0;

            const daysUntilDue = getDaysUntilDeadline(todo.deadline, currentDate);

            if (daysUntilDue < 0) {
                // OVERDUE: 150 base + 10 per day overdue, max 200
                return Math.min(200, 150 + (Math.abs(daysUntilDue) * 10));
            }

            if (daysUntilDue === 0) return 140;  // Due today
            if (daysUntilDue === 1) return 120;  // Due tomorrow
            if (daysUntilDue <= 3) return 100 - (daysUntilDue * 10);  // 70-90
            if (daysUntilDue <= 7) return 70 - (daysUntilDue * 5);    // 35-55
            if (daysUntilDue <= 14) return 30 - (daysUntilDue - 7);   // 23-30

            return Math.max(0, 20 - (daysUntilDue - 14));  // Distant future
        }

        function calculatePriorityScore(todo) {
            const priority = todo.priority || DEFAULT_PRIORITY;
            const weight = PRIORITY_TAGS[priority]?.weight;
            return weight ?? PRIORITY_TAGS[DEFAULT_PRIORITY].weight;
        }

        function calculateStalenessBonus(todo, currentDate = new Date()) {
            if (!todo.createdAt) return 0;

            const created = new Date(todo.createdAt);
            const today = new Date(currentDate);
            const msPerDay = 24 * 60 * 60 * 1000;
            const daysOld = Math.floor((today - created) / msPerDay);

            if (daysOld <= 7) return 0;
            if (daysOld <= 14) return 10;
            if (daysOld <= 30) return 20;
            return 30;
        }

        function calculateUrgencyScore(todo, currentDate = new Date()) {
            const deadline = calculateDeadlineScore(todo, currentDate);
            const priority = calculatePriorityScore(todo);
            const staleness = calculateStalenessBonus(todo, currentDate);

            return {
                total: deadline + priority + staleness,
                breakdown: { deadline, priority, staleness }
            };
        }

        function getScoreClassification(score) {
            if (score >= 250) return { label: 'Critical', class: 'critical' };
            if (score >= 200) return { label: 'Must Do Today', class: 'high' };
            if (score >= 150) return { label: 'High Priority', class: 'high' };
            if (score >= 100) return { label: 'Should Do Soon', class: 'medium' };
            if (score >= 50) return { label: 'Plan Ahead', class: '' };
            return { label: 'Backlog', class: '' };
        }

        // ========================================
        // DAILY PLAN GENERATION
        // ========================================

        function classifyTodos(scored, currentDate = new Date()) {
            const today = new Date(currentDate);
            today.setHours(0, 0, 0, 0);

            return {
                overdue: scored.filter(s => {
                    if (!s.todo.deadline) return false;
                    const d = new Date(s.todo.deadline);
                    d.setHours(0, 0, 0, 0);
                    return d < today;
                }),
                dueToday: scored.filter(s => {
                    if (!s.todo.deadline) return false;
                    const d = new Date(s.todo.deadline);
                    d.setHours(0, 0, 0, 0);
                    return d.getTime() === today.getTime();
                }),
                upcoming: scored.filter(s => {
                    if (!s.todo.deadline) return true; // Include todos without deadlines
                    const d = new Date(s.todo.deadline);
                    d.setHours(0, 0, 0, 0);
                    return d > today;
                })
            };
        }

        function buildPlan(classified, effectiveMinutes, config) {
            const plan = {
                date: new Date(),
                availableMinutes: effectiveMinutes,
                allocatedMinutes: 0,
                sections: {
                    overdue: [],
                    mustDoToday: [],
                    recommended: [],
                    ifTimePermits: []
                },
                warnings: [],
                insights: []
            };

            let remainingMinutes = effectiveMinutes;

            // Add overdue (capped, always shown)
            const overdueToShow = classified.overdue.slice(0, config.maxOverdueToShow);
            for (const item of overdueToShow) {
                plan.sections.overdue.push(formatScheduledItem(item));
                plan.allocatedMinutes += item.minutes;
            }

            // Add due today (always shown)
            for (const item of classified.dueToday) {
                plan.sections.mustDoToday.push(formatScheduledItem(item));
                plan.allocatedMinutes += item.minutes;
            }

            // Calculate remaining capacity
            remainingMinutes = effectiveMinutes - plan.allocatedMinutes;

            // Fill recommended from upcoming, respecting capacity
            for (const item of classified.upcoming) {
                if (remainingMinutes >= item.minutes) {
                    plan.sections.recommended.push(formatScheduledItem(item));
                    remainingMinutes -= item.minutes;
                    plan.allocatedMinutes += item.minutes;
                } else if (item.score.total >= 100) {
                    // High priority but doesn't fit
                    plan.sections.ifTimePermits.push(formatScheduledItem(item));
                }
            }

            return plan;
        }

        function formatScheduledItem(item) {
            return {
                todo: item.todo,
                urgencyScore: item.score.total,
                scoreBreakdown: item.score.breakdown,
                estimatedMinutes: item.minutes,
                reasoning: generateReasoning(item)
            };
        }

        function generateReasoning(item) {
            const parts = [];
            const daysUntil = getDaysUntilDeadline(item.todo.deadline);

            // Deadline reasoning
            if (daysUntil < 0) {
                parts.push(`Overdue by ${Math.abs(daysUntil)} day(s)`);
            } else if (daysUntil === 0) {
                parts.push("Due today");
            } else if (daysUntil === 1) {
                parts.push("Due tomorrow");
            } else if (daysUntil <= 7) {
                parts.push(`Due in ${daysUntil} days`);
            }

            // Priority reasoning (only mention if not normal)
            const priority = item.todo.priority || DEFAULT_PRIORITY;
            if (priority && priority !== "normal") {
                const priorityTag = PRIORITY_TAGS[priority];
                if (priorityTag) {
                    parts.push(priorityTag.label);
                }
            }

            // Effort reasoning
            const effort = item.todo.effort || DEFAULT_EFFORT;
            if (effort === "very_low") {
                parts.push("Quick win");
            } else if (effort === "very_high") {
                parts.push("Requires full day");
            }

            return parts.join(" • ") || "Scheduled based on priority";
        }

        function generateDailyPlan(currentDate = new Date()) {
            const config = { ...DEFAULT_SETTINGS, ...state.settings };

            // Calculate effective work time
            const effectiveMinutes = Math.floor(
                config.workdayMinutes * (1 - config.bufferPercentage / 100)
            );

            // 1. Filter incomplete and non-dropped todos (excluding blocked)
            const incomplete = state.todos.filter(t => !t.completed && !t.dropped && !t.blocked);

            // 1b. Get blocked todos separately (Issue-67)
            const blockedTodos = state.todos.filter(t => t.blocked && !t.completed && !t.dropped);

            // 2. Score and sort active todos
            const scored = incomplete
                .map(todo => ({
                    todo,
                    score: calculateUrgencyScore(todo, currentDate),
                    minutes: EFFORT_CONFIG[todo.effort || DEFAULT_EFFORT]?.minutes || 240
                }))
                .sort((a, b) => b.score.total - a.score.total);

            // 2b. Create blocked items for display (Issue-67)
            const blockedItems = blockedTodos.map(todo => ({
                todo,
                urgencyScore: 0,
                scoreBreakdown: { deadline: 0, priority: 0, staleness: 0 },
                estimatedMinutes: EFFORT_CONFIG[todo.effort || DEFAULT_EFFORT]?.minutes || 240,
                reasoning: todo.blockedReason || 'Blocked'
            }));

            // 3. Classify by deadline status
            const classified = classifyTodos(scored, currentDate);

            // 4. Build the plan with time constraints
            const plan = buildPlan(classified, effectiveMinutes, config);

            // 4b. Add blocked section (Issue-67)
            plan.sections.blocked = blockedItems;

            // 5. Generate warnings and insights
            plan.warnings = generateWarnings(plan, scored, currentDate, config);
            plan.insights = generateInsights(plan, scored, currentDate);

            return plan;
        }

        // ========================================
        // WARNINGS AND INSIGHTS
        // ========================================

        function generateWarnings(plan, allScored, currentDate, config) {
            const warnings = [];

            // Check for overloaded day
            if (plan.allocatedMinutes > plan.availableMinutes) {
                const overloadHours = ((plan.allocatedMinutes - plan.availableMinutes) / 60).toFixed(1);
                warnings.push({
                    type: "overloaded",
                    severity: "critical",
                    message: `Today's critical items exceed available time by ${overloadHours} hours. Consider renegotiating deadlines or delegating.`
                });
            }

            // Check for large overdue backlog
            const totalOverdue = allScored.filter(s => getDaysUntilDeadline(s.todo.deadline) < 0).length;
            if (totalOverdue > config.maxOverdueToShow) {
                warnings.push({
                    type: "overdue_backlog",
                    severity: "warning",
                    message: `You have ${totalOverdue} overdue items total. Consider a backlog review session.`
                });
            }

            // Check for deadline cluster
            const next3Days = allScored.filter(s => {
                const d = getDaysUntilDeadline(s.todo.deadline);
                return d >= 0 && d <= 3;
            });
            const clusterMinutes = next3Days.reduce((sum, s) => sum + s.minutes, 0);

            if (clusterMinutes > config.workdayMinutes * 2) {
                const clusterHours = Math.round(clusterMinutes / 60);
                warnings.push({
                    type: "deadline_cluster",
                    severity: "warning",
                    message: `Heavy deadline cluster ahead: ${clusterHours} hours of work due in the next 3 days.`
                });
            }

            // Check for impossible single task
            const impossibleTask = allScored.find(s =>
                s.minutes > config.workdayMinutes && getDaysUntilDeadline(s.todo.deadline) <= 1
            );
            if (impossibleTask) {
                warnings.push({
                    type: "impossible_task",
                    severity: "critical",
                    message: `"${impossibleTask.todo.title}" requires ${(impossibleTask.minutes / 60).toFixed(1)} hours but is due very soon. Consider breaking it down.`
                });
            }

            return warnings;
        }

        function generateInsights(plan, allScored, currentDate) {
            const insights = [];

            // Light day - good opportunity
            const utilization = plan.availableMinutes > 0
                ? (plan.allocatedMinutes / plan.availableMinutes) * 100
                : 0;
            if (utilization < 50 && allScored.length > 0) {
                insights.push({
                    type: "light_day",
                    message: "Light day ahead! Good chance to get ahead on upcoming tasks or clear some backlog."
                });
            }

            // Quick wins available
            const quickWins = allScored.filter(s =>
                (s.todo.effort === "very_low") && s.score.total >= 50
            );
            if (quickWins.length >= 3) {
                insights.push({
                    type: "quick_wins",
                    message: `${quickWins.length} quick-win tasks available. Consider batching them to build momentum.`
                });
            }

            // All caught up
            if (plan.sections.overdue.length === 0 && plan.sections.mustDoToday.length === 0) {
                insights.push({
                    type: "caught_up",
                    message: "No overdue or urgent items! Great time to work on important-but-not-urgent tasks."
                });
            }

            // High effort concentration
            const highEffortToday = [...plan.sections.mustDoToday, ...plan.sections.recommended]
                .filter(s => s.todo.effort === "high" || s.todo.effort === "very_high");
            if (highEffortToday.length >= 2) {
                insights.push({
                    type: "high_effort",
                    message: "Multiple high-effort tasks today. Consider tackling the hardest one during your peak energy hours."
                });
            }

            return insights;
        }

        // ========================================
        // FORMATTING HELPERS
        // ========================================

        function formatDeadlineDisplay(deadline, currentDate = new Date()) {
            if (!deadline) return 'No deadline';

            const days = getDaysUntilDeadline(deadline, currentDate);

            if (days < -1) return `${Math.abs(days)} days overdue`;
            if (days === -1) return "Yesterday";
            if (days === 0) return "Today";
            if (days === 1) return "Tomorrow";
            if (days <= 7) return `In ${days} days`;

            return new Date(deadline).toLocaleDateString("en-US", {
                month: "short",
                day: "numeric"
            });
        }

        function formatEffortDisplay(effort) {
            const config = EFFORT_CONFIG[effort || DEFAULT_EFFORT];
            if (!config) return '4 hrs';
            if (config.minutes < 60) {
                return `${config.minutes} min`;
            }
            return `${config.minutes / 60} hrs`;
        }

        function formatPlanSummary(plan) {
            const overdueCount = plan.sections.overdue.length;
            const todayCount = plan.sections.mustDoToday.length;
            const totalHours = (plan.allocatedMinutes / 60).toFixed(1);

            const parts = [];
            if (overdueCount > 0) parts.push(`${overdueCount} overdue`);
            if (todayCount > 0) parts.push(`${todayCount} due today`);
            parts.push(`${totalHours} hrs planned`);

            return parts.join(" • ");
        }

        function formatDateHeader(date = new Date()) {
            return date.toLocaleDateString("en-US", {
                weekday: "long",
                month: "long",
                day: "numeric",
                year: "numeric"
            });
        }

        // ========================================
        // RECOMMENDATION PANEL RENDERING
        // ========================================

        function renderRecommendationPanel() {
            const plan = generateDailyPlan();

            // Update header
            recommendationDateText.textContent = `Daily Plan — ${formatDateHeader()}`;
            recommendationSummary.textContent = formatPlanSummary(plan);

            // Render warnings
            renderWarnings(plan.warnings);

            // Render sections
            renderRecommendationSection(overdueSection, overdueItems, overdueCount, plan.sections.overdue);
            renderRecommendationSection(mustDoSection, mustDoItems, mustDoCount, plan.sections.mustDoToday);
            renderRecommendationSection(recommendedSection, recommendedItems, recommendedCount, plan.sections.recommended);
            renderRecommendationSection(ifTimeSection, ifTimeItems, ifTimeCount, plan.sections.ifTimePermits);

            // Render blocked section (Issue-67)
            renderBlockedSection(blockedSection, blockedItems, blockedCount, plan.sections.blocked);

            // Render insights
            renderInsights(plan.insights);

            // Show/hide empty state
            const hasItems = plan.sections.overdue.length > 0 ||
                           plan.sections.mustDoToday.length > 0 ||
                           plan.sections.recommended.length > 0 ||
                           plan.sections.ifTimePermits.length > 0;
            recommendationEmpty.classList.toggle('hidden', hasItems);
        }

        function renderRecommendationSection(sectionEl, itemsEl, countEl, items) {
            sectionEl.classList.toggle('hidden', items.length === 0);
            countEl.textContent = items.length;
            itemsEl.innerHTML = '';

            items.forEach((item, index) => {
                const itemEl = createRecommendationItemElement(item, index);
                itemsEl.appendChild(itemEl);
            });
        }

        // Issue-103: Compact single-line Daily Plan items
        function createRecommendationItemElement(item, index) {
            const div = document.createElement('div');
            div.className = `recommendation-item ${item.todo.completed ? 'completed' : ''}`;

            const effort = item.todo.effort || DEFAULT_EFFORT;

            // Single-line compact layout: checkbox | title | effort | deadline | block-btn
            div.innerHTML = `
                <div class="recommendation-item-checkbox ${item.todo.completed ? 'checked' : ''}"
                     onclick="event.stopPropagation(); toggleTodoFromRecommendation('${item.todo.id}')"></div>
                <div class="recommendation-item-title" title="${escapeHtml(item.todo.title)}">${escapeHtml(item.todo.title)}</div>
                <div class="recommendation-item-meta-compact">
                    <span class="recommendation-item-effort-compact">⏱️ ${formatEffortDisplay(effort)}</span>
                    <span class="recommendation-item-deadline-compact">📅 ${formatDeadlineDisplay(item.todo.deadline)}</span>
                </div>
                <button class="recommendation-item-block-btn" onclick="event.stopPropagation(); blockTodoFromRecommendation('${item.todo.id}')" title="Block">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="6" y="4" width="4" height="16"></rect>
                        <rect x="14" y="4" width="4" height="16"></rect>
                    </svg>
                </button>
            `;

            // Click on item (not checkbox/block button) opens read-only modal
            div.onclick = function(e) {
                if (!e.target.closest('.recommendation-item-checkbox') && !e.target.closest('.recommendation-item-block-btn')) {
                    viewTodoFromRecommendation(item.todo.id);
                }
            };

            return div;
        }

        function renderWarnings(warnings) {
            warningsSection.innerHTML = '';
            warningsSection.classList.toggle('hidden', warnings.length === 0);

            warnings.forEach(warning => {
                const card = document.createElement('div');
                card.className = `warning-card ${warning.severity === 'critical' ? 'critical' : ''}`;
                card.innerHTML = `
                    <span class="warning-icon">⚠️</span>
                    <span class="warning-message">${escapeHtml(warning.message)}</span>
                `;
                warningsSection.appendChild(card);
            });
        }

        function renderInsights(insights) {
            insightsSection.classList.toggle('hidden', insights.length === 0);
            insightsItems.innerHTML = '';

            insights.forEach(insight => {
                const card = document.createElement('div');
                card.className = 'insight-card';
                card.innerHTML = `
                    <span class="insight-icon">💡</span>
                    <span class="insight-message">${escapeHtml(insight.message)}</span>
                `;
                insightsItems.appendChild(card);
            });
        }

        function toggleTodoFromRecommendation(todoId) {
            const index = state.todos.findIndex(t => t.id === todoId);
            if (index !== -1) {
                toggleTodo(index);
            }
        }

        // Issue-101: View todo from recommendation panel (opens read-only modal)
        function viewTodoFromRecommendation(todoId) {
            const index = state.todos.findIndex(t => t.id === todoId);
            if (index !== -1) {
                viewTodo(index);
            }
        }

        // Render blocked section with special styling (Issue-67)
        function renderBlockedSection(sectionEl, itemsEl, countEl, items) {
            sectionEl.classList.toggle('hidden', items.length === 0);
            countEl.textContent = items.length;
            itemsEl.innerHTML = '';

            items.forEach((item, index) => {
                const itemEl = createBlockedItemElement(item);
                itemsEl.appendChild(itemEl);
            });
        }

        // Create blocked item element (Issue-67)
        // Issue-103: Compact single-line blocked items
        function createBlockedItemElement(item) {
            const div = document.createElement('div');
            div.className = 'recommendation-item blocked';

            const effort = item.todo.effort || DEFAULT_EFFORT;

            // Single-line compact layout: checkbox | title | effort | deadline | unblock-btn
            div.innerHTML = `
                <div class="recommendation-item-checkbox blocked"></div>
                <div class="recommendation-item-title" title="${escapeHtml(item.todo.title)}">${escapeHtml(item.todo.title)}</div>
                <div class="recommendation-item-meta-compact">
                    <span class="recommendation-item-effort-compact">⏱️ ${formatEffortDisplay(effort)}</span>
                    <span class="recommendation-item-deadline-compact">📅 ${formatDeadlineDisplay(item.todo.deadline)}</span>
                </div>
                <button class="recommendation-item-block-btn" onclick="event.stopPropagation(); unblockTodoFromRecommendation('${item.todo.id}')" title="Unblock">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                </button>
            `;

            // Click on item opens read-only modal
            div.onclick = function(e) {
                if (!e.target.closest('.recommendation-item-block-btn')) {
                    viewTodoFromRecommendation(item.todo.id);
                }
            };

            return div;
        }

        // ========================================
        // DAILY LOAD KPI CHART - Issue-74, Issue-107
        // ========================================

        // Get DOM elements for Daily Load chart
        const dailyLoadStatus = document.getElementById('daily-load-status');
        const dailyLoadBarsContainer = document.getElementById('daily-load-bars');

        // Track highlighted todo for Daily Load chart
        let highlightedTodoId = null;

        // Day abbreviations for column labels
        const DAY_NAMES_SHORT = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        const MONTH_NAMES_SHORT = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

        /**
         * Issue-107: Get the previous work day (or yesterday if it's a work day)
         */
        function getPreviousWorkDay(date) {
            const prevDay = new Date(date);
            prevDay.setDate(prevDay.getDate() - 1);

            // Safety: limit to 365 iterations to prevent infinite loops
            let iterations = 0;
            while (!isWorkDay(prevDay) && iterations < 365) {
                prevDay.setDate(prevDay.getDate() - 1);
                iterations++;
            }

            return prevDay;
        }

        /**
         * Issue-107: Get array of next N work days starting from a date (exclusive)
         */
        function getNextNWorkDays(startDate, count) {
            const workDays = [];
            let currentDate = new Date(startDate);

            while (workDays.length < count) {
                currentDate = getNextWorkDay(currentDate);
                workDays.push(new Date(currentDate));
            }

            return workDays;
        }

        /**
         * Issue-107: Format date label for Daily Load columns
         * Shows "Yesterday", "Today", "Tomorrow", weekday name, or date if gap > 2 days
         */
        function formatDayLabel(date, today, yesterday, prevDate = null) {
            const dateTime = date.getTime();
            const todayTime = today.getTime();
            const yesterdayTime = yesterday.getTime();
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);

            if (dateTime === yesterdayTime) {
                return 'Yest.';
            } else if (dateTime === todayTime) {
                return 'Today';
            } else if (dateTime === tomorrow.getTime()) {
                return 'Tmrw';
            }

            // Check if there's a gap > 2 days from previous date
            if (prevDate) {
                const dayDiff = Math.round((dateTime - prevDate.getTime()) / (1000 * 60 * 60 * 24));
                if (dayDiff > 2) {
                    // Show date format: "Dec 22"
                    return `${MONTH_NAMES_SHORT[date.getMonth()]} ${date.getDate()}`;
                }
            }

            // Show weekday abbreviation
            return DAY_NAMES_SHORT[date.getDay()];
        }

        /**
         * Issue-107: Get workload border class based on total hours
         */
        function getWorkloadBorderClass(totalHours) {
            if (totalHours <= 6) return 'workload-easy';
            if (totalHours <= 7.5) return 'workload-moderate';
            if (totalHours <= 8) return 'workload-heavy';
            return 'workload-overloaded';
        }

        /**
         * Issue-107: Get priority-based color class for task segment
         */
        function getPriorityColorClass(priority) {
            const priorityMap = {
                'urgent': 'priority-urgent',
                'high': 'priority-high',
                'normal': 'priority-normal',
                'low': 'priority-low',
                'someday': 'priority-someday'
            };
            return priorityMap[priority] || 'priority-normal';
        }

        /**
         * Issue-107: Categorize todos for a specific date
         */
        function getTodosForDate(targetDate) {
            const dateStart = new Date(targetDate);
            dateStart.setHours(0, 0, 0, 0);
            const dateEnd = new Date(dateStart);
            dateEnd.setDate(dateEnd.getDate() + 1);

            return state.todos.filter(todo => {
                if (todo.dropped || todo.blocked) return false;
                const deadlineValue = todo.deadline || todo.dueDate;
                if (!deadlineValue) return false;

                const deadline = new Date(deadlineValue);
                deadline.setHours(0, 0, 0, 0);

                return deadline.getTime() === dateStart.getTime();
            });
        }

        /**
         * Issue-107: Get overdue todos (deadlines before today, not completed)
         */
        function getOverdueTodos(today) {
            return state.todos.filter(todo => {
                if (todo.dropped || todo.blocked || todo.completed) return false;
                const deadlineValue = todo.deadline || todo.dueDate;
                if (!deadlineValue) return false;

                const deadline = new Date(deadlineValue);
                deadline.setHours(0, 0, 0, 0);

                return deadline < today;
            });
        }

        /**
         * Issue-107: Categorize yesterday's data with special logic
         */
        function categorizeYesterdayData(yesterday, today) {
            const yesterdayStart = new Date(yesterday);
            yesterdayStart.setHours(0, 0, 0, 0);
            const yesterdayEnd = new Date(yesterdayStart);
            yesterdayEnd.setDate(yesterdayEnd.getDate() + 1);

            const result = {
                meetings: [],
                completedOnTime: [],      // Completed with yesterday's deadline (green)
                completedExtra: [],       // Completed yesterday but deadline wasn't yesterday (dark green)
                overdueMissed: []         // Yesterday's deadline, not completed (light red)
            };

            // Get meetings for yesterday
            result.meetings = (state.meetings || []).filter(meeting => {
                const meetingDate = new Date(meeting.date);
                meetingDate.setHours(0, 0, 0, 0);
                return meetingDate.getTime() === yesterdayStart.getTime();
            });

            // Categorize todos
            state.todos.forEach(todo => {
                if (todo.dropped || todo.blocked) return;

                const deadlineValue = todo.deadline || todo.dueDate;
                const deadline = deadlineValue ? new Date(deadlineValue) : null;
                if (deadline) deadline.setHours(0, 0, 0, 0);

                const hadYesterdayDeadline = deadline && deadline.getTime() === yesterdayStart.getTime();

                if (todo.completed && todo.completedAt) {
                    const completedDate = new Date(todo.completedAt);
                    completedDate.setHours(0, 0, 0, 0);
                    const completedYesterday = completedDate.getTime() === yesterdayStart.getTime();

                    if (completedYesterday) {
                        if (hadYesterdayDeadline) {
                            result.completedOnTime.push(todo);
                        } else {
                            result.completedExtra.push(todo);
                        }
                    }
                } else if (!todo.completed && hadYesterdayDeadline) {
                    result.overdueMissed.push(todo);
                }
            });

            return result;
        }

        /**
         * Issue-107: Categorize today's data with priority ordering
         */
        function categorizeTodayData(today) {
            const todayStart = new Date(today);
            todayStart.setHours(0, 0, 0, 0);
            const todayEnd = new Date(todayStart);
            todayEnd.setDate(todayEnd.getDate() + 1);

            const result = {
                meetings: [],
                urgent: [],
                overdue: [],
                high: [],
                normal: [],
                low: [],
                someday: []
            };

            // Get meetings for today
            result.meetings = (state.meetings || []).filter(meeting => {
                const meetingDate = new Date(meeting.date);
                meetingDate.setHours(0, 0, 0, 0);
                return meetingDate.getTime() === todayStart.getTime();
            });

            // Get overdue todos
            result.overdue = getOverdueTodos(todayStart);

            // Get today's todos by priority
            const todayTodos = getTodosForDate(todayStart).filter(t => !t.completed);
            todayTodos.forEach(todo => {
                const priority = todo.priority || 'normal';
                if (result[priority]) {
                    result[priority].push(todo);
                } else {
                    result.normal.push(todo);
                }
            });

            return result;
        }

        /**
         * Issue-107: Categorize future day's data with priority ordering
         */
        function categorizeFutureDayData(date) {
            const dateStart = new Date(date);
            dateStart.setHours(0, 0, 0, 0);

            const result = {
                meetings: [],
                urgent: [],
                high: [],
                normal: [],
                low: [],
                someday: []
            };

            // Get meetings for this date
            result.meetings = (state.meetings || []).filter(meeting => {
                const meetingDate = new Date(meeting.date);
                meetingDate.setHours(0, 0, 0, 0);
                return meetingDate.getTime() === dateStart.getTime();
            });

            // Get todos for this date by priority
            const dayTodos = getTodosForDate(dateStart).filter(t => !t.completed);
            dayTodos.forEach(todo => {
                const priority = todo.priority || 'normal';
                if (result[priority]) {
                    result[priority].push(todo);
                } else {
                    result.normal.push(todo);
                }
            });

            return result;
        }

        /**
         * Calculate total hours for a list of todos
         */
        function calculateTotalHours(todos) {
            let totalMinutes = 0;
            let completedMinutes = 0;

            todos.forEach(todo => {
                const effort = todo.effort || DEFAULT_EFFORT;
                const minutes = EFFORT_CONFIG[effort]?.minutes || 240;
                totalMinutes += minutes;
                if (todo.completed) {
                    completedMinutes += minutes;
                }
            });

            return {
                total: totalMinutes / 60,
                completed: completedMinutes / 60,
                remaining: (totalMinutes - completedMinutes) / 60
            };
        }

        /**
         * Check if there are any pending (non-completed, non-dropped, non-blocked) todos
         * scheduled for the future (after today)
         */
        function hasFuturePendingTodos() {
            const today = new Date();
            today.setHours(23, 59, 59, 999); // End of today

            return state.todos.some(todo => {
                if (todo.completed || todo.dropped || todo.blocked) return false;
                const deadlineValue = todo.deadline || todo.dueDate;
                if (!deadlineValue) return false;
                const deadline = new Date(deadlineValue);
                return deadline > today;
            });
        }

        /**
         * Get workload status based on today's hours and future tasks (Issue-88)
         */
        function getWorkloadStatus(todayHours, hasFutureTasks = false) {
            if (todayHours > 8) {
                return { class: 'overloaded', text: 'You are overloaded' };
            } else if (todayHours >= 6) {
                return { class: 'careful', text: 'Careful not to exceed yourself today' };
            } else if (todayHours >= 4) {
                return { class: 'balanced', text: 'Balanced workload' };
            } else if (hasFutureTasks) {
                // Issue-88: Light workload but future tasks exist
                return { class: 'easy', text: 'Easy workload' };
            } else {
                return { class: 'light', text: 'You should ask for work' };
            }
        }

        /**
         * Format hours display - shows total hours
         */
        function formatHoursDisplay(totalHours) {
            if (totalHours === 0) return '0h';
            const hoursStr = totalHours % 1 === 0 ? totalHours.toFixed(0) : totalHours.toFixed(1);
            return `${hoursStr}h`;
        }

        /**
         * Issue-107: Render a segment in the bar
         */
        function renderSegment(barElement, item, colorClass, scaleFactor, pixelsPerHour, isCompleted = false, isMeeting = false) {
            let hours;
            if (isMeeting) {
                hours = item.duration / 60;
            } else {
                const effort = item.effort || DEFAULT_EFFORT;
                const minutes = EFFORT_CONFIG[effort]?.minutes || 240;
                hours = minutes / 60;
            }

            const scaledHours = hours * scaleFactor;
            const segmentHeight = Math.max(scaledHours * pixelsPerHour, 12); // Minimum 12px for visibility

            const segment = document.createElement('div');
            segment.className = `daily-load-segment ${colorClass}`;

            if (isCompleted) {
                segment.classList.add('completed');
            }

            if (!isMeeting && item.id === highlightedTodoId) {
                segment.classList.add('highlighted');
            }

            segment.style.height = `${segmentHeight}px`;

            if (isMeeting) {
                segment.dataset.meetingId = item.id;
                segment.title = `📅 ${escapeHtml(item.title)} (${formatDurationDisplay(item.duration)})`;
            } else {
                segment.dataset.todoId = item.id;
                const effort = item.effort || DEFAULT_EFFORT;
                segment.title = `${escapeHtml(item.title)} (${formatEffortDisplay(effort)})`;
                segment.onclick = () => highlightTodoInList(item.id);
            }

            barElement.appendChild(segment);
            return hours;
        }

        /**
         * Issue-107: Render Yesterday column
         */
        function renderYesterdayColumn(data) {
            const column = document.createElement('div');
            column.className = 'daily-load-column';

            // Calculate total hours
            let totalHours = 0;
            const allTodos = [...data.completedOnTime, ...data.completedExtra, ...data.overdueMissed];
            allTodos.forEach(todo => {
                const effort = todo.effort || DEFAULT_EFFORT;
                totalHours += (EFFORT_CONFIG[effort]?.minutes || 240) / 60;
            });
            data.meetings.forEach(m => totalHours += m.duration / 60);

            // Hours display
            const hoursDiv = document.createElement('div');
            hoursDiv.className = 'daily-load-column-hours';
            hoursDiv.textContent = formatHoursDisplay(totalHours);
            column.appendChild(hoursDiv);

            // Bar
            const bar = document.createElement('div');
            bar.className = `daily-load-bar ${getWorkloadBorderClass(totalHours)}`;

            if (data.meetings.length === 0 && allTodos.length === 0) {
                bar.innerHTML = '<div class="daily-load-empty">-</div>';
            } else {
                const maxHeight = 120;
                const maxHours = 10;
                const pixelsPerHour = maxHeight / maxHours;
                const scaleFactor = totalHours > maxHours ? maxHours / totalHours : 1;

                // Render in order: meetings (yellow), completed on-time (green), completed extra (dark green), overdue missed (light red)
                data.meetings.forEach(m => renderSegment(bar, m, 'meeting', scaleFactor, pixelsPerHour, false, true));
                data.completedOnTime.forEach(t => renderSegment(bar, t, 'completed-ontime', scaleFactor, pixelsPerHour, true));
                data.completedExtra.forEach(t => renderSegment(bar, t, 'completed-extra', scaleFactor, pixelsPerHour, true));
                data.overdueMissed.forEach(t => renderSegment(bar, t, 'overdue-missed', scaleFactor, pixelsPerHour));
            }

            column.appendChild(bar);

            // Label
            const label = document.createElement('div');
            label.className = 'daily-load-label';
            label.textContent = 'Yest.';
            column.appendChild(label);

            return column;
        }

        /**
         * Issue-107: Render Today column
         */
        function renderTodayColumn(data) {
            const column = document.createElement('div');
            column.className = 'daily-load-column';

            // Calculate total hours
            let totalHours = 0;
            const allTodos = [...data.urgent, ...data.overdue, ...data.high, ...data.normal, ...data.low, ...data.someday];
            allTodos.forEach(todo => {
                const effort = todo.effort || DEFAULT_EFFORT;
                totalHours += (EFFORT_CONFIG[effort]?.minutes || 240) / 60;
            });
            data.meetings.forEach(m => totalHours += m.duration / 60);

            // Hours display
            const hoursDiv = document.createElement('div');
            hoursDiv.className = 'daily-load-column-hours';
            hoursDiv.textContent = formatHoursDisplay(totalHours);
            column.appendChild(hoursDiv);

            // Bar
            const bar = document.createElement('div');
            bar.className = `daily-load-bar ${getWorkloadBorderClass(totalHours)}`;

            if (data.meetings.length === 0 && allTodos.length === 0) {
                bar.innerHTML = '<div class="daily-load-empty">-</div>';
            } else {
                const maxHeight = 120;
                const maxHours = 10;
                const pixelsPerHour = maxHeight / maxHours;
                const scaleFactor = totalHours > maxHours ? maxHours / totalHours : 1;

                // Render in order: meetings, urgent, overdue, high, normal, low, someday
                data.meetings.forEach(m => renderSegment(bar, m, 'meeting', scaleFactor, pixelsPerHour, false, true));
                data.urgent.forEach(t => renderSegment(bar, t, 'priority-urgent', scaleFactor, pixelsPerHour));
                data.overdue.forEach(t => renderSegment(bar, t, 'overdue', scaleFactor, pixelsPerHour));
                data.high.forEach(t => renderSegment(bar, t, 'priority-high', scaleFactor, pixelsPerHour));
                data.normal.forEach(t => renderSegment(bar, t, 'priority-normal', scaleFactor, pixelsPerHour));
                data.low.forEach(t => renderSegment(bar, t, 'priority-low', scaleFactor, pixelsPerHour));
                data.someday.forEach(t => renderSegment(bar, t, 'priority-someday', scaleFactor, pixelsPerHour));
            }

            column.appendChild(bar);

            // Label
            const label = document.createElement('div');
            label.className = 'daily-load-label';
            label.textContent = 'Today';
            column.appendChild(label);

            return column;
        }

        /**
         * Issue-107: Render Future day column
         */
        function renderFutureDayColumn(data, date, labelText) {
            const column = document.createElement('div');
            column.className = 'daily-load-column';

            // Calculate total hours
            let totalHours = 0;
            const allTodos = [...data.urgent, ...data.high, ...data.normal, ...data.low, ...data.someday];
            allTodos.forEach(todo => {
                const effort = todo.effort || DEFAULT_EFFORT;
                totalHours += (EFFORT_CONFIG[effort]?.minutes || 240) / 60;
            });
            data.meetings.forEach(m => totalHours += m.duration / 60);

            // Hours display
            const hoursDiv = document.createElement('div');
            hoursDiv.className = 'daily-load-column-hours';
            hoursDiv.textContent = formatHoursDisplay(totalHours);
            column.appendChild(hoursDiv);

            // Bar
            const bar = document.createElement('div');
            bar.className = `daily-load-bar ${getWorkloadBorderClass(totalHours)}`;

            if (data.meetings.length === 0 && allTodos.length === 0) {
                bar.innerHTML = '<div class="daily-load-empty">-</div>';
            } else {
                const maxHeight = 120;
                const maxHours = 10;
                const pixelsPerHour = maxHeight / maxHours;
                const scaleFactor = totalHours > maxHours ? maxHours / totalHours : 1;

                // Render in order: meetings, urgent, high, normal, low, someday
                data.meetings.forEach(m => renderSegment(bar, m, 'meeting', scaleFactor, pixelsPerHour, false, true));
                data.urgent.forEach(t => renderSegment(bar, t, 'priority-urgent', scaleFactor, pixelsPerHour));
                data.high.forEach(t => renderSegment(bar, t, 'priority-high', scaleFactor, pixelsPerHour));
                data.normal.forEach(t => renderSegment(bar, t, 'priority-normal', scaleFactor, pixelsPerHour));
                data.low.forEach(t => renderSegment(bar, t, 'priority-low', scaleFactor, pixelsPerHour));
                data.someday.forEach(t => renderSegment(bar, t, 'priority-someday', scaleFactor, pixelsPerHour));
            }

            column.appendChild(bar);

            // Label
            const label = document.createElement('div');
            label.className = 'daily-load-label';
            label.textContent = labelText;
            label.title = date.toLocaleDateString();
            column.appendChild(label);

            return column;
        }

        /**
         * Highlight a todo in the main list when clicked in Daily Load chart
         */
        function highlightTodoInList(todoId) {
            // Remove previous highlight
            if (highlightedTodoId) {
                const prevSegments = document.querySelectorAll(`.daily-load-segment[data-todo-id="${highlightedTodoId}"]`);
                prevSegments.forEach(seg => seg.classList.remove('highlighted'));
                const prevTodoCard = document.querySelector(`.todo-item[data-todo-id="${highlightedTodoId}"]`);
                if (prevTodoCard) {
                    prevTodoCard.classList.remove('daily-load-highlighted');
                }
            }

            highlightedTodoId = todoId;

            // Highlight new segment
            const segments = document.querySelectorAll(`.daily-load-segment[data-todo-id="${todoId}"]`);
            segments.forEach(seg => seg.classList.add('highlighted'));

            // Find and scroll to the todo card using data-todo-id
            const todoCard = document.querySelector(`.todo-item[data-todo-id="${todoId}"]`);
            if (todoCard) {
                todoCard.classList.add('daily-load-highlighted');
                todoCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

            // Clear highlight after 3 seconds
            setTimeout(() => {
                if (highlightedTodoId === todoId) {
                    highlightedTodoId = null;
                    segments.forEach(seg => seg.classList.remove('highlighted'));
                    const highlightedCards = document.querySelectorAll('.todo-item.daily-load-highlighted');
                    highlightedCards.forEach(card => card.classList.remove('daily-load-highlighted'));
                }
            }, 3000);
        }

        /**
         * Issue-107: Render the complete Daily Load chart with 8 columns
         */
        function renderDailyLoadChart() {
            if (state.currentPage !== 'app' || state.currentTab !== 'home') return;

            // Get dates
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            const yesterday = getPreviousWorkDay(today);
            yesterday.setHours(0, 0, 0, 0);

            // Get 7 future work days (including tomorrow if it's a work day)
            const futureWorkDays = getNextNWorkDays(today, 7);

            // Clear existing columns
            dailyLoadBarsContainer.innerHTML = '';

            // 1. Render Yesterday column
            const yesterdayData = categorizeYesterdayData(yesterday, today);
            dailyLoadBarsContainer.appendChild(renderYesterdayColumn(yesterdayData));

            // 2. Render Today column
            const todayData = categorizeTodayData(today);
            dailyLoadBarsContainer.appendChild(renderTodayColumn(todayData));

            // Calculate today's total hours for status
            let todayTotalHours = 0;
            const todayAllTodos = [...todayData.urgent, ...todayData.overdue, ...todayData.high, ...todayData.normal, ...todayData.low, ...todayData.someday];
            todayAllTodos.forEach(todo => {
                const effort = todo.effort || DEFAULT_EFFORT;
                todayTotalHours += (EFFORT_CONFIG[effort]?.minutes || 240) / 60;
            });
            todayData.meetings.forEach(m => todayTotalHours += m.duration / 60);

            // Update status message
            const hasFutureTasks = hasFuturePendingTodos();
            const status = getWorkloadStatus(todayTotalHours, hasFutureTasks);
            dailyLoadStatus.className = `daily-load-status ${status.class}`;
            dailyLoadStatus.textContent = status.text;

            // 3. Render 6 future day columns (to make 8 total)
            let prevDate = today;
            for (let i = 0; i < 6 && i < futureWorkDays.length; i++) {
                const date = futureWorkDays[i];
                const data = categorizeFutureDayData(date);
                const label = formatDayLabel(date, today, yesterday, prevDate);
                dailyLoadBarsContainer.appendChild(renderFutureDayColumn(data, date, label));
                prevDate = date;
            }
        }

        // ========================================
        // MEETING FUNCTIONS (Issue-80)
        // ========================================

        /**
         * Open the meeting modal for creating a new meeting
         */
        function openMeetingModal() {
            state.meetingModalOpen = true;
            state.editingMeetingIndex = null;

            // Reset form
            document.getElementById('meeting-title').value = '';
            document.getElementById('meeting-description').value = '';
            document.getElementById('meeting-duration').value = '1 hr';
            document.getElementById('meeting-modal-title').textContent = 'New Meeting';

            // Reset recurring options
            document.getElementById('meeting-recurring-check').checked = false;
            document.getElementById('meeting-recurring-end').value = '';
            document.querySelector('.meeting-modal-content').classList.remove('expanded');
            document.getElementById('meeting-recurring-panel').classList.remove('visible');
            selectRecurringFrequency('weekly'); // Reset to default weekly
            updateMeetingSaveButton();

            // Set default date to current date and time
            const now = new Date();
            // Round to next 30 minutes
            const minutes = now.getMinutes();
            now.setMinutes(minutes < 30 ? 30 : 60, 0, 0);
            if (minutes >= 30) now.setHours(now.getHours() + 1);

            const dateInput = document.getElementById('meeting-date');
            dateInput.value = formatDateTimeLocal(now);

            document.getElementById('meeting-modal').classList.remove('hidden');

            // Focus on title field
            setTimeout(() => {
                document.getElementById('meeting-title').focus();
            }, 50);
        }

        /**
         * Close the meeting modal
         */
        function closeMeetingModal() {
            state.meetingModalOpen = false;
            state.editingMeetingIndex = null;
            document.getElementById('meeting-modal').classList.add('hidden');
            // Reset expanded state
            document.querySelector('.meeting-modal-content').classList.remove('expanded');
            document.getElementById('meeting-recurring-panel').classList.remove('visible');
        }

        /**
         * Toggle the recurring panel visibility
         */
        function toggleRecurringPanel() {
            const checkbox = document.getElementById('meeting-recurring-check');
            const panel = document.getElementById('meeting-recurring-panel');
            const modalContent = document.querySelector('.meeting-modal-content');
            const endDateInput = document.getElementById('meeting-recurring-end');

            if (checkbox.checked) {
                modalContent.classList.add('expanded');
                panel.classList.add('visible');
                // Set default end date to 1 year from meeting date
                const meetingDate = document.getElementById('meeting-date').value;
                if (meetingDate) {
                    const startDate = new Date(meetingDate);
                    const endDate = new Date(startDate);
                    endDate.setFullYear(endDate.getFullYear() + 1);
                    endDateInput.value = endDate.toISOString().split('T')[0];
                }
            } else {
                modalContent.classList.remove('expanded');
                panel.classList.remove('visible');
                endDateInput.value = '';
            }
            updateMeetingSaveButton();
        }

        /**
         * Select a recurring frequency option (only one can be selected)
         */
        function selectRecurringFrequency(frequency) {
            const options = document.querySelectorAll('.recurring-option');
            options.forEach(option => {
                const input = option.querySelector('input[name="recurring-freq"]');
                if (input.value === frequency) {
                    input.checked = true;
                    option.classList.add('selected');
                } else {
                    input.checked = false;
                    option.classList.remove('selected');
                }
            });
        }

        /**
         * Update Save button state based on recurring settings
         */
        function updateMeetingSaveButton() {
            const saveBtn = document.getElementById('meeting-save-btn');
            const isRecurring = document.getElementById('meeting-recurring-check').checked;
            const endDate = document.getElementById('meeting-recurring-end').value;

            if (isRecurring && !endDate) {
                saveBtn.disabled = true;
                saveBtn.style.opacity = '0.5';
                saveBtn.style.cursor = 'not-allowed';
                saveBtn.title = 'Please select an end date for recurring meetings';
            } else {
                saveBtn.disabled = false;
                saveBtn.style.opacity = '1';
                saveBtn.style.cursor = 'pointer';
                saveBtn.title = '';
            }
        }

        /**
         * Get selected recurring frequency
         */
        function getSelectedRecurringFrequency() {
            const checked = document.querySelector('input[name="recurring-freq"]:checked');
            return checked ? checked.value : 'weekly';
        }

        /**
         * Generate recurring meeting dates based on frequency and end date
         * Respects Work Calendar settings (skips non-work days)
         */
        function generateRecurringDates(startDate, frequency, endDate) {
            const dates = [];
            let current = new Date(startDate);
            const end = new Date(endDate);
            end.setHours(23, 59, 59, 999); // Include the end date

            // Get interval in days based on frequency
            const intervals = {
                'daily': 1,
                'weekly': 7,
                'biweekly': 14,
                '3weeks': 21,
                'monthly': 0 // Special handling for monthly
            };

            while (current <= end) {
                // Check if current date is a work day
                if (isWorkDay(current)) {
                    dates.push(new Date(current));
                }

                // Advance to next occurrence
                if (frequency === 'monthly') {
                    current.setMonth(current.getMonth() + 1);
                } else {
                    current.setDate(current.getDate() + intervals[frequency]);
                }
            }

            return dates;
        }

        /**
         * Parse duration string to minutes
         * Supports formats: "1 hr", "1.5 hrs", "30 min", "1h", "90m", etc.
         */
        function parseDurationToMinutes(durationStr) {
            if (!durationStr) return 60; // Default 1 hour

            const str = durationStr.toLowerCase().trim();

            // Try hours format: "1 hr", "1.5 hrs", "2h", "1 hour"
            const hoursMatch = str.match(/^(\d+(?:\.\d+)?)\s*(?:hr|hrs|h|hour|hours)$/);
            if (hoursMatch) {
                return Math.round(parseFloat(hoursMatch[1]) * 60);
            }

            // Try minutes format: "30 min", "45m", "90 minutes"
            const minsMatch = str.match(/^(\d+)\s*(?:min|mins|m|minute|minutes)$/);
            if (minsMatch) {
                return parseInt(minsMatch[1]);
            }

            // Try plain number (assume hours if <= 8, else minutes)
            const numMatch = str.match(/^(\d+(?:\.\d+)?)$/);
            if (numMatch) {
                const num = parseFloat(numMatch[1]);
                return num <= 8 ? Math.round(num * 60) : Math.round(num);
            }

            return 60; // Default 1 hour
        }

        /**
         * Format minutes to display string
         */
        function formatDurationDisplay(minutes) {
            if (minutes < 60) {
                return `${minutes}m`;
            }
            const hours = minutes / 60;
            if (hours === Math.floor(hours)) {
                return `${hours}h`;
            }
            return `${hours.toFixed(1)}h`;
        }

        /**
         * Save meeting from modal
         */
        function saveMeeting(event) {
            event.preventDefault();

            const title = document.getElementById('meeting-title').value.trim();
            const description = document.getElementById('meeting-description').value.trim();
            const dateValue = document.getElementById('meeting-date').value;
            const durationStr = document.getElementById('meeting-duration').value;
            const isRecurring = document.getElementById('meeting-recurring-check').checked;
            const recurringEndDate = document.getElementById('meeting-recurring-end').value;

            if (!title || !dateValue) {
                alert('Please fill in all required fields.');
                return;
            }

            // Validate recurring settings
            if (isRecurring && !recurringEndDate) {
                alert('Please select an end date for recurring meetings.');
                return;
            }

            const durationMinutes = parseDurationToMinutes(durationStr);
            const startDate = new Date(dateValue);

            if (isRecurring) {
                // Generate all recurring meeting instances
                const frequency = getSelectedRecurringFrequency();
                const recurringDates = generateRecurringDates(startDate, frequency, recurringEndDate);
                const now = new Date().toISOString();
                const recurringGroupId = generateId(); // Link all instances together

                recurringDates.forEach((date, index) => {
                    // Preserve the time from the original meeting
                    date.setHours(startDate.getHours(), startDate.getMinutes(), 0, 0);

                    const meeting = {
                        id: generateId(),
                        title: title,
                        description: description,
                        date: date.toISOString(),
                        duration: durationMinutes,
                        recurringGroupId: recurringGroupId,
                        recurringFrequency: frequency,
                        recurringIndex: index,
                        createdAt: now,
                        updatedAt: now
                    };
                    state.meetings.push(meeting);
                });
            } else {
                // Single meeting
                const meeting = {
                    id: state.editingMeetingIndex !== null ? state.meetings[state.editingMeetingIndex].id : generateId(),
                    title: title,
                    description: description,
                    date: startDate.toISOString(),
                    duration: durationMinutes,
                    createdAt: state.editingMeetingIndex !== null ? state.meetings[state.editingMeetingIndex].createdAt : new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };

                if (state.editingMeetingIndex !== null) {
                    state.meetings[state.editingMeetingIndex] = meeting;
                } else {
                    state.meetings.push(meeting);
                }
            }

            closeMeetingModal();
            renderMeetingsList();
            renderDailyLoadChart();
            saveStateToIndexedDB();
        }

        /**
         * Delete a meeting
         */
        function deleteMeeting(meetingId) {
            state.meetings = state.meetings.filter(m => m.id !== meetingId);
            renderMeetingsList();
            renderDailyLoadChart();
            saveStateToIndexedDB();
        }

        /**
         * Get date label for meeting (Today, Tomorrow, or date)
         */
        function getMeetingDateLabel(meetingDate) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);

            const meetingDay = new Date(meetingDate);
            meetingDay.setHours(0, 0, 0, 0);

            if (meetingDay.getTime() === today.getTime()) {
                return 'Today';
            } else if (meetingDay.getTime() === tomorrow.getTime()) {
                return 'Tomorrow';
            } else {
                return meetingDay.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            }
        }

        /**
         * Render the meetings list
         */
        function renderMeetingsList() {
            const listEl = document.getElementById('meetings-list');
            const countEl = document.getElementById('meetings-count');

            if (!listEl) return;

            // Get upcoming meetings (today and future)
            const now = new Date();
            now.setHours(0, 0, 0, 0);

            const upcomingMeetings = state.meetings
                .filter(m => {
                    const meetingDate = new Date(m.date);
                    meetingDate.setHours(0, 0, 0, 0);
                    return meetingDate >= now;
                })
                .sort((a, b) => new Date(a.date) - new Date(b.date));

            // Update count - only show today's meetings to align with Daily Load KPI focus (Issue-95)
            if (countEl) {
                const tomorrow = new Date(now);
                tomorrow.setDate(tomorrow.getDate() + 1);
                const todayMeetings = upcomingMeetings.filter(m => {
                    const meetingDate = new Date(m.date);
                    meetingDate.setHours(0, 0, 0, 0);
                    return meetingDate < tomorrow;
                });
                countEl.textContent = todayMeetings.length > 0 ? `${todayMeetings.length} today` : '';
            }

            if (upcomingMeetings.length === 0) {
                listEl.innerHTML = '<div class="meetings-empty">No upcoming meetings</div>';
                return;
            }

            listEl.innerHTML = upcomingMeetings.map(meeting => `
                <div class="meeting-item" data-meeting-id="${meeting.id}">
                    <span class="meeting-date-label">${getMeetingDateLabel(meeting.date)}</span>
                    <span class="meeting-title-text" title="${escapeHtml(meeting.title)}">${escapeHtml(meeting.title)}</span>
                    <span class="meeting-duration-text">${formatDurationDisplay(meeting.duration)}</span>
                    <button class="meeting-delete-btn" onclick="deleteMeeting('${meeting.id}')" title="Delete meeting">×</button>
                </div>
            `).join('');
        }

        // Issue-107: Removed categorizeMeetingsForDailyLoad - meetings are now categorized per-day

        // ========================================
        // PRIORITY AUTOCOMPLETE FUNCTIONS
        // ========================================

        function getFilteredPriorityOptions(filter = '') {
            const filterLower = filter.toLowerCase();
            return Object.keys(PRIORITY_TAGS).filter(key => {
                const priority = PRIORITY_TAGS[key];
                if (filter && !priority.label.toLowerCase().includes(filterLower) &&
                    !priority.name.toLowerCase().includes(filterLower)) {
                    return false;
                }
                return true;
            });
        }

        function renderPriorityDropdown(filter = '') {
            priorityDropdown.innerHTML = '';
            const filteredOptions = getFilteredPriorityOptions(filter);

            filteredOptions.forEach((key, filteredIndex) => {
                const priority = PRIORITY_TAGS[key];
                const option = document.createElement('div');
                option.className = `priority-option ${state.selectedPriority === key ? 'selected' : ''} ${state.priorityHighlightIndex === filteredIndex ? 'highlighted' : ''}`;
                option.innerHTML = `
                    <span class="priority-option-color" style="background-color: ${priority.color}"></span>
                    <span class="priority-option-label">${priority.label}</span>
                    <span class="priority-option-desc">${priority.description}</span>
                `;
                option.onclick = () => selectPriority(key);
                priorityDropdown.appendChild(option);
            });
        }

        function selectPriority(key) {
            state.selectedPriority = key;
            todoPriorityInput.value = PRIORITY_TAGS[key].label;
            closePriorityDropdown();
        }

        function openPriorityDropdown() {
            state.priorityDropdownOpen = true;
            state.priorityHighlightIndex = -1;
            renderPriorityDropdown(todoPriorityInput.value);
            priorityDropdown.classList.add('open');
        }

        function closePriorityDropdown() {
            state.priorityDropdownOpen = false;
            state.priorityHighlightIndex = -1;
            priorityDropdown.classList.remove('open');
        }

        // Priority input event listeners
        if (todoPriorityInput) {
            todoPriorityInput.addEventListener('focus', () => {
                openPriorityDropdown();
            });

            todoPriorityInput.addEventListener('input', (e) => {
                openPriorityDropdown();
                renderPriorityDropdown(e.target.value);
                // Auto-highlight first match when typing
                const filteredOptions = getFilteredPriorityOptions(e.target.value);
                if (filteredOptions.length > 0) {
                    state.priorityHighlightIndex = 0;
                    renderPriorityDropdown(e.target.value);
                }
            });

            todoPriorityInput.addEventListener('keydown', (e) => {
                const filteredOptions = getFilteredPriorityOptions(todoPriorityInput.value);

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    state.priorityHighlightIndex = Math.min(state.priorityHighlightIndex + 1, filteredOptions.length - 1);
                    renderPriorityDropdown(todoPriorityInput.value);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    state.priorityHighlightIndex = Math.max(state.priorityHighlightIndex - 1, 0);
                    renderPriorityDropdown(todoPriorityInput.value);
                } else if (e.key === 'Tab' && !e.shiftKey && state.priorityDropdownOpen) {
                    // Tab (forward only) with dropdown open: select first/highlighted match and move on
                    if (filteredOptions.length > 0) {
                        e.preventDefault();
                        const indexToSelect = state.priorityHighlightIndex >= 0 ? state.priorityHighlightIndex : 0;
                        selectPriority(filteredOptions[indexToSelect]);
                        // Move focus to the next focusable element
                        todoEngagementInput.focus();
                    }
                    // If no filtered options, let Tab naturally move to next control
                } else if (e.key === 'Enter' && state.priorityDropdownOpen) {
                    e.preventDefault();
                    if (filteredOptions.length > 0) {
                        const indexToSelect = state.priorityHighlightIndex >= 0 ? state.priorityHighlightIndex : 0;
                        selectPriority(filteredOptions[indexToSelect]);
                    }
                } else if (e.key === 'Escape') {
                    closePriorityDropdown();
                }
            });

            todoPriorityInput.addEventListener('blur', () => {
                // Delay to allow click events on dropdown items
                setTimeout(() => {
                    // Validate input - if not a valid priority, reset to selected
                    const inputValue = todoPriorityInput.value.toLowerCase();
                    const matchingKey = Object.keys(PRIORITY_TAGS).find(
                        key => PRIORITY_TAGS[key].label.toLowerCase() === inputValue ||
                               PRIORITY_TAGS[key].name.toLowerCase() === inputValue
                    );

                    if (matchingKey) {
                        state.selectedPriority = matchingKey;
                    }

                    // Always show the selected priority label
                    todoPriorityInput.value = PRIORITY_TAGS[state.selectedPriority].label;
                    closePriorityDropdown();
                }, 200);
            });
        }

        // ========================================
        // PLANNING SETTINGS FUNCTIONS
        // ========================================

        function savePlanningSettings(event) {
            event.preventDefault();

            state.settings.workdayMinutes = parseInt(document.getElementById('workday-minutes').value) || DEFAULT_SETTINGS.workdayMinutes;
            state.settings.bufferPercentage = parseInt(document.getElementById('buffer-percentage').value) || DEFAULT_SETTINGS.bufferPercentage;
            state.settings.maxOverdueToShow = parseInt(document.getElementById('max-overdue').value) || DEFAULT_SETTINGS.maxOverdueToShow;
            state.settings.planningHorizonDays = parseInt(document.getElementById('planning-horizon').value) || DEFAULT_SETTINGS.planningHorizonDays;

            // Refresh recommendation panel with new settings
            if (state.currentPage === 'app' && state.currentTab === 'home') {
                renderRecommendationPanel();
            }

            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));

            alert('Planning settings saved successfully!');
        }

        function loadPlanningSettings() {
            document.getElementById('workday-minutes').value = state.settings.workdayMinutes;
            document.getElementById('buffer-percentage').value = state.settings.bufferPercentage;
            document.getElementById('max-overdue').value = state.settings.maxOverdueToShow;
            document.getElementById('planning-horizon').value = state.settings.planningHorizonDays;
        }

        function renderPlanningSettings() {
            loadPlanningSettings();
        }

        // ========================================
        // TASKS SETTINGS FUNCTIONS (Issue-97)
        // ========================================

        function saveTasksSettings(event) {
            event.preventDefault();

            state.settings.completedVisibilityDays = parseInt(document.getElementById('completed-visibility-days').value) || DEFAULT_SETTINGS.completedVisibilityDays;

            // Refresh todo list with new settings
            if (state.currentPage === 'app' && state.currentTab === 'home') {
                renderTodos();
            }

            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state:', err));

            alert('Tasks settings saved successfully!');
        }

        function loadTasksSettings() {
            document.getElementById('completed-visibility-days').value = state.settings.completedVisibilityDays || DEFAULT_SETTINGS.completedVisibilityDays;
        }

        function renderTasksSettings() {
            loadTasksSettings();
        }

        // ========================================
        // CALENDAR SECTION FUNCTIONS (Issue-76)
        // ========================================

        const DAY_NAMES = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const DAY_ABBREVS = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

        /**
         * Render the work calendar settings section
         */
        function renderCalendarSettings() {
            // Initialize date pickers after DOM is ready
            setTimeout(initializeCalendarPickers, 0);
            renderWorkDaysGrid();
            renderHolidaysList();
            renderPTOList();
        }

        /**
         * Render the work days grid with toggles and hour inputs
         */
        function renderWorkDaysGrid() {
            const grid = document.getElementById('work-days-grid');
            grid.innerHTML = '';

            for (let i = 0; i < 7; i++) {
                const dayConfig = state.workCalendar.workDays[i];
                const dayCard = document.createElement('div');
                dayCard.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    padding: 8px 6px;
                    background: ${dayConfig.enabled ? '#fff' : '#f3f4f6'};
                    border-radius: 6px;
                    border: 2px solid ${dayConfig.enabled ? '#F5A623' : 'transparent'};
                    transition: all 0.2s;
                    min-width: 54px;
                `;

                const hoursDisplay = dayConfig.enabled
                    ? `<span style="font-size: 11px; color: #1F1F1F;">${dayConfig.hours}</span>
                       <span style="font-size: 10px; color: #6C757D; margin-right: 2px;">hrs</span>
                       <button onclick="openWorkDayHoursModal(${i})" style="background: none; border: none; cursor: pointer; padding: 0; line-height: 1;" title="Edit hours">
                           <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="#6C757D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                               <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                           </svg>
                       </button>`
                    : `<span style="font-size: 11px; color: #9CA3AF;">0 hrs</span>`;

                dayCard.innerHTML = `
                    <div style="font-weight: 600; font-size: 11px; color: ${dayConfig.enabled ? '#1F1F1F' : '#9CA3AF'}; margin-bottom: 4px;">${DAY_ABBREVS[i]}</div>
                    <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 4px;">
                        <input type="checkbox" ${dayConfig.enabled ? 'checked' : ''}
                            onchange="toggleWorkDay(${i}, this.checked)"
                            style="width: 14px; height: 14px; accent-color: #F5A623;">
                    </label>
                    <div style="display: flex; align-items: center; gap: 1px;">
                        ${hoursDisplay}
                    </div>
                `;

                grid.appendChild(dayCard);
            }
        }

        /**
         * Toggle a work day enabled/disabled
         */
        function toggleWorkDay(dayIndex, enabled) {
            state.workCalendar.workDays[dayIndex].enabled = enabled;
            if (!enabled) {
                state.workCalendar.workDays[dayIndex].hours = 0;
                // Check for conflicts when disabling a work day (Issue-82)
                checkWorkDayConflicts(dayIndex);
            } else if (state.workCalendar.workDays[dayIndex].hours === 0) {
                state.workCalendar.workDays[dayIndex].hours = 8; // Default to 8 hours when enabling
            }
            renderWorkDaysGrid();
        }

        /**
         * Check for conflicts when disabling a recurring work day (Issue-82)
         * This checks all future occurrences of the disabled day
         */
        function checkWorkDayConflicts(dayIndex) {
            // Get all dates for this day of week in the next 365 days
            const conflictDates = [];
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            for (let i = 0; i < 365; i++) {
                const checkDate = new Date(today);
                checkDate.setDate(today.getDate() + i);
                if (checkDate.getDay() === dayIndex) {
                    conflictDates.push(formatDateStr(checkDate));
                }
            }

            if (conflictDates.length > 0) {
                checkAndShowConflicts(conflictDates);
            }
        }

        /**
         * Set hours for a specific work day
         */
        function setWorkDayHours(dayIndex, hours) {
            const numHours = parseFloat(hours);
            if (!isNaN(numHours) && numHours >= 0 && numHours <= 24) {
                state.workCalendar.workDays[dayIndex].hours = numHours;
            }
        }

        /**
         * Open the work day hours modal
         */
        function openWorkDayHoursModal(dayIndex) {
            const modal = document.getElementById('workday-hours-modal');
            const titleEl = document.getElementById('workday-hours-modal-title');
            const dayIndexInput = document.getElementById('workday-hours-day-index');
            const hoursInput = document.getElementById('workday-hours-input');

            const dayConfig = state.workCalendar.workDays[dayIndex];
            titleEl.textContent = `Edit ${DAY_NAMES[dayIndex]} Hours`;
            dayIndexInput.value = dayIndex;
            hoursInput.value = dayConfig.hours;

            modal.classList.remove('hidden');
            hoursInput.focus();
            hoursInput.select();
        }

        /**
         * Close the work day hours modal
         */
        function closeWorkDayHoursModal() {
            const modal = document.getElementById('workday-hours-modal');
            modal.classList.add('hidden');
        }

        /**
         * Save work day hours from modal
         */
        function saveWorkDayHours(event) {
            event.preventDefault();
            const dayIndex = parseInt(document.getElementById('workday-hours-day-index').value, 10);
            const hours = parseFloat(document.getElementById('workday-hours-input').value);

            if (!isNaN(hours) && hours >= 0 && hours <= 24) {
                state.workCalendar.workDays[dayIndex].hours = hours;
                renderWorkDaysGrid();
                closeWorkDayHoursModal();
            }
        }

        /**
         * Render the holidays list
         */
        function renderHolidaysList() {
            const list = document.getElementById('holidays-list');
            list.innerHTML = '';

            if (state.workCalendar.holidays.length === 0) {
                list.innerHTML = '<span style="color: #9CA3AF; font-size: 13px;">No holidays added</span>';
                return;
            }

            // Sort holidays by date
            const sortedHolidays = [...state.workCalendar.holidays].sort();

            sortedHolidays.forEach(dateStr => {
                const date = new Date(dateStr + 'T00:00:00');
                const chip = document.createElement('div');
                chip.style.cssText = `
                    display: inline-flex;
                    align-items: center;
                    gap: 6px;
                    padding: 6px 12px;
                    background: #FEE2E2;
                    color: #DC2626;
                    border-radius: 16px;
                    font-size: 13px;
                `;
                chip.innerHTML = `
                    <span>${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}</span>
                    <button onclick="removeHoliday('${dateStr}')" style="background: none; border: none; cursor: pointer; color: #DC2626; font-size: 14px; line-height: 1;">×</button>
                `;
                list.appendChild(chip);
            });
        }

        /**
         * Add a holiday
         */
        function addHoliday() {
            const input = document.getElementById('holiday-date-input');
            const dateStr = input.value;
            if (!dateStr) {
                alert('Please select a date');
                return;
            }

            if (state.workCalendar.holidays.includes(dateStr)) {
                alert('This date is already added as a holiday');
                return;
            }

            state.workCalendar.holidays.push(dateStr);
            input.value = '';
            renderHolidaysList();
        }

        /**
         * Remove a holiday
         */
        function removeHoliday(dateStr) {
            state.workCalendar.holidays = state.workCalendar.holidays.filter(d => d !== dateStr);
            renderHolidaysList();
        }

        /**
         * Render the PTO list
         */
        function renderPTOList() {
            const list = document.getElementById('pto-list');
            list.innerHTML = '';

            if (state.workCalendar.pto.length === 0) {
                list.innerHTML = '<span style="color: #9CA3AF; font-size: 13px;">No PTO days added</span>';
                return;
            }

            // Sort PTO by date
            const sortedPTO = [...state.workCalendar.pto].sort();

            sortedPTO.forEach(dateStr => {
                const date = new Date(dateStr + 'T00:00:00');
                const chip = document.createElement('div');
                chip.style.cssText = `
                    display: inline-flex;
                    align-items: center;
                    gap: 6px;
                    padding: 6px 12px;
                    background: #DBEAFE;
                    color: #1D4ED8;
                    border-radius: 16px;
                    font-size: 13px;
                `;
                chip.innerHTML = `
                    <span>${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}</span>
                    <button onclick="removePTO('${dateStr}')" style="background: none; border: none; cursor: pointer; color: #1D4ED8; font-size: 14px; line-height: 1;">×</button>
                `;
                list.appendChild(chip);
            });
        }

        /**
         * Add a PTO day
         */
        function addPTO() {
            const input = document.getElementById('pto-date-input');
            const dateStr = input.value;
            if (!dateStr) {
                alert('Please select a date');
                return;
            }

            if (state.workCalendar.pto.includes(dateStr)) {
                alert('This date is already added as PTO');
                return;
            }

            state.workCalendar.pto.push(dateStr);
            input.value = '';
            renderPTOList();
        }

        /**
         * Remove a PTO day
         */
        function removePTO(dateStr) {
            state.workCalendar.pto = state.workCalendar.pto.filter(d => d !== dateStr);
            renderPTOList();
        }

        // PTO Range Selection State
        let ptoRangeStart = null;
        let ptoRangeEnd = null;
        let holidayPickerInstance = null;
        let ptoPickerInstance = null;

        /**
         * Initialize DateTimePickers for calendar settings
         */
        function initializeCalendarPickers() {
            const holidayPickerContainer = document.getElementById('holiday-picker-container');
            const ptoPickerContainer = document.getElementById('pto-picker-container');

            // Initialize embedded holiday picker
            if (holidayPickerContainer && !holidayPickerContainer._dtpInitialized) {
                holidayPickerContainer._dtpInitialized = true;
                initializeEmbeddedHolidayPicker(holidayPickerContainer);
            }

            // Initialize PTO picker as embedded inline picker
            if (ptoPickerContainer && !ptoPickerContainer._dtpInitialized) {
                ptoPickerContainer._dtpInitialized = true;
                initializeEmbeddedPTOPicker(ptoPickerContainer);
            }
        }

        /**
         * Initialize embedded Holiday picker (always visible, click to add)
         */
        function initializeEmbeddedHolidayPicker(container) {
            const pickerHTML = `
                <div class="dtp-embedded" style="border: 1px solid #E0E0E0; border-radius: 8px; padding: 12px; background: white; width: 280px;">
                    <div class="dtp-calendar-panel">
                        <div class="dtp-calendar-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <button type="button" class="dtp-nav-btn dtp-prev-month" aria-label="Previous month" style="border: none; background: none; cursor: pointer; padding: 4px 8px;">◀</button>
                            <span class="dtp-month-year" style="font-weight: 600;">
                                <span class="dtp-month-name"></span>
                                <span class="dtp-year"></span>
                            </span>
                            <button type="button" class="dtp-nav-btn dtp-next-month" aria-label="Next month" style="border: none; background: none; cursor: pointer; padding: 4px 8px;">▶</button>
                        </div>
                        <div class="dtp-day-headers" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px; margin-bottom: 4px;"></div>
                        <div class="dtp-calendar-grid" tabindex="0" role="grid" aria-label="Holiday Calendar" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px;"></div>
                    </div>
                    <div class="dtp-footer" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #E0E0E0; height: 36px;"></div>
                </div>
            `;
            container.innerHTML = pickerHTML;

            const picker = {
                container: container,
                calendarGrid: container.querySelector('.dtp-calendar-grid'),
                dayHeaders: container.querySelector('.dtp-day-headers'),
                monthName: container.querySelector('.dtp-month-name'),
                yearDisplay: container.querySelector('.dtp-year'),
                viewDate: new Date(),
                focusedDate: new Date(),

                renderDayHeaders() {
                    this.dayHeaders.innerHTML = DTP_DAY_NAMES.map(day =>
                        `<span style="font-size: 11px; font-weight: 600; color: #888; text-align: center;">${day}</span>`
                    ).join('');
                },

                renderMonthYearHeader() {
                    this.monthName.textContent = DTP_MONTH_NAMES[this.viewDate.getMonth()] + ' ';
                    this.yearDisplay.textContent = this.viewDate.getFullYear();
                },

                renderCalendar() {
                    const year = this.viewDate.getFullYear();
                    const month = this.viewDate.getMonth();
                    const firstDay = new Date(year, month, 1);
                    const lastDay = new Date(year, month + 1, 0);

                    let startDay = firstDay.getDay();
                    if (startDay === 0) startDay = 7;
                    startDay = startDay - 1;

                    let html = '';
                    let dayCount = 1;
                    let nextMonthDay = 1;
                    const prevMonthLastDay = new Date(year, month, 0).getDate();

                    for (let i = 0; i < 42; i++) {
                        let dayNum, dateObj, classes = ['dtp-day'];
                        const baseStyle = 'width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border: 1px solid transparent; border-radius: 4px; cursor: pointer; font-size: 13px; background: none;';

                        if (i < startDay) {
                            dayNum = prevMonthLastDay - startDay + i + 1;
                            dateObj = new Date(year, month - 1, dayNum);
                            classes.push('other-month');
                        } else if (dayCount <= lastDay.getDate()) {
                            dayNum = dayCount;
                            dateObj = new Date(year, month, dayNum);
                            dayCount++;
                        } else {
                            dayNum = nextMonthDay;
                            dateObj = new Date(year, month + 1, dayNum);
                            classes.push('other-month');
                            nextMonthDay++;
                        }

                        const dateKey = formatDateStr(dateObj);
                        let extraStyle = '';

                        // Check if it's a weekend (non-work day by default)
                        const dayOfWeek = dateObj.getDay();
                        if (!state.workCalendar.workDays[dayOfWeek].enabled) {
                            classes.push('disabled-day');
                            extraStyle += 'color: #D1D5DB; background: #F3F4F6; cursor: not-allowed; pointer-events: none;';
                        }

                        // Check if already a holiday
                        if (state.workCalendar.holidays.includes(dateKey)) {
                            classes.push('holiday-added');
                            extraStyle += 'background: #FEE2E2; color: #DC2626; font-weight: 600;';
                        }

                        // Check if other month
                        if (classes.includes('other-month')) {
                            extraStyle += 'color: #999;';
                        }

                        html += `<button type="button" class="${classes.join(' ')}" data-date="${dateObj.toISOString()}" tabindex="-1" style="${baseStyle}${extraStyle}">${dayNum}</button>`;
                    }

                    this.calendarGrid.innerHTML = html;
                    this.renderMonthYearHeader();
                },

                navigateMonth(delta) {
                    this.viewDate.setMonth(this.viewDate.getMonth() + delta);
                    this.renderCalendar();
                }
            };

            holidayPickerInstance = picker;

            container.querySelector('.dtp-prev-month').addEventListener('click', () => picker.navigateMonth(-1));
            container.querySelector('.dtp-next-month').addEventListener('click', () => picker.navigateMonth(1));

            // Click to add/remove holiday
            picker.calendarGrid.addEventListener('click', (e) => {
                const dayEl = e.target.closest('.dtp-day');
                if (!dayEl || dayEl.classList.contains('disabled-day')) return;
                const date = new Date(dayEl.dataset.date);
                handleHolidayDateClickEmbedded(date, picker);
            });

            // Keyboard navigation
            picker.calendarGrid.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const focused = picker.calendarGrid.querySelector('.dtp-day:focus');
                    if (focused && !focused.classList.contains('disabled-day')) {
                        const date = new Date(focused.dataset.date);
                        handleHolidayDateClickEmbedded(date, picker);
                    }
                }
            });

            picker.renderDayHeaders();
            picker.renderCalendar();
        }

        /**
         * Handle holiday date click from embedded picker
         */
        function handleHolidayDateClickEmbedded(date, picker) {
            const dateStr = formatDateStr(date);
            const dayOfWeek = date.getDay();

            if (!state.workCalendar.workDays[dayOfWeek].enabled) {
                return;
            }

            if (state.workCalendar.holidays.includes(dateStr)) {
                // Already a holiday - remove it (no conflict check needed for removal)
                state.workCalendar.holidays = state.workCalendar.holidays.filter(d => d !== dateStr);
                picker.renderCalendar();
                renderHolidaysList();
                if (ptoPickerInstance) ptoPickerInstance.renderCalendar();
            } else {
                // Check if this date is already a PTO day
                if (state.workCalendar.pto.includes(dateStr)) {
                    // Show confirmation dialog
                    const formattedDate = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                    if (confirm(`${formattedDate} is currently marked as PTO. Adding it as a holiday will remove it from your PTO days. Continue?`)) {
                        // Remove from PTO
                        state.workCalendar.pto = state.workCalendar.pto.filter(d => d !== dateStr);
                        renderPTOList();
                        // Add as holiday
                        state.workCalendar.holidays.push(dateStr);
                        picker.renderCalendar();
                        renderHolidaysList();
                        if (ptoPickerInstance) ptoPickerInstance.renderCalendar();
                        // Check for conflicts (Issue-82)
                        checkAndShowConflicts([dateStr]);
                    }
                } else {
                    // Add as holiday
                    state.workCalendar.holidays.push(dateStr);
                    picker.renderCalendar();
                    renderHolidaysList();
                    if (ptoPickerInstance) ptoPickerInstance.renderCalendar();
                    // Check for conflicts (Issue-82)
                    checkAndShowConflicts([dateStr]);
                }
            }
        }

        /**
         * Initialize embedded PTO picker (always visible, no popup)
         */
        function initializeEmbeddedPTOPicker(container) {
            // Create a minimal picker structure
            const pickerHTML = `
                <div class="dtp-embedded" style="border: 1px solid #E0E0E0; border-radius: 8px; padding: 12px; background: white; width: 280px;">
                    <div class="dtp-calendar-panel">
                        <div class="dtp-calendar-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <button type="button" class="dtp-nav-btn dtp-prev-month" aria-label="Previous month" style="border: none; background: none; cursor: pointer; padding: 4px 8px;">◀</button>
                            <span class="dtp-month-year" style="font-weight: 600;">
                                <span class="dtp-month-name"></span>
                                <span class="dtp-year"></span>
                            </span>
                            <button type="button" class="dtp-nav-btn dtp-next-month" aria-label="Next month" style="border: none; background: none; cursor: pointer; padding: 4px 8px;">▶</button>
                        </div>
                        <div class="dtp-day-headers" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px; margin-bottom: 4px;"></div>
                        <div class="dtp-calendar-grid" tabindex="0" role="grid" aria-label="Calendar" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px;"></div>
                    </div>
                    <div class="dtp-footer" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #E0E0E0;">
                        <button type="button" class="dtp-select-btn btn btn-primary" style="width: 100%;">Add PTO</button>
                    </div>
                </div>
            `;
            container.innerHTML = pickerHTML;

            // Create a picker-like object to manage state
            const picker = {
                container: container,
                calendarGrid: container.querySelector('.dtp-calendar-grid'),
                dayHeaders: container.querySelector('.dtp-day-headers'),
                monthName: container.querySelector('.dtp-month-name'),
                yearDisplay: container.querySelector('.dtp-year'),
                selectBtn: container.querySelector('.dtp-select-btn'),
                viewDate: new Date(),
                focusedDate: new Date(),

                renderDayHeaders() {
                    this.dayHeaders.innerHTML = DTP_DAY_NAMES.map(day =>
                        `<span style="font-size: 11px; font-weight: 600; color: #888; text-align: center;">${day}</span>`
                    ).join('');
                },

                renderMonthYearHeader() {
                    this.monthName.textContent = DTP_MONTH_NAMES[this.viewDate.getMonth()] + ' ';
                    this.yearDisplay.textContent = this.viewDate.getFullYear();
                },

                renderCalendar() {
                    const year = this.viewDate.getFullYear();
                    const month = this.viewDate.getMonth();
                    const firstDay = new Date(year, month, 1);
                    const lastDay = new Date(year, month + 1, 0);
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);

                    let startDay = firstDay.getDay();
                    if (startDay === 0) startDay = 7;
                    startDay = startDay - 1;

                    let html = '';
                    let dayCount = 1;
                    let nextMonthDay = 1;
                    const prevMonthLastDay = new Date(year, month, 0).getDate();

                    for (let i = 0; i < 42; i++) {
                        let dayNum, dateObj, classes = ['dtp-day'];
                        const baseStyle = 'width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border: 1px solid transparent; border-radius: 4px; cursor: pointer; font-size: 13px; background: none;';

                        if (i < startDay) {
                            dayNum = prevMonthLastDay - startDay + i + 1;
                            dateObj = new Date(year, month - 1, dayNum);
                            classes.push('other-month');
                        } else if (dayCount <= lastDay.getDate()) {
                            dayNum = dayCount;
                            dateObj = new Date(year, month, dayNum);
                            dayCount++;
                        } else {
                            dayNum = nextMonthDay;
                            dateObj = new Date(year, month + 1, dayNum);
                            classes.push('other-month');
                            nextMonthDay++;
                        }

                        const dateKey = formatDateStr(dateObj);
                        let extraStyle = '';

                        // Check if disabled (non-work day)
                        if (!isWorkDay(dateObj)) {
                            classes.push('disabled-day');
                            extraStyle += 'color: #D1D5DB; background: #F3F4F6; cursor: not-allowed; pointer-events: none; text-decoration: line-through;';
                        }

                        // Check if other month
                        if (classes.includes('other-month')) {
                            extraStyle += 'color: #999;';
                        }

                        // Range highlighting
                        if (ptoRangeStart) {
                            const startKey = formatDateStr(ptoRangeStart);
                            const endKey = ptoRangeEnd ? formatDateStr(ptoRangeEnd) : null;

                            if (dateKey === startKey) {
                                classes.push('range-start');
                                extraStyle += 'background: #F5A623; color: white; border-radius: 50% 0 0 50%;';
                            }
                            if (endKey && dateKey === endKey) {
                                classes.push('range-end');
                                extraStyle += 'background: #F5A623; color: white; border-radius: 0 50% 50% 0;';
                            }
                            if (dateKey === startKey && endKey && dateKey === endKey) {
                                extraStyle += 'border-radius: 50%;';
                            }

                            // In range
                            if (endKey) {
                                const startTime = ptoRangeStart.getTime();
                                const endTime = ptoRangeEnd.getTime();
                                const [rangeMin, rangeMax] = startTime < endTime ? [startTime, endTime] : [endTime, startTime];
                                const dateTime = dateObj.getTime();
                                if (dateTime > rangeMin && dateTime < rangeMax) {
                                    classes.push('in-range');
                                    extraStyle += 'background: #FEF3C7; color: #92400E; border-radius: 0;';
                                }
                            }
                        }

                        html += `<button type="button" class="${classes.join(' ')}" data-date="${dateObj.toISOString()}" tabindex="-1" style="${baseStyle}${extraStyle}">${dayNum}</button>`;
                    }

                    this.calendarGrid.innerHTML = html;
                    this.renderMonthYearHeader();
                },

                navigateMonth(delta) {
                    this.viewDate.setMonth(this.viewDate.getMonth() + delta);
                    this.renderCalendar();
                }
            };

            // Store reference
            ptoPickerInstance = picker;

            // Set up event listeners
            container.querySelector('.dtp-prev-month').addEventListener('click', () => picker.navigateMonth(-1));
            container.querySelector('.dtp-next-month').addEventListener('click', () => picker.navigateMonth(1));

            picker.calendarGrid.addEventListener('click', (e) => {
                const dayEl = e.target.closest('.dtp-day');
                if (!dayEl || dayEl.classList.contains('disabled-day')) return;
                const date = new Date(dayEl.dataset.date);
                handlePTODateClick(date, picker);
            });

            // Keyboard navigation for PTO picker
            picker.calendarGrid.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const focused = picker.calendarGrid.querySelector('.dtp-day:focus');
                    if (focused && !focused.classList.contains('disabled-day')) {
                        const date = new Date(focused.dataset.date);
                        handlePTODateClick(date, picker);
                        // If we have a complete range, add it
                        if (ptoRangeStart && ptoRangeEnd) {
                            addPTOFromRange();
                        }
                    }
                }
            });

            picker.selectBtn.addEventListener('click', () => {
                addPTOFromRange();
            });

            // Initial render
            picker.renderDayHeaders();
            picker.renderCalendar();
        }

        /**
         * Add PTO from the current range selection (no inputs needed)
         */
        function addPTOFromRange() {
            if (!ptoRangeStart) {
                alert('Please select a start date');
                return;
            }

            // Track newly added dates for conflict check (Issue-82)
            const addedDates = [];

            // If only start date, add single day
            if (!ptoRangeEnd) {
                const dateStr = formatDateStr(ptoRangeStart);

                if (state.workCalendar.pto.includes(dateStr)) {
                    alert('This date is already added as PTO');
                    return;
                }

                const dayOfWeek = ptoRangeStart.getDay();
                if (!state.workCalendar.workDays[dayOfWeek].enabled) {
                    alert('This date is not a work day');
                    return;
                }

                if (state.workCalendar.holidays.includes(dateStr)) {
                    alert('This date is a holiday');
                    return;
                }

                state.workCalendar.pto.push(dateStr);
                addedDates.push(dateStr);
                clearPTORangeSelection();
                renderPTOList();
                // Check for conflicts (Issue-82)
                if (addedDates.length > 0) {
                    checkAndShowConflicts(addedDates);
                }
                return;
            }

            // Add range
            const current = new Date(ptoRangeStart);
            while (current <= ptoRangeEnd) {
                const dateStr = formatDateStr(current);
                const dayOfWeek = current.getDay();
                if (state.workCalendar.workDays[dayOfWeek].enabled &&
                    !state.workCalendar.holidays.includes(dateStr) &&
                    !state.workCalendar.pto.includes(dateStr)) {
                    state.workCalendar.pto.push(dateStr);
                    addedDates.push(dateStr);
                }
                current.setDate(current.getDate() + 1);
            }

            clearPTORangeSelection();
            renderPTOList();
            // Check for conflicts (Issue-82)
            if (addedDates.length > 0) {
                checkAndShowConflicts(addedDates);
            }
        }

        /**
         * Sync input values to range state (legacy - kept for compatibility)
         */
        function syncInputsToRangeState() {
            // No longer needed - range state is managed directly by clicks
        }

        /**
         * Sync range state to input values (legacy - kept for compatibility)
         */
        function syncRangeStateToInputs() {
            // No longer needed - no input fields to sync
        }

        /**
         * Add PTO from the input fields
         */
        function addPTOFromInputs() {
            syncInputsToRangeState();

            if (!ptoRangeStart) {
                alert('Please select a start date');
                return;
            }

            // If only start date, add single day
            if (!ptoRangeEnd) {
                const dateStr = formatDateStr(ptoRangeStart);

                if (state.workCalendar.pto.includes(dateStr)) {
                    alert('This date is already added as PTO');
                    return;
                }

                const dayOfWeek = ptoRangeStart.getDay();
                if (!state.workCalendar.workDays[dayOfWeek].enabled) {
                    alert('This date is not a work day');
                    return;
                }

                if (state.workCalendar.holidays.includes(dateStr)) {
                    alert('This date is a holiday');
                    return;
                }

                state.workCalendar.pto.push(dateStr);
                clearPTORangeSelection();
                renderPTOList();
                return;
            }

            // Add range
            const current = new Date(ptoRangeStart);
            let addedCount = 0;
            while (current <= ptoRangeEnd) {
                const dateStr = formatDateStr(current);
                const dayOfWeek = current.getDay();
                if (state.workCalendar.workDays[dayOfWeek].enabled &&
                    !state.workCalendar.holidays.includes(dateStr) &&
                    !state.workCalendar.pto.includes(dateStr)) {
                    state.workCalendar.pto.push(dateStr);
                    addedCount++;
                }
                current.setDate(current.getDate() + 1);
            }

            clearPTORangeSelection();
            renderPTOList();
        }

        /**
         * Handle holiday date click from picker
         * Automatically adds the selected date as a holiday
         */
        function handleHolidayDateClick(date, picker) {
            const input = document.getElementById('holiday-date-input');
            const formattedDateStr = formatDateStr(date);

            if (state.workCalendar.holidays.includes(formattedDateStr)) {
                alert('This date is already added as a holiday');
                picker.close();
                return;
            }

            // Check if it's a work day (but exclude existing holidays from the check)
            const dayOfWeek = date.getDay();
            if (!state.workCalendar.workDays[dayOfWeek].enabled) {
                alert('This date is already a non-work day (weekend)');
                picker.close();
                return;
            }

            if (state.workCalendar.pto.includes(formattedDateStr)) {
                alert('This date is already marked as PTO');
                picker.close();
                return;
            }

            state.workCalendar.holidays.push(formattedDateStr);
            input.value = '';
            picker.selectedDate = null;
            picker.displayInput.value = "";
            picker.close();
            renderHolidaysList();
        }

        /**
         * Handle confirm (Select button click) in PTO picker
         * Adds the selected range as PTO days
         */
        function handlePTOConfirm(picker) {
            addPTOFromPicker();
            picker.close();
        }

        /**
         * Handle date click in PTO picker for range selection
         * First click sets start, second click sets end
         */
        function handlePTODateClick(date, picker) {
            const dateStr = formatDateStr(date);
            if (state.workCalendar.holidays.includes(dateStr)) {
                return;
            }

            if (!ptoRangeStart) {
                // First click: set range start
                ptoRangeStart = new Date(date);
                ptoRangeEnd = null;
                syncRangeStateToInputs();
                updatePTORangeStatus();
                picker.renderCalendar();
            } else if (!ptoRangeEnd) {
                // Second click: set range end
                ptoRangeEnd = new Date(date);
                if (ptoRangeStart > ptoRangeEnd) {
                    [ptoRangeStart, ptoRangeEnd] = [ptoRangeEnd, ptoRangeStart];
                }
                syncRangeStateToInputs();
                updatePTORangeStatus();
                picker.renderCalendar();
            } else {
                // Third click: reset and start new range
                ptoRangeStart = new Date(date);
                ptoRangeEnd = null;
                syncRangeStateToInputs();
                updatePTORangeStatus();
                picker.renderCalendar();
            }
        }

        /**
         * Update PTO range status display
         */
        function updatePTORangeStatus() {
            const statusEl = document.getElementById('pto-range-status');
            if (!statusEl) return;

            if (ptoRangeStart && !ptoRangeEnd) {
                const startStr = ptoRangeStart.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                statusEl.textContent = 'Start: ' + startStr + ' - Select end date or press Enter/click Add PTO for single day';
                statusEl.style.display = 'block';
            } else if (ptoRangeStart && ptoRangeEnd) {
                const startStr = ptoRangeStart.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                const endStr = ptoRangeEnd.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                const count = countWorkDaysInRange(ptoRangeStart, ptoRangeEnd);
                statusEl.textContent = 'Range: ' + startStr + ' to ' + endStr + ' (' + count + ' work day' + (count !== 1 ? 's' : '') + ') - Press Enter or click Add PTO';
                statusEl.style.display = 'block';
            } else {
                statusEl.textContent = 'Select a start date in the calendar or enter dates manually';
                statusEl.style.display = 'block';
            }
        }

        /**
         * Count work days in a date range (excluding holidays and existing PTO)
         */
        function countWorkDaysInRange(start, end) {
            let count = 0;
            const current = new Date(start);
            while (current <= end) {
                const dateStr = formatDateStr(current);
                if (isWorkDay(current) && !state.workCalendar.holidays.includes(dateStr) && !state.workCalendar.pto.includes(dateStr)) {
                    count++;
                }
                current.setDate(current.getDate() + 1);
            }
            return count;
        }

        /**
         * Format date as YYYY-MM-DD string
         */
        function formatDateStr(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return year + '-' + month + '-' + day;
        }

        /**
         * Add holiday from DateTimePicker
         */
        function addHolidayFromPicker() {
            const input = document.getElementById('holiday-date-input');
            const dateStr = input.value;
            if (!dateStr) {
                alert('Please select a date');
                return;
            }

            if (state.workCalendar.holidays.includes(dateStr)) {
                alert('This date is already added as a holiday');
                return;
            }

            const date = new Date(dateStr + 'T00:00:00');
            if (!isWorkDay(date)) {
                alert('This date is already a non-work day');
                return;
            }

            state.workCalendar.holidays.push(dateStr);
            input.value = '';
            if (holidayPickerInstance) {
                holidayPickerInstance.selectedDate = null;
                holidayPickerInstance.displayInput.value = "";
            }
            renderHolidaysList();
        }

        /**
         * Add PTO from DateTimePicker (supports range selection)
         */
        function addPTOFromPicker() {
            if (ptoRangeStart && ptoRangeEnd) {
                const current = new Date(ptoRangeStart);
                let addedCount = 0;
                while (current <= ptoRangeEnd) {
                    const dateStr = formatDateStr(current);
                    if (isWorkDay(current) && !state.workCalendar.holidays.includes(dateStr) && !state.workCalendar.pto.includes(dateStr)) {
                        state.workCalendar.pto.push(dateStr);
                        addedCount++;
                    }
                    current.setDate(current.getDate() + 1);
                }
                clearPTORangeSelection();
                renderPTOList();
            } else if (ptoRangeStart) {
                const dateStr = formatDateStr(ptoRangeStart);
                if (state.workCalendar.pto.includes(dateStr)) {
                    alert('This date is already added as PTO');
                    return;
                }
                if (!isWorkDay(ptoRangeStart)) {
                    alert('This date is not a work day');
                    return;
                }
                if (state.workCalendar.holidays.includes(dateStr)) {
                    alert('This date is a holiday');
                    return;
                }
                state.workCalendar.pto.push(dateStr);
                clearPTORangeSelection();
                renderPTOList();
            } else {
                const input = document.getElementById('pto-date-input');
                const dateStr = input.value;
                if (!dateStr) {
                    alert('Please select a date');
                    return;
                }
                if (state.workCalendar.pto.includes(dateStr)) {
                    alert('This date is already added as PTO');
                    return;
                }
                state.workCalendar.pto.push(dateStr);
                input.value = '';
                renderPTOList();
            }
        }

        /**
         * Clear PTO range selection
         */
        function clearPTORangeSelection() {
            ptoRangeStart = null;
            ptoRangeEnd = null;

            // Clear the start and end date input fields
            const startInput = document.getElementById('pto-start-date');
            const endInput = document.getElementById('pto-end-date');
            if (startInput) startInput.value = '';
            if (endInput) endInput.value = '';

            // Re-render the embedded picker calendar
            if (ptoPickerInstance) {
                ptoPickerInstance.renderCalendar();
            }

            updatePTORangeStatus();
            const clearBtn = document.getElementById('pto-clear-range');
            if (clearBtn) clearBtn.style.display = 'none';
        }

        /**
         * Save calendar settings
         */
        function saveCalendarSettings() {
            saveStateToIndexedDB().then(() => {
                alert('Calendar settings saved successfully!');
            }).catch(err => {
                Logger.error('Failed to save calendar settings:', err);
                alert('Failed to save calendar settings. Please try again.');
            });
        }

        /**
         * Check if a date is a valid work day
         * @param {Date} date - The date to check
         * @returns {boolean} - True if the date is a valid work day
         */
        function isWorkDay(date) {
            const dayOfWeek = date.getDay();
            const dateStr = formatDateStr(date);

            // Check if day of week is enabled
            if (!state.workCalendar.workDays[dayOfWeek].enabled) {
                return false;
            }

            // Check if it's a holiday
            if (state.workCalendar.holidays.includes(dateStr)) {
                return false;
            }

            // Check if it's a PTO day
            if (state.workCalendar.pto.includes(dateStr)) {
                return false;
            }

            return true;
        }

        /**
         * Get the next work day from a given date
         * @param {Date} date - The starting date
         * @returns {Date} - The next work day
         */
        function getNextWorkDay(date) {
            const nextDay = new Date(date);
            nextDay.setDate(nextDay.getDate() + 1);

            // Safety: limit to 365 iterations to prevent infinite loops
            let iterations = 0;
            while (!isWorkDay(nextDay) && iterations < 365) {
                nextDay.setDate(nextDay.getDate() + 1);
                iterations++;
            }

            return nextDay;
        }

        /**
         * Get work hours for a specific date
         * @param {Date} date - The date to check
         * @returns {number} - Hours available for that day (0 if not a work day)
         */
        function getWorkHoursForDate(date) {
            if (!isWorkDay(date)) {
                return 0;
            }
            const dayOfWeek = date.getDay();
            return state.workCalendar.workDays[dayOfWeek].hours;
        }

        /**
         * Get the closest valid work day for a date (same day if valid, next if not)
         * @param {Date} date - The date to check
         * @returns {Date} - The closest valid work day
         */
        function getClosestWorkDay(date) {
            const checkDate = new Date(date);
            checkDate.setHours(0, 0, 0, 0);

            // If it's already a work day, return same date
            if (isWorkDay(checkDate)) {
                return new Date(date); // Return original date with time preserved
            }

            // Otherwise find the next work day
            let iterations = 0;
            while (!isWorkDay(checkDate) && iterations < 365) {
                checkDate.setDate(checkDate.getDate() + 1);
                iterations++;
            }

            // Preserve the original time
            const result = new Date(checkDate);
            result.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
            return result;
        }

        // ========================================
        // CONFLICT DETECTION FUNCTIONS (Issue-82)
        // ========================================

        // Store detected conflicts for modal operations
        let pendingConflicts = [];

        /**
         * Detect conflicts between exclusion dates and scheduled items
         * @param {string[]} newExclusionDates - Array of date strings (YYYY-MM-DD) to check
         * @returns {object} Object with conflicts grouped by type
         */
        function detectExclusionConflicts(newExclusionDates) {
            const conflicts = {
                todos: [],
                meetings: [],
                recurringMeetings: []
            };

            if (!newExclusionDates || newExclusionDates.length === 0) {
                return conflicts;
            }

            // Create a Set for O(1) lookup
            const exclusionSet = new Set(newExclusionDates);

            // Check todos with deadlines
            state.todos.forEach(todo => {
                if (todo.completed || todo.dropped) return;

                const deadline = todo.deadline || todo.dueDate;
                if (!deadline) return;

                const deadlineDate = new Date(deadline);
                const dateStr = formatDateStr(deadlineDate);

                if (exclusionSet.has(dateStr)) {
                    conflicts.todos.push({
                        type: 'todo',
                        id: todo.id,
                        title: todo.title,
                        date: deadline,
                        dateStr: dateStr
                    });
                }
            });

            // Check meetings
            state.meetings.forEach(meeting => {
                const meetingDate = new Date(meeting.date);
                const dateStr = formatDateStr(meetingDate);

                if (exclusionSet.has(dateStr)) {
                    if (meeting.recurringGroupId) {
                        conflicts.recurringMeetings.push({
                            type: 'recurring',
                            id: meeting.id,
                            title: meeting.title,
                            date: meeting.date,
                            dateStr: dateStr,
                            recurringGroupId: meeting.recurringGroupId,
                            duration: meeting.duration
                        });
                    } else {
                        conflicts.meetings.push({
                            type: 'meeting',
                            id: meeting.id,
                            title: meeting.title,
                            date: meeting.date,
                            dateStr: dateStr,
                            duration: meeting.duration
                        });
                    }
                }
            });

            return conflicts;
        }

        /**
         * Check if there are any conflicts
         * @param {object} conflicts - Conflicts object from detectExclusionConflicts
         * @returns {boolean}
         */
        function hasConflicts(conflicts) {
            return conflicts.todos.length > 0 ||
                   conflicts.meetings.length > 0 ||
                   conflicts.recurringMeetings.length > 0;
        }

        /**
         * Get total count of conflicts
         * @param {object} conflicts - Conflicts object from detectExclusionConflicts
         * @returns {number}
         */
        function getTotalConflictCount(conflicts) {
            return conflicts.todos.length + conflicts.meetings.length + conflicts.recurringMeetings.length;
        }

        /**
         * Format a date for display in conflict modal
         * @param {string} dateStr - ISO date string
         * @returns {string}
         */
        function formatConflictDate(dateStr) {
            const date = new Date(dateStr);
            return date.toLocaleDateString('en-US', {
                weekday: 'short',
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit'
            });
        }

        /**
         * Open the conflict resolution modal
         * @param {object} conflicts - Conflicts object from detectExclusionConflicts
         */
        function openConflictResolutionModal(conflicts) {
            pendingConflicts = [];

            // Build flat list of all conflicts
            conflicts.todos.forEach(c => pendingConflicts.push({ ...c, selected: true }));
            conflicts.meetings.forEach(c => pendingConflicts.push({ ...c, selected: true }));
            conflicts.recurringMeetings.forEach(c => pendingConflicts.push({ ...c, selected: true }));

            renderConflictItems(conflicts);
            document.getElementById('conflict-resolution-modal').classList.remove('hidden');
        }

        /**
         * Close the conflict resolution modal
         */
        function closeConflictResolutionModal() {
            document.getElementById('conflict-resolution-modal').classList.add('hidden');
            pendingConflicts = [];
        }

        /**
         * Render conflict items in the modal
         * @param {object} conflicts - Conflicts object
         */
        function renderConflictItems(conflicts) {
            const container = document.getElementById('conflict-items-container');
            let html = '';

            // Todos group
            if (conflicts.todos.length > 0) {
                html += `
                    <div class="conflict-group">
                        <div class="conflict-group-header">
                            <span class="group-icon">📋</span>
                            <span>Todos with Deadlines</span>
                            <span class="group-count">${conflicts.todos.length}</span>
                        </div>
                        <div class="conflict-items-list">
                            ${conflicts.todos.map(item => renderConflictItem(item)).join('')}
                        </div>
                    </div>
                `;
            }

            // Meetings group
            if (conflicts.meetings.length > 0) {
                html += `
                    <div class="conflict-group">
                        <div class="conflict-group-header">
                            <span class="group-icon">📅</span>
                            <span>Scheduled Meetings</span>
                            <span class="group-count">${conflicts.meetings.length}</span>
                        </div>
                        <div class="conflict-items-list">
                            ${conflicts.meetings.map(item => renderConflictItem(item)).join('')}
                        </div>
                    </div>
                `;
            }

            // Recurring meetings group
            if (conflicts.recurringMeetings.length > 0) {
                html += `
                    <div class="conflict-group">
                        <div class="conflict-group-header">
                            <span class="group-icon">🔄</span>
                            <span>Recurring Meeting Occurrences</span>
                            <span class="group-count">${conflicts.recurringMeetings.length}</span>
                        </div>
                        <div class="conflict-items-list">
                            ${conflicts.recurringMeetings.map(item => renderConflictItem(item)).join('')}
                        </div>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        /**
         * Render a single conflict item
         * @param {object} item - Conflict item
         * @returns {string} HTML string
         */
        function renderConflictItem(item) {
            const typeLabel = item.type === 'todo' ? 'Todo' :
                             item.type === 'meeting' ? 'Meeting' : 'Recurring';
            const typeClass = item.type;
            const durationDisplay = item.duration ? ` (${formatDurationDisplay(item.duration)})` : '';

            return `
                <div class="conflict-item selected" data-id="${item.id}" data-type="${item.type}">
                    <input type="checkbox" checked onchange="toggleConflictItem('${item.id}')">
                    <div class="conflict-item-info">
                        <div class="conflict-item-title">${escapeHtml(item.title)}${durationDisplay}</div>
                        <div class="conflict-item-meta">
                            <span class="conflict-item-date">📅 ${formatConflictDate(item.date)}</span>
                        </div>
                    </div>
                    <span class="conflict-item-type-badge ${typeClass}">${typeLabel}</span>
                </div>
            `;
        }

        /**
         * Toggle a conflict item's selection
         * @param {string} id - Item ID
         */
        function toggleConflictItem(id) {
            const item = pendingConflicts.find(c => c.id === id);
            if (item) {
                item.selected = !item.selected;
                const el = document.querySelector(`.conflict-item[data-id="${id}"]`);
                if (el) {
                    el.classList.toggle('selected', item.selected);
                }
            }
        }

        /**
         * Select all conflict items
         */
        function selectAllConflicts() {
            pendingConflicts.forEach(item => {
                item.selected = true;
            });
            document.querySelectorAll('.conflict-item').forEach(el => {
                el.classList.add('selected');
                el.querySelector('input[type="checkbox"]').checked = true;
            });
        }

        /**
         * Deselect all conflict items
         */
        function deselectAllConflicts() {
            pendingConflicts.forEach(item => {
                item.selected = false;
            });
            document.querySelectorAll('.conflict-item').forEach(el => {
                el.classList.remove('selected');
                el.querySelector('input[type="checkbox"]').checked = false;
            });
        }

        /**
         * Move selected conflict items to next available work day
         */
        function moveSelectedConflicts() {
            const selectedItems = pendingConflicts.filter(item => item.selected);
            if (selectedItems.length === 0) {
                alert('No items selected. Please select items to move.');
                return;
            }

            let movedCount = 0;

            selectedItems.forEach(item => {
                const currentDate = new Date(item.date);
                const nextWorkDay = getNextWorkDay(currentDate);

                if (item.type === 'todo') {
                    const todo = state.todos.find(t => t.id === item.id);
                    if (todo) {
                        // Preserve time from original deadline
                        nextWorkDay.setHours(currentDate.getHours(), currentDate.getMinutes(), 0, 0);
                        todo.deadline = nextWorkDay.toISOString();
                        todo.updatedAt = new Date().toISOString();
                        movedCount++;
                    }
                } else if (item.type === 'meeting' || item.type === 'recurring') {
                    const meeting = state.meetings.find(m => m.id === item.id);
                    if (meeting) {
                        // Preserve time from original meeting
                        nextWorkDay.setHours(currentDate.getHours(), currentDate.getMinutes(), 0, 0);
                        meeting.date = nextWorkDay.toISOString();
                        meeting.updatedAt = new Date().toISOString();
                        movedCount++;
                    }
                }
            });

            closeConflictResolutionModal();

            // Refresh UI
            if (state.currentPage === 'todos') {
                renderTodos();
                renderMeetingsList();
                renderDailyLoadKPI();
            }

            // Show confirmation
            if (movedCount > 0) {
                Logger.log(`Moved ${movedCount} item(s) to next available work day`);
            }
        }

        /**
         * Delete selected conflict items
         */
        function deleteSelectedConflicts() {
            const selectedItems = pendingConflicts.filter(item => item.selected);
            if (selectedItems.length === 0) {
                alert('No items selected. Please select items to delete.');
                return;
            }

            let deletedCount = 0;

            selectedItems.forEach(item => {
                if (item.type === 'todo') {
                    const index = state.todos.findIndex(t => t.id === item.id);
                    if (index !== -1) {
                        state.todos.splice(index, 1);
                        deletedCount++;
                    }
                } else if (item.type === 'meeting' || item.type === 'recurring') {
                    const index = state.meetings.findIndex(m => m.id === item.id);
                    if (index !== -1) {
                        state.meetings.splice(index, 1);
                        deletedCount++;
                    }
                }
            });

            closeConflictResolutionModal();

            // Refresh UI
            if (state.currentPage === 'todos') {
                renderTodos();
                renderMeetingsList();
                renderDailyLoadKPI();
            }

            // Show confirmation
            if (deletedCount > 0) {
                Logger.log(`Deleted ${deletedCount} item(s)`);
            }
        }

        /**
         * Check for conflicts and show the modal if any are found
         * Helper function to be called after adding exclusion dates
         * @param {string[]} newExclusionDates - Array of date strings to check
         */
        function checkAndShowConflicts(newExclusionDates) {
            const conflicts = detectExclusionConflicts(newExclusionDates);
            if (hasConflicts(conflicts)) {
                openConflictResolutionModal(conflicts);
            }
        }

        /**
         * Migrate todos with very_low effort to minimal (Issue-78)
         * This preserves the 30-minute intent for existing todos
         * @returns {object} Migration summary
         */
        function migrateEffortVeryLowToMinimal() {
            const migrated = [];

            state.todos = state.todos.map(todo => {
                if (todo.effort !== 'very_low') return todo;

                migrated.push({
                    todoTitle: todo.title,
                    oldEffort: 'Very Low (30 min)',
                    newEffort: 'Minimal Work (30 min)'
                });

                return {
                    ...todo,
                    effort: 'minimal',
                    updatedAt: new Date().toISOString()
                };
            });

            return {
                migratedCount: migrated.length,
                items: migrated
            };
        }

        // ========================================
        // STORAGE SECTION FUNCTIONS
        // ========================================

        async function renderStorageSection() {
            const stats = await getStorageStats();
            document.getElementById('storage-size').textContent = formatBytes(stats.estimatedSize);
            document.getElementById('storage-todos').textContent = stats.todoCount;
            document.getElementById('storage-engagements').textContent = stats.engagementCount;
            // Set debug logging toggle state (Issue-64)
            const debugToggle = document.getElementById('debug-logging-toggle');
            if (debugToggle) {
                debugToggle.checked = state.settings.debugLogging || false;
            }
        }

        function openClearStateModal() {
            document.getElementById('clear-state-modal').classList.remove('hidden');
        }

        function closeClearStateModal() {
            document.getElementById('clear-state-modal').classList.add('hidden');
        }

        // Toggle debug logging (Issue-64)
        function toggleDebugLogging(enabled) {
            Logger.debug = enabled;
            state.settings.debugLogging = enabled;
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save debug logging setting:', err));
        }

        // ========================================
        // HOLIDAY TEMPLATE FUNCTIONS (Issue-76)
        // ========================================

        /**
         * Calculate Easter Sunday for a given year using the Anonymous Gregorian algorithm
         * @param {number} year - The year to calculate Easter for
         * @returns {Date} - Easter Sunday date
         */
        function calculateEasterSunday(year) {
            const a = year % 19;
            const b = Math.floor(year / 100);
            const c = year % 100;
            const d = Math.floor(b / 4);
            const e = b % 4;
            const f = Math.floor((b + 8) / 25);
            const g = Math.floor((b - f + 1) / 3);
            const h = (19 * a + b - d - g + 15) % 30;
            const i = Math.floor(c / 4);
            const k = c % 4;
            const l = (32 + 2 * e + 2 * i - h - k) % 7;
            const m = Math.floor((a + 11 * h + 22 * l) / 451);
            const month = Math.floor((h + l - 7 * m + 114) / 31) - 1; // 0-indexed month
            const day = ((h + l - 7 * m + 114) % 31) + 1;
            return new Date(year, month, day);
        }

        /**
         * Get the nth occurrence of a weekday in a month
         * @param {number} year - Year
         * @param {number} month - Month (0-indexed)
         * @param {number} weekday - Day of week (0=Sunday, 1=Monday, etc.)
         * @param {number} n - Which occurrence (1=first, 2=second, etc., -1=last)
         * @returns {Date}
         */
        function getNthWeekdayOfMonth(year, month, weekday, n) {
            if (n === -1) {
                // Last occurrence of weekday in month
                const lastDay = new Date(year, month + 1, 0);
                let day = lastDay.getDate();
                while (new Date(year, month, day).getDay() !== weekday) {
                    day--;
                }
                return new Date(year, month, day);
            }
            const firstDay = new Date(year, month, 1);
            let dayOffset = (weekday - firstDay.getDay() + 7) % 7;
            const day = 1 + dayOffset + (n - 1) * 7;
            return new Date(year, month, day);
        }

        /**
         * Add days to a date
         * @param {Date} date - Base date
         * @param {number} days - Days to add (can be negative)
         * @returns {Date}
         */
        function addDays(date, days) {
            const result = new Date(date);
            result.setDate(result.getDate() + days);
            return result;
        }

        /**
         * Get holidays for Netherlands for a given year
         */
        function getNetherlandsHolidays(year) {
            const holidays = [];
            const easter = calculateEasterSunday(year);

            // Fixed holidays
            holidays.push({ date: new Date(year, 0, 1), name: "New Year's Day" });

            // King's Day - April 27 (or April 26 if 27th is Sunday)
            let kingsDay = new Date(year, 3, 27);
            if (kingsDay.getDay() === 0) {
                kingsDay = new Date(year, 3, 26);
            }
            holidays.push({ date: kingsDay, name: "King's Day" });

            // Liberation Day - May 5 (national holiday every 5 years: 2025, 2030, etc.)
            if (year % 5 === 0) {
                holidays.push({ date: new Date(year, 4, 5), name: "Liberation Day" });
            }

            // Christmas
            holidays.push({ date: new Date(year, 11, 25), name: "Christmas Day" });
            holidays.push({ date: new Date(year, 11, 26), name: "Second Day of Christmas" });

            // Easter-based holidays
            holidays.push({ date: addDays(easter, -2), name: "Good Friday" });
            holidays.push({ date: easter, name: "Easter Sunday" });
            holidays.push({ date: addDays(easter, 1), name: "Easter Monday" });
            holidays.push({ date: addDays(easter, 39), name: "Ascension Day" });
            holidays.push({ date: addDays(easter, 49), name: "Whit Sunday" });
            holidays.push({ date: addDays(easter, 50), name: "Whit Monday" });

            return holidays;
        }

        /**
         * Get holidays for Germany for a given year (nationwide only)
         */
        function getGermanyHolidays(year) {
            const holidays = [];
            const easter = calculateEasterSunday(year);

            // Fixed holidays
            holidays.push({ date: new Date(year, 0, 1), name: "New Year's Day" });
            holidays.push({ date: new Date(year, 4, 1), name: "Labour Day" });
            holidays.push({ date: new Date(year, 9, 3), name: "German Unity Day" });
            holidays.push({ date: new Date(year, 11, 25), name: "Christmas Day" });
            holidays.push({ date: new Date(year, 11, 26), name: "Second Day of Christmas" });

            // Easter-based holidays
            holidays.push({ date: addDays(easter, -2), name: "Good Friday" });
            holidays.push({ date: addDays(easter, 1), name: "Easter Monday" });
            holidays.push({ date: addDays(easter, 39), name: "Ascension Day" });
            holidays.push({ date: addDays(easter, 50), name: "Whit Monday" });

            return holidays;
        }

        /**
         * Get holidays for United Kingdom (England) for a given year
         */
        function getUKHolidays(year) {
            const holidays = [];
            const easter = calculateEasterSunday(year);

            // New Year's Day - Jan 1 (substitute if weekend)
            let newYear = new Date(year, 0, 1);
            if (newYear.getDay() === 0) newYear = new Date(year, 0, 2);
            if (newYear.getDay() === 6) newYear = new Date(year, 0, 3);
            holidays.push({ date: newYear, name: "New Year's Day" });

            // Easter-based
            holidays.push({ date: addDays(easter, -2), name: "Good Friday" });
            holidays.push({ date: addDays(easter, 1), name: "Easter Monday" });

            // Early May bank holiday - First Monday of May
            holidays.push({ date: getNthWeekdayOfMonth(year, 4, 1, 1), name: "Early May Bank Holiday" });

            // Spring bank holiday - Last Monday of May
            holidays.push({ date: getNthWeekdayOfMonth(year, 4, 1, -1), name: "Spring Bank Holiday" });

            // Summer bank holiday - Last Monday of August
            holidays.push({ date: getNthWeekdayOfMonth(year, 7, 1, -1), name: "Summer Bank Holiday" });

            // Christmas Day - Dec 25 (substitute if weekend)
            let christmas = new Date(year, 11, 25);
            if (christmas.getDay() === 0) christmas = new Date(year, 11, 27);
            if (christmas.getDay() === 6) christmas = new Date(year, 11, 27);
            holidays.push({ date: christmas, name: "Christmas Day" });

            // Boxing Day - Dec 26 (substitute if weekend)
            let boxingDay = new Date(year, 11, 26);
            if (boxingDay.getDay() === 0) boxingDay = new Date(year, 11, 28);
            if (boxingDay.getDay() === 6) boxingDay = new Date(year, 11, 28);
            holidays.push({ date: boxingDay, name: "Boxing Day" });

            return holidays;
        }

        /**
         * Get holidays for United States for a given year
         */
        function getUSHolidays(year) {
            const holidays = [];

            // New Year's Day - Jan 1 (observed on Friday if Sat, Monday if Sun)
            let newYear = new Date(year, 0, 1);
            if (newYear.getDay() === 0) newYear = new Date(year, 0, 2);
            if (newYear.getDay() === 6) newYear = new Date(year - 1, 11, 31);
            holidays.push({ date: newYear, name: "New Year's Day" });

            // MLK Day - Third Monday of January
            holidays.push({ date: getNthWeekdayOfMonth(year, 0, 1, 3), name: "Martin Luther King Jr. Day" });

            // Presidents' Day - Third Monday of February
            holidays.push({ date: getNthWeekdayOfMonth(year, 1, 1, 3), name: "Presidents' Day" });

            // Memorial Day - Last Monday of May
            holidays.push({ date: getNthWeekdayOfMonth(year, 4, 1, -1), name: "Memorial Day" });

            // Juneteenth - June 19 (observed on Friday if Sat, Monday if Sun)
            let juneteenth = new Date(year, 5, 19);
            if (juneteenth.getDay() === 0) juneteenth = new Date(year, 5, 20);
            if (juneteenth.getDay() === 6) juneteenth = new Date(year, 5, 18);
            holidays.push({ date: juneteenth, name: "Juneteenth" });

            // Independence Day - July 4 (observed on Friday if Sat, Monday if Sun)
            let july4 = new Date(year, 6, 4);
            if (july4.getDay() === 0) july4 = new Date(year, 6, 5);
            if (july4.getDay() === 6) july4 = new Date(year, 6, 3);
            holidays.push({ date: july4, name: "Independence Day" });

            // Labor Day - First Monday of September
            holidays.push({ date: getNthWeekdayOfMonth(year, 8, 1, 1), name: "Labor Day" });

            // Columbus Day - Second Monday of October
            holidays.push({ date: getNthWeekdayOfMonth(year, 9, 1, 2), name: "Columbus Day" });

            // Veterans Day - November 11 (observed on Friday if Sat, Monday if Sun)
            let veteransDay = new Date(year, 10, 11);
            if (veteransDay.getDay() === 0) veteransDay = new Date(year, 10, 12);
            if (veteransDay.getDay() === 6) veteransDay = new Date(year, 10, 10);
            holidays.push({ date: veteransDay, name: "Veterans Day" });

            // Thanksgiving - Fourth Thursday of November
            holidays.push({ date: getNthWeekdayOfMonth(year, 10, 4, 4), name: "Thanksgiving Day" });

            // Christmas - December 25 (observed on Friday if Sat, Monday if Sun)
            let christmas = new Date(year, 11, 25);
            if (christmas.getDay() === 0) christmas = new Date(year, 11, 26);
            if (christmas.getDay() === 6) christmas = new Date(year, 11, 24);
            holidays.push({ date: christmas, name: "Christmas Day" });

            return holidays;
        }

        /**
         * Get holidays for India for a given year (national gazetted holidays)
         */
        function getIndiaHolidays(year) {
            const holidays = [];

            // Three mandatory national holidays
            holidays.push({ date: new Date(year, 0, 26), name: "Republic Day" });
            holidays.push({ date: new Date(year, 7, 15), name: "Independence Day" });
            holidays.push({ date: new Date(year, 9, 2), name: "Gandhi Jayanti" });

            // Common gazetted holidays
            holidays.push({ date: new Date(year, 0, 1), name: "New Year's Day" });
            holidays.push({ date: new Date(year, 4, 1), name: "May Day" });
            holidays.push({ date: new Date(year, 11, 25), name: "Christmas Day" });

            // Holi - approximate date (full moon in March, varies by lunar calendar)
            // Using approximate Western dates
            const holiDates = {
                2025: new Date(2025, 2, 14),
                2026: new Date(2026, 2, 3),
                2027: new Date(2027, 2, 22),
                2028: new Date(2028, 2, 11),
                2029: new Date(2029, 2, 1),
                2030: new Date(2030, 2, 20),
                2031: new Date(2031, 2, 10),
                2032: new Date(2032, 1, 28),
                2033: new Date(2033, 2, 17),
                2034: new Date(2034, 2, 7),
                2035: new Date(2035, 2, 25),
                2036: new Date(2036, 2, 14),
                2037: new Date(2037, 2, 4),
                2038: new Date(2038, 2, 23),
                2039: new Date(2039, 2, 12),
                2040: new Date(2040, 2, 1),
                2041: new Date(2041, 2, 20),
                2042: new Date(2042, 2, 9),
                2043: new Date(2043, 2, 28),
                2044: new Date(2044, 2, 16),
                2045: new Date(2045, 2, 6),
                2046: new Date(2046, 2, 24),
                2047: new Date(2047, 2, 14),
                2048: new Date(2048, 2, 3),
                2049: new Date(2049, 2, 22),
                2050: new Date(2050, 2, 11)
            };
            if (holiDates[year]) {
                holidays.push({ date: holiDates[year], name: "Holi" });
            }

            // Diwali - approximate date (new moon in Oct/Nov, varies by lunar calendar)
            const diwaliDates = {
                2025: new Date(2025, 9, 20),
                2026: new Date(2026, 10, 8),
                2027: new Date(2027, 9, 29),
                2028: new Date(2028, 9, 17),
                2029: new Date(2029, 10, 5),
                2030: new Date(2030, 9, 26),
                2031: new Date(2031, 9, 16),
                2032: new Date(2032, 10, 3),
                2033: new Date(2033, 9, 23),
                2034: new Date(2034, 10, 11),
                2035: new Date(2035, 9, 31),
                2036: new Date(2036, 9, 19),
                2037: new Date(2037, 10, 7),
                2038: new Date(2038, 9, 27),
                2039: new Date(2039, 9, 17),
                2040: new Date(2040, 10, 4),
                2041: new Date(2041, 9, 24),
                2042: new Date(2042, 10, 12),
                2043: new Date(2043, 10, 1),
                2044: new Date(2044, 9, 20),
                2045: new Date(2045, 10, 8),
                2046: new Date(2046, 9, 28),
                2047: new Date(2047, 9, 18),
                2048: new Date(2048, 10, 5),
                2049: new Date(2049, 9, 25),
                2050: new Date(2050, 10, 13)
            };
            if (diwaliDates[year]) {
                holidays.push({ date: diwaliDates[year], name: "Diwali" });
            }

            return holidays;
        }

        /**
         * Get holidays for a country
         * @param {string} countryCode - Country code (NL, DE, UK, US, IN)
         * @param {number} startYear - Start year
         * @param {number} endYear - End year (inclusive)
         * @returns {Array} - Array of holiday objects with date and name
         */
        function getHolidaysForCountry(countryCode, startYear, endYear) {
            const allHolidays = [];
            const getHolidaysFunc = {
                'NL': getNetherlandsHolidays,
                'DE': getGermanyHolidays,
                'UK': getUKHolidays,
                'US': getUSHolidays,
                'IN': getIndiaHolidays
            }[countryCode];

            if (!getHolidaysFunc) return [];

            for (let year = startYear; year <= endYear; year++) {
                const yearHolidays = getHolidaysFunc(year);
                allHolidays.push(...yearHolidays);
            }

            return allHolidays;
        }

        /**
         * Open the holiday template modal
         */
        function openHolidayTemplateModal() {
            const modal = document.getElementById('holiday-template-modal');
            const countrySelect = document.getElementById('holiday-template-country');
            const yearSelect = document.getElementById('holiday-template-end-year');
            const previewDiv = document.getElementById('holiday-template-preview');

            // Reset selections
            countrySelect.value = '';
            previewDiv.style.display = 'none';

            // Populate year dropdown (current year to 2050)
            const currentYear = new Date().getFullYear();
            yearSelect.innerHTML = '';
            for (let year = currentYear; year <= 2050; year++) {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                yearSelect.appendChild(option);
            }
            yearSelect.value = currentYear + 1; // Default to next year

            // Add change listeners for preview
            countrySelect.onchange = updateHolidayTemplatePreview;
            yearSelect.onchange = updateHolidayTemplatePreview;

            modal.classList.remove('hidden');
        }

        /**
         * Close the holiday template modal
         */
        function closeHolidayTemplateModal() {
            document.getElementById('holiday-template-modal').classList.add('hidden');
        }

        /**
         * Update the preview in the holiday template modal
         */
        function updateHolidayTemplatePreview() {
            const countrySelect = document.getElementById('holiday-template-country');
            const yearSelect = document.getElementById('holiday-template-end-year');
            const previewDiv = document.getElementById('holiday-template-preview');
            const previewText = document.getElementById('holiday-template-preview-text');

            const country = countrySelect.value;
            const endYear = parseInt(yearSelect.value);

            if (!country) {
                previewDiv.style.display = 'none';
                return;
            }

            const currentYear = new Date().getFullYear();
            const holidays = getHolidaysForCountry(country, currentYear, endYear);

            // Filter out holidays that would fall on non-work days or already exist
            const validHolidays = holidays.filter(h => {
                const dateStr = formatDateStr(h.date);
                const dayOfWeek = h.date.getDay();
                return state.workCalendar.workDays[dayOfWeek].enabled &&
                       !state.workCalendar.holidays.includes(dateStr);
            });

            const countryNames = {
                'NL': 'Netherlands',
                'DE': 'Germany',
                'UK': 'United Kingdom',
                'US': 'United States',
                'IN': 'India'
            };

            previewText.innerHTML = `<strong>${countryNames[country]}</strong>: ${validHolidays.length} new holidays will be added from ${currentYear} to ${endYear}.<br><br>` +
                `Total holidays in template: ${holidays.length}<br>` +
                `Already added or non-work days: ${holidays.length - validHolidays.length}`;

            previewDiv.style.display = 'block';
        }

        /**
         * Apply the selected holiday template
         */
        function applyHolidayTemplate() {
            const countrySelect = document.getElementById('holiday-template-country');
            const yearSelect = document.getElementById('holiday-template-end-year');

            const country = countrySelect.value;
            const endYear = parseInt(yearSelect.value);

            if (!country) {
                alert('Please select a country.');
                return;
            }

            const currentYear = new Date().getFullYear();
            const holidays = getHolidaysForCountry(country, currentYear, endYear);

            let addedCount = 0;
            let skippedCount = 0;
            const addedDates = []; // Track newly added dates for conflict check (Issue-82)

            holidays.forEach(holiday => {
                const dateStr = formatDateStr(holiday.date);
                const dayOfWeek = holiday.date.getDay();

                // Skip if not a work day or already exists
                if (!state.workCalendar.workDays[dayOfWeek].enabled) {
                    skippedCount++;
                    return;
                }
                if (state.workCalendar.holidays.includes(dateStr)) {
                    skippedCount++;
                    return;
                }

                // Add the holiday
                state.workCalendar.holidays.push(dateStr);
                addedDates.push(dateStr);
                addedCount++;
            });

            // Sort holidays chronologically
            state.workCalendar.holidays.sort();

            // Close modal and refresh UI
            closeHolidayTemplateModal();
            renderHolidaysList();
            if (holidayPickerInstance) holidayPickerInstance.renderCalendar();
            if (ptoPickerInstance) ptoPickerInstance.renderCalendar();

            // Show summary
            const countryNames = {
                'NL': 'Netherlands',
                'DE': 'Germany',
                'UK': 'United Kingdom',
                'US': 'United States',
                'IN': 'India'
            };
            alert(`Holiday template applied!\n\n${countryNames[country]} holidays from ${currentYear} to ${endYear}:\n- Added: ${addedCount} holidays\n- Skipped: ${skippedCount} (already added or non-work days)`);

            // Check for conflicts after applying template (Issue-82)
            if (addedDates.length > 0) {
                checkAndShowConflicts(addedDates);
            }
        }

        // ========================================
        // WHAT'S NEW MODAL FUNCTIONS (Issue-76, Issue-78)
        // ========================================

        /**
         * Show the What's New modal with migration summary
         * @param {object} migrationSummary - Result from migrateEffortVeryLowToMinimal
         */
        function showWhatsNewModal(migrationSummary) {
            document.getElementById('whats-new-version').textContent = APP_VERSION;

            // Show migration details if any todos were migrated
            const migrationSection = document.getElementById('whats-new-migration');
            if (migrationSummary && migrationSummary.migratedCount > 0) {
                migrationSection.style.display = 'block';
                document.getElementById('whats-new-migration-count').textContent =
                    `${migrationSummary.migratedCount} todo(s) had their effort level updated:`;

                const listHtml = migrationSummary.items.map(item =>
                    `<div style="margin: 4px 0;">• "${item.todoTitle}" changed from ${item.oldEffort} → ${item.newEffort}</div>`
                ).join('');
                document.getElementById('whats-new-migration-list').innerHTML = listHtml;
            } else {
                migrationSection.style.display = 'none';
            }

            document.getElementById('whats-new-modal').classList.remove('hidden');
        }

        /**
         * Close the What's New modal
         */
        function closeWhatsNewModal() {
            document.getElementById('whats-new-modal').classList.add('hidden');
            state.showWhatsNew = false;
            state.migrationSummary = null;

            // Save state to mark upgrade as complete
            saveStateToIndexedDB().catch(err => Logger.error('Failed to save state after upgrade:', err));
        }

        function exportThenClear() {
            // Export data first
            exportData();
            // Then clear after a short delay to allow download to start
            setTimeout(() => {
                confirmClearState();
            }, 500);
        }

        async function confirmClearState() {
            try {
                // Clear IndexedDB
                await clearIndexedDB();

                // Reset in-memory state
                state.todos = [];
                state.engagements = [];
                state.people = [];
                state.roles = [];
                state.tags = [];
                state.meetings = [];
                state.settings = { ...DEFAULT_SETTINGS };
                // Reset work calendar to defaults (Mon-Fri 8hrs, no holidays, no PTO)
                state.workCalendar = JSON.parse(JSON.stringify(DEFAULT_WORK_CALENDAR));

                // Close modal and navigate to landing page
                closeClearStateModal();
                navigateTo('landing');
            } catch (error) {
                Logger.error('Failed to clear state:', error);
                alert('Failed to clear browser state. Please try again.');
            }
        }

        // ========================================
        // DATETIME HELPERS
        // ========================================

        // Get default deadline as Date object (5 PM today)
        function getDefaultDeadlineDate() {
            const now = new Date();
            now.setHours(17, 0, 0, 0);
            return now;
        }

        function getDefaultDeadline() {
            return formatDateTimeLocal(getDefaultDeadlineDate());
        }

        // Set deadline value using DateTimePicker API if available (Issue-85)
        function setDeadlineValue(date) {
            if (todoDeadlineInput._dtpInstance) {
                todoDeadlineInput._dtpInstance.setValue(date);
            } else {
                todoDeadlineInput.value = formatDateTimeLocal(date);
            }
        }

        function formatDateTimeLocal(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        // Show IndexedDB warning modal
        function showIndexedDBWarning() {
            document.getElementById('indexeddb-warning-modal').classList.remove('hidden');
        }

        // Initialize application with IndexedDB
        async function initializeApp() {
            try {
                // Initialize IndexedDB
                await initDB();

                // Try to load saved state
                const savedState = await loadStateFromIndexedDB();

                if (savedState) {
                    // Restore state from IndexedDB
                    state.todos = Array.isArray(savedState.todos) ? savedState.todos : [];
                    state.engagements = Array.isArray(savedState.engagements) ? savedState.engagements : [];
                    state.people = Array.isArray(savedState.people) ? savedState.people : [];
                    state.roles = Array.isArray(savedState.roles) ? savedState.roles : [];
                    state.tags = Array.isArray(savedState.tags) ? savedState.tags : [];
                    // Sanitize tag colors to prevent CSS injection (Issue #61)
                    state.tags = state.tags.map(tag => ({
                        ...tag,
                        color: isValidHexColor(tag.color) ? tag.color : DEFAULT_TAG_COLOR
                    }));
                    state.allocations = Array.isArray(savedState.allocations) ? savedState.allocations : [];
                    state.meetings = Array.isArray(savedState.meetings) ? savedState.meetings : [];

                    // Restore settings (merge with defaults)
                    if (savedState.settings && typeof savedState.settings === 'object') {
                        state.settings = { ...DEFAULT_SETTINGS, ...savedState.settings };
                    }

                    // Initialize Logger with saved debug setting (Issue-64)
                    Logger.debug = state.settings.debugLogging || false;

                    // Restore work calendar (Issue-76)
                    if (savedState.workCalendar && typeof savedState.workCalendar === 'object') {
                        // Deep merge with defaults to handle new fields
                        state.workCalendar = {
                            workDays: savedState.workCalendar.workDays || JSON.parse(JSON.stringify(DEFAULT_WORK_CALENDAR.workDays)),
                            holidays: Array.isArray(savedState.workCalendar.holidays) ? savedState.workCalendar.holidays : [],
                            pto: Array.isArray(savedState.workCalendar.pto) ? savedState.workCalendar.pto : []
                        };
                    }

                    // Ensure all todos have required fields with defaults
                    state.todos = state.todos.map(todo => ({
                        ...todo,
                        title: todo.title || todo.description || 'Untitled',
                        description: todo.description || null,
                        deadline: todo.deadline || (todo.dueDate ? new Date(todo.dueDate).toISOString() : null),
                        effort: todo.effort || DEFAULT_EFFORT,
                        priority: PRIORITY_TAGS[todo.priority] ? todo.priority : DEFAULT_PRIORITY,
                        completedAt: todo.completedAt || null,
                        createdAt: todo.createdAt || new Date().toISOString(),
                        updatedAt: todo.updatedAt || new Date().toISOString()
                    }));

                    // Run migration for backwards compatibility
                    migrateContactsToPeople();
                    migrateEngagementLifecycle();
                    migrateEngagementAllocations();

                    // Update all engagement statuses based on linked todos (auto-pause/resume)
                    updateAllEngagementStatuses();

                    // Check for version upgrade (Issue-76)
                    const savedVersion = savedState.appVersion || '0.0.0';
                    const isUpgrade = savedVersion !== APP_VERSION;
                    let migrationSummary = null;

                    if (isUpgrade) {
                        // Run v1.1.0 migration: convert very_low effort to minimal (Issue-78)
                        migrationSummary = migrateEffortVeryLowToMinimal();

                        // Save state after migration
                        await saveStateToIndexedDB();
                    }

                    // Navigate directly to app with home tab
                    state.currentTab = 'home';
                    navigateTo('app');

                    // Show What's New modal if this is an upgrade with existing data
                    if (isUpgrade) {
                        showWhatsNewModal(migrationSummary);
                    }
                } else {
                    // No saved state, show landing page
                    migrateContactsToPeople();
                    migrateEngagementLifecycle();
                    migrateEngagementAllocations();
                    updateAllEngagementStatuses();
                    navigateTo('landing');
                }
            } catch (error) {
                Logger.error('Failed to initialize IndexedDB:', error);
                // Show warning modal if IndexedDB is unavailable
                showIndexedDBWarning();
            }
        }

        // ========================================
        // DATETIMEPICKER COMPONENT
        // ========================================

        const DTP_MONTH_NAMES = ['January', 'February', 'March', 'April', 'May', 'June',
                                  'July', 'August', 'September', 'October', 'November', 'December'];
        const DTP_DAY_NAMES = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

        class DateTimePicker {
            constructor(inputElement, options = {}) {
                this.input = inputElement;

                // Auto-detect date-only mode from input type
                const isDateOnly = inputElement.type === 'date';

                this.options = {
                    defaultHour: 17,
                    defaultMinute: 0,
                    startOfWeek: 1, // Monday
                    closeOnSelect: true,
                    dateOnly: isDateOnly,
                    onChange: null,
                    rangeMode: false,
                    onDateClick: null,
                    ...options
                };

                // State
                this.isOpen = false;
                this.selectedDate = null;
                this.viewDate = new Date();
                this.focusedDate = new Date();
                this.hours = this.options.defaultHour;
                this.minutes = this.options.defaultMinute;
                this.focusedElement = 'calendar'; // 'calendar', 'hours', 'minutes', 'select'
                this.monthPickerOpen = false;
                this.yearPickerOpen = false;
                this.yearRangeStart = new Date().getFullYear() - 5;

                // Long press state
                this.pressTimer = null;
                this.pressInterval = null;

                // Scroll accumulator for month navigation
                this.scrollAccumulator = 0;

                // Initialize
                this.createElements();
                this.bindEvents();
                this.parseInitialValue();
            }

            createElements() {
                // Wrap input
                this.wrapper = document.createElement('div');
                this.wrapper.className = 'dtp-input-wrapper';
                this.input.parentNode.insertBefore(this.wrapper, this.input);
                this.wrapper.appendChild(this.input);

                // Add display input (replaces native input visually)
                this.displayInput = document.createElement('input');
                this.displayInput.type = 'text';
                this.displayInput.className = 'dtp-display-input';
                this.displayInput.readOnly = true;
                this.displayInput.placeholder = 'Select date and time';
                this.wrapper.appendChild(this.displayInput);

                // Hide original input
                this.input.style.display = 'none';

                // Calendar icon
                this.calendarIcon = document.createElement('span');
                this.calendarIcon.className = 'dtp-calendar-icon';
                this.calendarIcon.innerHTML = '📅';
                this.calendarIcon.setAttribute('role', 'button');
                this.calendarIcon.setAttribute('aria-label', 'Open date picker');
                this.wrapper.appendChild(this.calendarIcon);

                // Create picker container
                this.picker = document.createElement('div');
                this.picker.className = 'dtp-picker';
                this.picker.setAttribute('role', 'dialog');
                this.picker.setAttribute('aria-label', 'Select date and time');
                this.picker.innerHTML = this.createPickerHTML();
                this.wrapper.appendChild(this.picker);

                // Cache DOM references
                this.cacheElements();
            }

            createPickerHTML() {
                const title = this.options.dateOnly ? 'Select Date' : 'Select Date and Time';
                const timePanelHTML = this.options.dateOnly ? '' : `
                        <div class="dtp-time-panel">
                            <div class="dtp-date-display"></div>
                            <div class="dtp-time-spinners">
                                <div class="dtp-spinner dtp-hours-spinner">
                                    <button type="button" class="dtp-spinner-btn dtp-spinner-up" data-field="hours" data-dir="up" aria-label="Increase hours">▲</button>
                                    <input type="text" class="dtp-time-input dtp-hours-input" maxlength="2" aria-label="Hours">
                                    <button type="button" class="dtp-spinner-btn dtp-spinner-down" data-field="hours" data-dir="down" aria-label="Decrease hours">▼</button>
                                </div>
                                <span class="dtp-time-separator">:</span>
                                <div class="dtp-spinner dtp-minutes-spinner">
                                    <button type="button" class="dtp-spinner-btn dtp-spinner-up" data-field="minutes" data-dir="up" aria-label="Increase minutes">▲</button>
                                    <input type="text" class="dtp-time-input dtp-minutes-input" maxlength="2" aria-label="Minutes">
                                    <button type="button" class="dtp-spinner-btn dtp-spinner-down" data-field="minutes" data-dir="down" aria-label="Decrease minutes">▼</button>
                                </div>
                            </div>
                        </div>`;

                return `
                    <div class="dtp-header">
                        <span class="dtp-header-title">${title}</span>
                    </div>
                    <div class="dtp-body${this.options.dateOnly ? ' dtp-date-only' : ''}">
                        ${timePanelHTML}
                        <div class="dtp-calendar-panel">
                            <div class="dtp-calendar-header">
                                <button type="button" class="dtp-nav-btn dtp-prev-month" aria-label="Previous month">◀</button>
                                <span class="dtp-month-year">
                                    <span class="dtp-month-name" tabindex="0"></span>
                                    <span class="dtp-year" tabindex="0"></span>
                                </span>
                                <button type="button" class="dtp-nav-btn dtp-next-month" aria-label="Next month">▶</button>
                            </div>
                            <div class="dtp-day-headers"></div>
                            <div class="dtp-calendar-grid" tabindex="0" role="grid" aria-label="Calendar"></div>
                        </div>
                    </div>
                    <div class="dtp-footer">
                        <button type="button" class="dtp-select-btn">Select</button>
                    </div>
                    <div class="dtp-overlay dtp-month-overlay">
                        <div class="dtp-overlay-header">Select Month</div>
                        <div class="dtp-overlay-grid dtp-month-grid"></div>
                    </div>
                    <div class="dtp-overlay dtp-year-overlay">
                        <div class="dtp-overlay-header">Select Year</div>
                        <div class="dtp-overlay-grid dtp-year-grid"></div>
                    </div>
                `;
            }

            cacheElements() {
                this.dateDisplay = this.picker.querySelector('.dtp-date-display');
                this.hoursInput = this.picker.querySelector('.dtp-hours-input');
                this.minutesInput = this.picker.querySelector('.dtp-minutes-input');
                this.calendarGrid = this.picker.querySelector('.dtp-calendar-grid');
                this.dayHeaders = this.picker.querySelector('.dtp-day-headers');
                this.monthName = this.picker.querySelector('.dtp-month-name');
                this.yearDisplay = this.picker.querySelector('.dtp-year');
                this.prevMonthBtn = this.picker.querySelector('.dtp-prev-month');
                this.nextMonthBtn = this.picker.querySelector('.dtp-next-month');
                this.selectBtn = this.picker.querySelector('.dtp-select-btn');
                this.monthOverlay = this.picker.querySelector('.dtp-month-overlay');
                this.yearOverlay = this.picker.querySelector('.dtp-year-overlay');
                this.monthGrid = this.picker.querySelector('.dtp-month-grid');
                this.yearGrid = this.picker.querySelector('.dtp-year-grid');
            }

            bindEvents() {
                // Open picker
                this.displayInput.addEventListener('click', () => this.open());
                this.displayInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation(); // Prevent form submission when inside a form
                        this.open();
                    }
                });
                this.calendarIcon.addEventListener('click', () => this.open());

                // Close on outside click (use mousedown to prevent race with click)
                document.addEventListener('mousedown', (e) => {
                    if (this.isOpen && !this.wrapper.contains(e.target)) {
                        this.close();
                    }
                });

                // Keyboard navigation (use capture phase to intercept before modal)
                this.wrapper.addEventListener('keydown', (e) => this.handleKeydown(e), true);

                // Month navigation buttons
                this.prevMonthBtn.addEventListener('click', () => this.navigateMonth(-1));
                this.nextMonthBtn.addEventListener('click', () => this.navigateMonth(1));

                // Calendar grid click
                this.calendarGrid.addEventListener('click', (e) => this.handleDayClick(e));

                // Mouse wheel on calendar
                this.calendarGrid.addEventListener('wheel', (e) => this.handleCalendarWheel(e));

                // Time spinner buttons
                this.picker.querySelectorAll('.dtp-spinner-btn').forEach(btn => {
                    btn.addEventListener('mousedown', (e) => this.startSpinnerPress(e));
                    btn.addEventListener('mouseup', () => this.stopSpinnerPress());
                    btn.addEventListener('mouseleave', () => this.stopSpinnerPress());
                    btn.addEventListener('click', (e) => this.handleSpinnerClick(e));
                });

                // Time inputs (only if not date-only mode)
                if (!this.options.dateOnly && this.hoursInput && this.minutesInput) {
                    this.hoursInput.addEventListener('focus', () => { this.focusedElement = 'hours'; });
                    this.minutesInput.addEventListener('focus', () => { this.focusedElement = 'minutes'; });
                    this.hoursInput.addEventListener('input', (e) => this.handleTimeInput(e, 'hours'));
                    this.minutesInput.addEventListener('input', (e) => this.handleTimeInput(e, 'minutes'));
                    this.hoursInput.addEventListener('blur', () => this.formatTimeInput('hours'));
                    this.minutesInput.addEventListener('blur', () => this.formatTimeInput('minutes'));

                    // Wheel on time inputs
                    this.hoursInput.addEventListener('wheel', (e) => this.handleTimeWheel(e, 'hours'));
                    this.minutesInput.addEventListener('wheel', (e) => this.handleTimeWheel(e, 'minutes'));
                }

                // Select button
                this.selectBtn.addEventListener('click', () => this.confirm());
                this.selectBtn.addEventListener('focus', () => { this.focusedElement = 'select'; });

                // Month/Year picker triggers
                this.monthName.addEventListener('mouseenter', () => this.showMonthPicker());
                this.monthName.addEventListener('click', () => this.showMonthPicker());
                this.yearDisplay.addEventListener('mouseenter', () => this.showYearPicker());
                this.yearDisplay.addEventListener('click', () => this.showYearPicker());

                // Overlay events
                this.monthOverlay.addEventListener('mouseleave', () => this.hideMonthPicker());
                this.yearOverlay.addEventListener('mouseleave', () => this.hideYearPicker());
                this.monthGrid.addEventListener('click', (e) => this.handleMonthSelect(e));
                this.yearGrid.addEventListener('click', (e) => this.handleYearSelect(e));
                this.monthGrid.addEventListener('wheel', (e) => this.handleMonthPickerWheel(e));
                this.yearGrid.addEventListener('wheel', (e) => this.handleYearPickerWheel(e));
            }

            parseInitialValue() {
                const value = this.input.value;
                if (value) {
                    const date = new Date(value);
                    if (!isNaN(date.getTime())) {
                        this.selectedDate = date;
                        this.viewDate = new Date(date);
                        this.focusedDate = new Date(date);
                        this.hours = date.getHours();
                        this.minutes = date.getMinutes();
                        this.updateDisplayInput();
                    }
                }
            }

            open() {
                if (this.isOpen) return;
                this.isOpen = true;

                // Re-parse value in case it was set externally after initialization
                this.parseInitialValue();

                // Set view date to selected or today
                if (this.selectedDate) {
                    this.viewDate = new Date(this.selectedDate);
                    this.focusedDate = new Date(this.selectedDate);
                    this.hours = this.selectedDate.getHours();
                    this.minutes = this.selectedDate.getMinutes();
                } else {
                    this.viewDate = new Date();
                    this.focusedDate = new Date();
                    this.hours = this.options.defaultHour;
                    this.minutes = this.options.defaultMinute;
                }

                this.render();

                // Detect if picker should appear above input (smart positioning)
                this.positionPicker();

                this.picker.classList.add('open');
                this.focusedElement = 'calendar';

                // Focus calendar grid
                setTimeout(() => this.calendarGrid.focus(), 50);
            }

            positionPicker() {
                // Reset position class
                this.picker.classList.remove('above');

                // Get input position and picker dimensions
                const inputRect = this.displayInput.getBoundingClientRect();
                const pickerHeight = this.picker.offsetHeight || 380; // Estimated height
                const viewportHeight = window.innerHeight;
                const spaceBelow = viewportHeight - inputRect.bottom;
                const spaceAbove = inputRect.top;

                // Position above if insufficient space below and more space above
                if (spaceBelow < pickerHeight + 20 && spaceAbove > spaceBelow) {
                    this.picker.classList.add('above');
                }
            }

            close() {
                if (!this.isOpen) return;
                this.isOpen = false;
                this.picker.classList.remove('open', 'above');
                this.hideMonthPicker();
                this.hideYearPicker();
                this.displayInput.focus();
            }

            confirm() {
                // In range mode with onConfirm callback, use that instead
                if (this.options.rangeMode && this.options.onConfirm) {
                    this.options.onConfirm(this);
                    return;
                }

                // Build final date
                const finalDate = new Date(this.focusedDate);
                finalDate.setHours(this.hours, this.minutes, 0, 0);
                this.selectedDate = finalDate;

                // Update inputs
                this.updateDisplayInput();
                this.updateHiddenInput();

                // Callback
                if (this.options.onChange) {
                    this.options.onChange(finalDate, this.formatDateTime(finalDate));
                }

                // Trigger change event on original input
                this.input.dispatchEvent(new Event('change', { bubbles: true }));

                this.close();
            }

            render() {
                this.renderDayHeaders();
                this.renderCalendar();
                this.renderTimePanel();
                this.renderMonthYearHeader();
            }

            renderDayHeaders() {
                this.dayHeaders.innerHTML = DTP_DAY_NAMES.map(day =>
                    `<span class="dtp-day-header">${day}</span>`
                ).join('');
            }

            renderCalendar() {
                const year = this.viewDate.getFullYear();
                const month = this.viewDate.getMonth();

                // First day of month
                const firstDay = new Date(year, month, 1);
                // Last day of month
                const lastDay = new Date(year, month + 1, 0);
                // Day of week for first day (adjusted for Monday start)
                let startDay = firstDay.getDay() - this.options.startOfWeek;
                if (startDay < 0) startDay += 7;

                const today = new Date();
                today.setHours(0, 0, 0, 0);

                let html = '';
                let dayCount = 1;
                let nextMonthDay = 1;

                // Previous month days
                const prevMonthLastDay = new Date(year, month, 0).getDate();

                for (let i = 0; i < 42; i++) { // 6 rows * 7 days
                    let dayNum, dateObj, classes = ['dtp-day'];

                    if (i < startDay) {
                        // Previous month
                        dayNum = prevMonthLastDay - startDay + i + 1;
                        dateObj = new Date(year, month - 1, dayNum);
                        classes.push('other-month');
                    } else if (dayCount <= lastDay.getDate()) {
                        // Current month
                        dayNum = dayCount;
                        dateObj = new Date(year, month, dayNum);
                        dayCount++;
                    } else {
                        // Next month
                        dayNum = nextMonthDay;
                        dateObj = new Date(year, month + 1, dayNum);
                        classes.push('other-month');
                        nextMonthDay++;
                    }

                    // Check states
                    const dateKey = this.dateToKey(dateObj);
                    const todayKey = this.dateToKey(today);
                    const selectedKey = this.selectedDate ? this.dateToKey(this.selectedDate) : null;
                    const focusedKey = this.dateToKey(this.focusedDate);

                    if (dateKey === todayKey) classes.push('today');
                    if (dateKey === selectedKey) classes.push('selected');
                    if (dateKey === focusedKey) classes.push('focused');

                    // Check if this is a valid work day (Issue-76)
                    if (!isWorkDay(dateObj)) {
                        classes.push('disabled-day');
                    }

                    // Range selection highlighting (Issue-76 PTO picker)
                    // Only highlights when both start and end are selected (click-based)
                    if (this.options.rangeMode && ptoRangeStart) {
                        const rangeStartKey = this.dateToKey(ptoRangeStart);
                        const rangeEndKey = ptoRangeEnd ? this.dateToKey(ptoRangeEnd) : null;

                        if (dateKey === rangeStartKey) {
                            classes.push('range-start');
                        }
                        if (rangeEndKey && dateKey === rangeEndKey) {
                            classes.push('range-end');
                        }

                        // Highlight dates in range (only when both start and end are set)
                        if (rangeEndKey) {
                            const startTime = ptoRangeStart.getTime();
                            const endTime = ptoRangeEnd.getTime();
                            const [rangeMin, rangeMax] = startTime < endTime ? [startTime, endTime] : [endTime, startTime];
                            const dateTime = dateObj.getTime();
                            if (dateTime > rangeMin && dateTime < rangeMax) {
                                classes.push('in-range');
                            }
                        }
                    }

                    html += `<button type="button" class="${classes.join(' ')}" data-date="${dateObj.toISOString()}" tabindex="-1">${dayNum}</button>`;
                }

                this.calendarGrid.innerHTML = html;
            }

            renderTimePanel() {
                // Skip for date-only mode (no time panel exists)
                if (this.options.dateOnly) return;

                // Date display
                const dateStr = this.formatDate(this.focusedDate);
                if (this.dateDisplay) this.dateDisplay.textContent = dateStr;

                // Time inputs
                if (this.hoursInput) this.hoursInput.value = String(this.hours).padStart(2, '0');
                if (this.minutesInput) this.minutesInput.value = String(this.minutes).padStart(2, '0');
            }

            renderMonthYearHeader() {
                this.monthName.textContent = DTP_MONTH_NAMES[this.viewDate.getMonth()];
                this.yearDisplay.textContent = this.viewDate.getFullYear();
            }

            renderMonthPicker() {
                const currentMonth = this.viewDate.getMonth();
                let html = '';
                for (let i = 0; i < 12; i++) {
                    const classes = ['dtp-overlay-cell'];
                    if (i === currentMonth) classes.push('selected');
                    if (i === new Date().getMonth() && this.viewDate.getFullYear() === new Date().getFullYear()) {
                        classes.push('current');
                    }
                    html += `<button type="button" class="${classes.join(' ')}" data-month="${i}">${DTP_MONTH_NAMES[i].substring(0, 3)}</button>`;
                }
                this.monthGrid.innerHTML = html;
            }

            renderYearPicker() {
                const currentYear = this.viewDate.getFullYear();
                const thisYear = new Date().getFullYear();
                let html = '';
                for (let i = 0; i < 12; i++) {
                    const year = this.yearRangeStart + i;
                    const classes = ['dtp-overlay-cell'];
                    if (year === currentYear) classes.push('selected');
                    if (year === thisYear) classes.push('current');
                    html += `<button type="button" class="${classes.join(' ')}" data-year="${year}">${year}</button>`;
                }
                this.yearGrid.innerHTML = html;
            }

            // Navigation methods
            navigateMonth(delta) {
                this.viewDate.setMonth(this.viewDate.getMonth() + delta);
                this.focusedDate = new Date(this.viewDate);
                this.focusedDate.setDate(1);
                this.render();
            }

            navigateYear(delta) {
                this.viewDate.setFullYear(this.viewDate.getFullYear() + delta);
                this.focusedDate = new Date(this.viewDate);
                this.render();
            }

            navigateDay(delta) {
                this.focusedDate.setDate(this.focusedDate.getDate() + delta);
                // Update view if month changed
                if (this.focusedDate.getMonth() !== this.viewDate.getMonth() ||
                    this.focusedDate.getFullYear() !== this.viewDate.getFullYear()) {
                    this.viewDate = new Date(this.focusedDate);
                }
                this.render();
            }

            navigateWeek(delta) {
                this.navigateDay(delta * 7);
            }

            goToFirstDayOfMonth() {
                this.focusedDate = new Date(this.viewDate.getFullYear(), this.viewDate.getMonth(), 1);
                this.render();
            }

            goToLastDayOfMonth() {
                this.focusedDate = new Date(this.viewDate.getFullYear(), this.viewDate.getMonth() + 1, 0);
                this.render();
            }

            // Event handlers
            handleKeydown(e) {
                if (!this.isOpen) return;

                // Close overlays first
                if (this.monthPickerOpen || this.yearPickerOpen) {
                    if (e.key === 'Escape') {
                        this.hideMonthPicker();
                        this.hideYearPicker();
                        e.preventDefault();
                        e.stopPropagation();
                        return;
                    }
                }

                switch (e.key) {
                    case 'Escape':
                        this.close();
                        e.preventDefault();
                        e.stopPropagation();
                        break;
                    case 'Enter':
                        if (this.focusedElement === 'calendar') {
                            // If custom click handler is set, use it (same as clicking a date)
                            if (this.options.onDateClick) {
                                this.options.onDateClick(this.focusedDate, this);
                            } else {
                                this.selectFocusedDate();
                                if (this.options.dateOnly) {
                                    this.selectBtn.focus();
                                } else {
                                    this.hoursInput.focus();
                                }
                            }
                        } else if (this.focusedElement === 'select') {
                            this.confirm();
                        }
                        e.preventDefault();
                        break;
                    case 'Tab':
                        this.handleTab(e);
                        break;
                    case 'ArrowLeft':
                        if (this.focusedElement === 'calendar') {
                            this.navigateDay(-1);
                            e.preventDefault();
                        } else if (!this.options.dateOnly && this.focusedElement === 'minutes') {
                            this.hoursInput.focus();
                            e.preventDefault();
                        }
                        break;
                    case 'ArrowRight':
                        if (this.focusedElement === 'calendar') {
                            this.navigateDay(1);
                            e.preventDefault();
                        } else if (!this.options.dateOnly && this.focusedElement === 'hours') {
                            this.minutesInput.focus();
                            e.preventDefault();
                        }
                        break;
                    case 'ArrowUp':
                        if (this.focusedElement === 'calendar') {
                            this.navigateWeek(-1);
                        } else if (this.focusedElement === 'hours') {
                            this.adjustTime('hours', 1);
                        } else if (this.focusedElement === 'minutes') {
                            this.adjustTime('minutes', 1);
                        }
                        e.preventDefault();
                        break;
                    case 'ArrowDown':
                        if (this.focusedElement === 'calendar') {
                            this.navigateWeek(1);
                        } else if (this.focusedElement === 'hours') {
                            this.adjustTime('hours', -1);
                        } else if (this.focusedElement === 'minutes') {
                            this.adjustTime('minutes', -1);
                        }
                        e.preventDefault();
                        break;
                    case 'PageUp':
                        if (e.ctrlKey) {
                            this.navigateYear(-1);
                        } else {
                            this.navigateMonth(-1);
                        }
                        e.preventDefault();
                        break;
                    case 'PageDown':
                        if (e.ctrlKey) {
                            this.navigateYear(1);
                        } else {
                            this.navigateMonth(1);
                        }
                        e.preventDefault();
                        break;
                    case 'Home':
                        if (this.focusedElement === 'calendar') {
                            this.goToFirstDayOfMonth();
                            e.preventDefault();
                        }
                        break;
                    case 'End':
                        if (this.focusedElement === 'calendar') {
                            this.goToLastDayOfMonth();
                            e.preventDefault();
                        }
                        break;
                    case ' ':
                        if (this.focusedElement === 'calendar') {
                            this.selectFocusedDate();
                            e.preventDefault();
                        }
                        break;
                }
            }

            handleTab(e) {
                if (this.options.dateOnly) {
                    // Date-only mode: Calendar -> Select button
                    if (e.shiftKey) {
                        if (this.focusedElement === 'select') {
                            this.calendarGrid.focus();
                            this.focusedElement = 'calendar';
                            e.preventDefault();
                        }
                    } else {
                        if (this.focusedElement === 'calendar') {
                            this.selectBtn.focus();
                            e.preventDefault();
                        } else if (this.focusedElement === 'select') {
                            this.close();
                        }
                    }
                } else {
                    // DateTime mode: Calendar -> Hours -> Minutes -> Select button
                    if (e.shiftKey) {
                        // Backward
                        if (this.focusedElement === 'hours') {
                            this.calendarGrid.focus();
                            this.focusedElement = 'calendar';
                            e.preventDefault();
                        } else if (this.focusedElement === 'minutes') {
                            this.hoursInput.focus();
                            e.preventDefault();
                        } else if (this.focusedElement === 'select') {
                            this.minutesInput.focus();
                            e.preventDefault();
                        }
                    } else {
                        // Forward
                        if (this.focusedElement === 'calendar') {
                            this.hoursInput.focus();
                            e.preventDefault();
                        } else if (this.focusedElement === 'hours') {
                            this.minutesInput.focus();
                            e.preventDefault();
                        } else if (this.focusedElement === 'minutes') {
                            this.selectBtn.focus();
                            e.preventDefault();
                        } else if (this.focusedElement === 'select') {
                            // Allow natural tab out, then close
                            this.close();
                        }
                    }
                }
            }

            handleDayClick(e) {
                const dayEl = e.target.closest('.dtp-day');
                if (!dayEl) return;

                const date = new Date(dayEl.dataset.date);

                // Dont allow clicking on disabled days
                if (dayEl.classList.contains('disabled-day')) return;

                // If custom click handler is set, use it
                if (this.options.onDateClick) {
                    this.options.onDateClick(date, this);
                    return;
                }
                this.focusedDate = date;
                this.viewDate = new Date(date);
                this.selectFocusedDate();

                // Move focus to time (or select button for date-only)
                if (this.options.dateOnly) {
                    this.selectBtn.focus();
                } else {
                    this.hoursInput.focus();
                }
            }

            handleCalendarWheel(e) {
                e.preventDefault();
                this.scrollAccumulator += e.deltaY;

                const threshold = 50;
                if (Math.abs(this.scrollAccumulator) >= threshold) {
                    const direction = this.scrollAccumulator > 0 ? 1 : -1;
                    this.navigateMonth(direction);
                    this.scrollAccumulator = 0;
                }
            }

            handleSpinnerClick(e) {
                const btn = e.target.closest('.dtp-spinner-btn');
                if (!btn) return;

                const field = btn.dataset.field;
                const dir = btn.dataset.dir;
                const delta = dir === 'up' ? 1 : -1;
                this.adjustTime(field, delta);
            }

            startSpinnerPress(e) {
                const btn = e.target.closest('.dtp-spinner-btn');
                if (!btn) return;

                const field = btn.dataset.field;
                const dir = btn.dataset.dir;
                const delta = dir === 'up' ? 1 : -1;

                let rate = 150;
                this.pressTimer = setTimeout(() => {
                    this.pressInterval = setInterval(() => {
                        this.adjustTime(field, delta);
                        rate = Math.max(30, rate * 0.9);
                    }, rate);
                }, 400);
            }

            stopSpinnerPress() {
                clearTimeout(this.pressTimer);
                clearInterval(this.pressInterval);
                this.pressTimer = null;
                this.pressInterval = null;
            }

            handleTimeInput(e, field) {
                let value = e.target.value.replace(/\D/g, '');
                const max = field === 'hours' ? 23 : 59;

                if (value.length > 0) {
                    let num = parseInt(value, 10);
                    if (num > max) num = max;
                    this[field] = num;
                }
            }

            formatTimeInput(field) {
                const input = field === 'hours' ? this.hoursInput : this.minutesInput;
                input.value = String(this[field]).padStart(2, '0');
            }

            handleTimeWheel(e, field) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -1 : 1;
                this.adjustTime(field, delta);
            }

            adjustTime(field, delta) {
                if (field === 'hours') {
                    this.hours = (this.hours + delta + 24) % 24;
                    this.hoursInput.value = String(this.hours).padStart(2, '0');
                } else {
                    this.minutes = (this.minutes + delta + 60) % 60;
                    this.minutesInput.value = String(this.minutes).padStart(2, '0');
                }
            }

            selectFocusedDate() {
                this.selectedDate = new Date(this.focusedDate);
                this.render();
            }

            // Month/Year picker methods
            showMonthPicker() {
                this.renderMonthPicker();
                this.monthOverlay.classList.add('open');
                this.monthPickerOpen = true;
                this.hideYearPicker();
            }

            hideMonthPicker() {
                this.monthOverlay.classList.remove('open');
                this.monthPickerOpen = false;
            }

            showYearPicker() {
                this.yearRangeStart = this.viewDate.getFullYear() - 5;
                this.renderYearPicker();
                this.yearOverlay.classList.add('open');
                this.yearPickerOpen = true;
                this.hideMonthPicker();
            }

            hideYearPicker() {
                this.yearOverlay.classList.remove('open');
                this.yearPickerOpen = false;
            }

            handleMonthSelect(e) {
                const cell = e.target.closest('.dtp-overlay-cell');
                if (!cell) return;

                const month = parseInt(cell.dataset.month, 10);
                this.viewDate.setMonth(month);
                this.focusedDate = new Date(this.viewDate);
                this.hideMonthPicker();
                this.render();
            }

            handleYearSelect(e) {
                const cell = e.target.closest('.dtp-overlay-cell');
                if (!cell) return;

                const year = parseInt(cell.dataset.year, 10);
                this.viewDate.setFullYear(year);
                this.focusedDate = new Date(this.viewDate);
                this.hideYearPicker();
                this.render();
            }

            handleMonthPickerWheel(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 1 : -1;
                let newMonth = this.viewDate.getMonth() + delta;

                if (newMonth > 11) {
                    newMonth = 0;
                    this.viewDate.setFullYear(this.viewDate.getFullYear() + 1);
                } else if (newMonth < 0) {
                    newMonth = 11;
                    this.viewDate.setFullYear(this.viewDate.getFullYear() - 1);
                }

                this.viewDate.setMonth(newMonth);
                this.renderMonthPicker();
                this.renderMonthYearHeader();
            }

            handleYearPickerWheel(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 4 : -4;
                this.yearRangeStart += delta;
                this.renderYearPicker();
            }

            // Utility methods
            dateToKey(date) {
                return `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
            }

            formatDate(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            formatDateTime(date) {
                const dateStr = this.formatDate(date);
                if (this.options.dateOnly) {
                    return dateStr;
                }
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${dateStr} ${hours}:${minutes}`;
            }

            updateDisplayInput() {
                if (this.selectedDate) {
                    this.displayInput.value = this.formatDateTime(this.selectedDate);
                } else {
                    this.displayInput.value = '';
                }
            }

            updateHiddenInput() {
                if (this.selectedDate) {
                    const year = this.selectedDate.getFullYear();
                    const month = String(this.selectedDate.getMonth() + 1).padStart(2, '0');
                    const day = String(this.selectedDate.getDate()).padStart(2, '0');

                    if (this.options.dateOnly) {
                        // Format for date input: YYYY-MM-DD
                        this.input.value = `${year}-${month}-${day}`;
                    } else {
                        // Format for datetime-local input: YYYY-MM-DDTHH:MM
                        const hours = String(this.selectedDate.getHours()).padStart(2, '0');
                        const minutes = String(this.selectedDate.getMinutes()).padStart(2, '0');
                        this.input.value = `${year}-${month}-${day}T${hours}:${minutes}`;
                    }
                } else {
                    this.input.value = '';
                }
            }

            // Public API
            getValue() {
                return this.selectedDate;
            }

            setValue(date) {
                if (typeof date === 'string') {
                    date = new Date(date);
                }
                if (date && !isNaN(date.getTime())) {
                    this.selectedDate = date;
                    this.viewDate = new Date(date);
                    this.focusedDate = new Date(date);
                    this.hours = date.getHours();
                    this.minutes = date.getMinutes();
                    this.updateDisplayInput();
                    this.updateHiddenInput();
                }
            }

            clear() {
                this.selectedDate = null;
                this.hours = this.options.defaultHour;
                this.minutes = this.options.defaultMinute;
                this.updateDisplayInput();
                this.input.value = '';
            }

            destroy() {
                // Move input back out of wrapper
                this.wrapper.parentNode.insertBefore(this.input, this.wrapper);
                this.input.style.display = '';
                // Remove wrapper and picker
                this.wrapper.remove();
            }
        }

        // Auto-initialize date pickers
        function initDateTimePickers() {
            document.querySelectorAll('[data-datetimepicker]').forEach(input => {
                if (!input._dtpInstance) {
                    input._dtpInstance = new DateTimePicker(input);
                }
            });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize inline forms with disabled tab navigation (they start closed)
            // Right panel is hidden by default (horizontal expansion)
            setFormTabIndex(todoFormRight, false);
            setFormTabIndex(inlineEngPersonForm, false);
            if (inlinePersonForm) setFormTabIndex(inlinePersonForm, false);

            // Initialize DateTimePickers
            initDateTimePickers();

            // Collapse status tooltips when mouse leaves container
            document.addEventListener('mouseleave', (e) => {
                if (e.target && e.target.closest) {
                    const container = e.target.closest('.status-tooltip-container');
                    if (container) {
                        const tooltip = container.querySelector('.status-tooltip');
                        if (tooltip && !tooltip.classList.contains('expanded')) {
                            tooltip.classList.remove('expanded');
                        }
                    }
                }
            }, true);

            // Collapse expanded status tooltips when clicking outside
            document.addEventListener('click', (e) => {
                if (e.target && e.target.closest) {
                    // If click is not inside a status tooltip, collapse all expanded tooltips
                    if (!e.target.closest('.status-tooltip')) {
                        collapseAllStatusTooltips();
                    }
                    // Issue-57: Collapse expanded engagement when clicking outside
                    if (state.expandedEngagementId && !e.target.closest('.engagement-item')) {
                        collapseEngagementExpansion();
                    }
                }
            });

            // Initialize app with IndexedDB (handles migration and navigation)
            initializeApp();
        });
    </script>
</body>
</html>
