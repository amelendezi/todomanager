<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TodoManager - Manage Your Tasks Efficiently</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #F5F5F5 0%, #E8E8E8 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
            overflow-x: hidden;
        }

        .container {
            max-width: 600px;
            width: 100%;
            text-align: center;
            animation: fadeIn 0.6s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .logo-container {
            margin-bottom: 48px;
            animation: slideDown 0.8s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .logo {
            width: 120px;
            height: 120px;
            margin: 0 auto 24px;
            filter: drop-shadow(0 4px 12px rgba(255, 184, 0, 0.3));
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        .logo:hover {
            animation: float 3s ease-in-out infinite, pulse 0.6s ease;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        h1 {
            font-size: 48px;
            font-weight: 700;
            color: #1F1F1F;
            margin-bottom: 16px;
            letter-spacing: -1px;
        }

        .tagline {
            font-size: 18px;
            color: #6C757D;
            margin-bottom: 64px;
            font-weight: 400;
        }

        .options-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-bottom: 32px;
        }

        .option-card {
            background: white;
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid transparent;
            animation: slideUp 0.6s ease;
            animation-fill-mode: both;
        }

        .option-card:nth-child(1) {
            animation-delay: 0.2s;
        }

        .option-card:nth-child(2) {
            animation-delay: 0.3s;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .option-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            border-color: #FFB800;
        }

        .option-card:active {
            transform: translateY(-2px) scale(1.01);
        }

        .option-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            background: linear-gradient(135deg, #FFB800 0%, #FFA000 100%);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .option-card:hover .option-icon {
            transform: rotate(5deg) scale(1.1);
            box-shadow: 0 4px 16px rgba(255, 184, 0, 0.4);
        }

        .option-icon svg {
            width: 36px;
            height: 36px;
            color: #1F1F1F;
        }

        .option-title {
            font-size: 24px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 8px;
        }

        .option-description {
            font-size: 14px;
            color: #6C757D;
            line-height: 1.5;
        }

        .footer {
            margin-top: 48px;
            font-size: 14px;
            color: #ADB5BD;
            animation: fadeIn 0.8s ease 0.5s both;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 36px;
            }

            .tagline {
                font-size: 16px;
                margin-bottom: 48px;
            }

            .logo {
                width: 100px;
                height: 100px;
            }

            .option-card {
                padding: 24px;
            }

            .option-title {
                font-size: 20px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Page visibility */
        .hidden {
            display: none !important;
        }

        .page {
            min-height: 100vh;
            width: 100%;
        }

        /* Header styles */
        .header {
            height: 60px;
            background: #FFFFFF;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 24px;
        }

        .header-title {
            font-size: 16px;
            font-weight: 500;
            color: #1F1F1F;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: 4px;
        }

        .tab-btn {
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            color: #6C757D;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tab-btn:hover {
            color: #1F1F1F;
            background: #F8F9FA;
        }

        .tab-btn.active {
            color: #1F1F1F;
            background: #FFB800;
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .icon-button {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }

        .icon-button:hover {
            background: #F8F9FA;
        }

        .icon-button:active {
            transform: scale(0.95);
        }

        .icon-button svg {
            width: 24px;
            height: 24px;
            color: #6C757D;
            transition: color 0.2s ease, transform 0.3s ease;
        }

        .icon-button:hover svg {
            color: #1F1F1F;
        }

        /* Settings icon rotation on hover */
        .icon-button[title="Settings"]:hover svg {
            transform: rotate(90deg);
        }

        /* Main content area */
        .main-content {
            padding-top: 84px;
            padding-left: 24px;
            padding-right: 24px;
            padding-bottom: 24px;
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Todo list styles */
        .todo-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .todo-item {
            background: #FFFFFF;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s ease;
        }

        .todo-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translateY(-2px);
        }

        .todo-checkbox {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #E0E0E0;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.2s ease;
        }

        .todo-checkbox.checked {
            background: #00A86B;
            border-color: #00A86B;
        }

        .todo-content {
            flex: 1;
            display: flex;
            gap: 16px;
            align-items: flex-start;
        }

        .todo-info {
            flex: 0 0 auto;
            min-width: 180px;
            max-width: 50%;
        }

        .todo-description {
            flex: 1;
            font-size: 13px;
            color: #6C757D;
            line-height: 1.4;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }

        .todo-item.completed .todo-description {
            color: #ADB5BD;
        }

        .todo-title {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
        }

        /* Empty state styles */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 64px 24px;
            animation: fadeIn 0.5s ease;
        }

        .empty-icon {
            width: 64px;
            height: 64px;
            color: #ADB5BD;
            margin-bottom: 16px;
        }

        .empty-text {
            font-size: 16px;
            font-weight: 500;
            color: #ADB5BD;
        }

        /* Keyboard shortcut hint text */
        .shortcut-hint {
            font-size: 13px;
            font-style: italic;
            color: #ADB5BD;
            margin-top: 12px;
        }

        .shortcut-hint-floating {
            font-size: 12px;
            font-style: italic;
            color: #ADB5BD;
            text-align: center;
            padding: 8px 0;
            margin-bottom: 8px;
        }

        /* Home page body override */
        #home-page {
            background: #F5F5F5;
        }

        /* Responsive styles for home page */
        @media (max-width: 768px) {
            .header {
                padding: 0 16px;
            }

            .main-content {
                padding-left: 16px;
                padding-right: 16px;
            }
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            position: relative;
            background: #FFFFFF;
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 480px;
            max-height: calc(100vh - 48px);
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            animation: modalSlideIn 0.3s ease;
            transform-origin: center center;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 24px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 8px;
        }

        .form-label .required {
            color: #DC3545;
        }

        .form-input {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .form-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .form-input::placeholder {
            color: #ADB5BD;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 24px;
        }

        .btn {
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .btn-primary {
            background: #FFB800;
            color: #1F1F1F;
        }

        .btn-primary:hover {
            background: #E5A600;
            transform: scale(1.02);
        }

        .btn-secondary {
            background: #F8F9FA;
            color: #6C757D;
        }

        .btn-secondary:hover {
            background: #E9ECEF;
        }

        /* Disabled button state */
        .btn:disabled,
        .btn.btn-disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        .btn-primary:disabled,
        .btn-primary.btn-disabled {
            background: #FFB800;
        }

        /* Tooltip wrapper for disabled button */
        .btn-tooltip-wrapper {
            position: relative;
            display: inline-block;
        }

        .btn-tooltip-wrapper[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            margin-bottom: 8px;
            z-index: 1000;
        }

        .btn-tooltip-wrapper[data-tooltip]:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #333;
            margin-bottom: -4px;
            z-index: 1000;
        }

        /* Todo item with due date */
        .todo-due-date {
            font-size: 12px;
            color: #6C757D;
            margin-top: 4px;
        }

        .todo-due-date.overdue {
            color: #DC3545;
        }

        .todo-item.completed .todo-title {
            text-decoration: line-through;
            color: #ADB5BD;
        }

        /* Checkmark icon inside checkbox */
        .todo-checkbox.checked::after {
            content: '';
            display: block;
            width: 8px;
            height: 5px;
            border-left: 2px solid #FFFFFF;
            border-bottom: 2px solid #FFFFFF;
            transform: rotate(-45deg);
            margin: 6px auto;
        }

        /* Todo actions (edit button) */
        .todo-actions {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: auto;
        }

        .todo-edit-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
            flex-shrink: 0;
        }

        .todo-edit-btn:hover {
            background: #F0F0F0;
        }

        .todo-edit-btn svg {
            width: 18px;
            height: 18px;
            color: #6C757D;
            transition: color 0.2s ease;
        }

        .todo-edit-btn:hover svg {
            color: #1F1F1F;
        }

        /* Modal responsive */
        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                padding: 20px;
            }

            .modal-actions {
                flex-direction: column-reverse;
            }

            .btn {
                width: 100%;
            }
        }

        /* Engagement list styles */
        .engagement-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .engagement-item {
            background: #FFFFFF;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            align-items: center;
            gap: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .engagement-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translateY(-2px);
        }

        .engagement-content {
            flex: 1;
            min-width: 0;
        }

        .engagement-name {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 4px;
        }

        .engagement-contact {
            font-size: 12px;
            color: #6C757D;
        }

        /* Status badges */
        .status-badge {
            padding: 4px 12px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 16px;
            white-space: nowrap;
        }

        .status-requested {
            background: #E3F2FD;
            color: #1976D2;
        }

        .status-open {
            background: #E8F5E9;
            color: #388E3C;
        }

        .status-paused {
            background: #FFF3E0;
            color: #F57C00;
        }

        .status-cancelled {
            background: #FFEBEE;
            color: #D32F2F;
        }

        .status-closed {
            background: #F3E5F5;
            color: #7B1FA2;
        }

        /* Side Panel */
        .side-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 400px;
            max-width: 100%;
            height: 100vh;
            background: #FFFFFF;
            box-shadow: -4px 0 24px rgba(0, 0, 0, 0.15);
            z-index: 200;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .side-panel.open {
            transform: translateX(0);
        }

        .side-panel-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 199;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .side-panel-backdrop.open {
            opacity: 1;
            visibility: visible;
        }

        .side-panel-header {
            padding: 20px 24px;
            border-bottom: 1px solid #E0E0E0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .side-panel-title {
            font-size: 18px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .side-panel-close {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }

        .side-panel-close:hover {
            background: #F8F9FA;
        }

        .side-panel-close svg {
            width: 20px;
            height: 20px;
            color: #6C757D;
        }

        .side-panel-body {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
        }

        .detail-group {
            margin-bottom: 20px;
        }

        .detail-label {
            font-size: 12px;
            font-weight: 500;
            color: #6C757D;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .detail-value {
            font-size: 14px;
            color: #1F1F1F;
        }

        .detail-value.editable {
            cursor: pointer;
            padding: 4px 8px;
            margin: -4px -8px;
            border-radius: 4px;
            border: 1px solid transparent;
            transition: all 0.2s ease;
        }

        .detail-value.editable:hover {
            background: #F8F9FA;
            border-color: #E0E0E0;
        }

        .detail-input {
            width: 100%;
            font-size: 14px;
            color: #1F1F1F;
            padding: 4px 8px;
            margin: -4px -8px;
            border: 1px solid #FFB800;
            border-radius: 4px;
            outline: none;
            background: #FFFEF5;
            font-family: inherit;
        }

        .detail-input:focus {
            box-shadow: 0 0 0 2px rgba(255, 184, 0, 0.2);
        }

        .detail-textarea {
            width: calc(100% + 16px);
            min-height: 60px;
            font-size: 14px;
            color: #1F1F1F;
            padding: 4px 8px;
            margin: -4px -8px;
            border: 1px solid #FFB800;
            border-radius: 4px;
            outline: none;
            background: #FFFEF5;
            font-family: inherit;
            resize: vertical;
        }

        .detail-textarea:focus {
            box-shadow: 0 0 0 2px rgba(255, 184, 0, 0.2);
        }

        .panel-contact-wrapper {
            position: relative;
        }

        .panel-contact-dropdown {
            position: absolute;
            top: 100%;
            left: -8px;
            right: -8px;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 4px;
            display: none;
        }

        .panel-contact-dropdown.open {
            display: block;
        }

        .panel-contact-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            color: #1F1F1F;
        }

        .panel-contact-item:hover,
        .panel-contact-item.highlighted {
            background: #FFF8E1;
        }

        .detail-select {
            width: 100%;
            height: 40px;
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            cursor: pointer;
            transition: border-color 0.2s ease;
        }

        .detail-select:focus {
            outline: none;
            border-color: #FFB800;
        }

        /* Responsive side panel */
        @media (max-width: 768px) {
            .side-panel {
                width: 100%;
            }
        }

        /* Autocomplete styles */
        .autocomplete-wrapper {
            position: relative;
        }

        .autocomplete-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .autocomplete-input {
            width: 100%;
            height: 48px;
            padding: 12px 40px 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .autocomplete-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .autocomplete-input::placeholder {
            color: #ADB5BD;
        }

        .autocomplete-clear {
            position: absolute;
            right: 12px;
            width: 20px;
            height: 20px;
            border: none;
            background: #E0E0E0;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease, background-color 0.2s ease;
        }

        .autocomplete-clear.visible {
            opacity: 1;
        }

        .autocomplete-clear:hover {
            background: #D0D0D0;
        }

        .autocomplete-clear svg {
            width: 12px;
            height: 12px;
            color: #6C757D;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 4px;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-height: 200px;
            overflow-y: auto;
            z-index: 10;
            display: none;
        }

        .autocomplete-dropdown.open {
            display: block;
        }

        .autocomplete-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.15s ease;
            font-size: 14px;
            color: #1F1F1F;
        }

        .autocomplete-item:hover,
        .autocomplete-item.highlighted {
            background: #F8F9FA;
        }

        .autocomplete-item-name {
            font-weight: 500;
        }

        .autocomplete-item-contact {
            font-size: 12px;
            color: #6C757D;
            margin-top: 2px;
        }

        .autocomplete-empty {
            padding: 12px 16px;
            font-size: 14px;
            color: #6C757D;
            font-style: italic;
        }

        .autocomplete-create-hint {
            padding: 8px 16px;
            font-size: 12px;
            color: #6C757D;
            background: #F8F9FA;
            border-top: 1px solid #E0E0E0;
        }

        /* Inline engagement creation form */
        .inline-eng-form {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
            background: #F8F9FA;
            border-radius: 8px;
            margin-top: 0;
            padding: 0 16px;
        }

        .inline-eng-form.open {
            max-height: 300px;
            padding: 16px;
            margin-top: 12px;
        }

        .inline-eng-form .form-group {
            margin-bottom: 12px;
        }

        .inline-eng-form .form-group:last-child {
            margin-bottom: 0;
        }

        .inline-eng-form .form-label {
            font-size: 12px;
            margin-bottom: 4px;
        }

        .inline-eng-form .form-input {
            height: 40px;
            padding: 8px 12px;
            font-size: 13px;
        }

        .inline-eng-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .inline-eng-title {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .inline-eng-actions {
            display: flex;
            gap: 8px;
        }

        .inline-eng-actions .btn {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Todo engagement badge */
        .todo-engagement {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 500;
            color: #1976D2;
            background: #E3F2FD;
            border-radius: 12px;
            margin-top: 4px;
        }

        .todo-engagement svg {
            width: 12px;
            height: 12px;
        }

        /* Engagement action buttons */
        .engagement-actions {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: 8px;
        }

        .opp-action-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease, opacity 0.2s ease;
            flex-shrink: 0;
        }

        .opp-action-btn:hover:not(:disabled) {
            background: #F0F0F0;
        }

        .opp-action-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .opp-action-btn svg {
            width: 18px;
            height: 18px;
            color: #6C757D;
            transition: color 0.2s ease;
        }

        .opp-action-btn:hover:not(:disabled) svg {
            color: #1F1F1F;
        }

        .opp-action-btn.close-btn:hover:not(:disabled) svg {
            color: #7B1FA2;
        }

        .opp-action-btn.delete-btn:hover:not(:disabled) svg {
            color: #D32F2F;
        }

        .opp-action-btn.cancel-btn:hover:not(:disabled) svg {
            color: #F57C00;
        }

        .opp-action-btn.archive-btn:hover:not(:disabled) svg {
            color: #5C6BC0;
        }

        .opp-action-btn.edit-btn:hover:not(:disabled) svg {
            color: #1976D2;
        }

        /* Archived engagement styling */
        .engagement-item.archived {
            opacity: 0.6;
        }

        .engagement-item.archived .engagement-name {
            text-decoration: line-through;
        }

        /* Show Archived Toggle */
        .archive-toggle-container {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            margin-bottom: 16px;
            padding-right: 8px;
        }

        .archive-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 13px;
            color: #6C757D;
            user-select: none;
        }

        .archive-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #FFB800;
            cursor: pointer;
        }

        .archive-toggle:hover {
            color: #1F1F1F;
        }

        /* Confirmation modal */
        .confirm-modal-content {
            text-align: center;
        }

        .confirm-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            color: #D32F2F;
        }

        .confirm-title {
            font-size: 20px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 12px;
        }

        .confirm-message {
            font-size: 14px;
            color: #6C757D;
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .confirm-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .btn-danger {
            background: #D32F2F;
            color: #FFFFFF;
        }

        .btn-danger:hover {
            background: #B71C1C;
        }

        /* Comments section in side panel */
        .comments-section {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid #E0E0E0;
        }

        .comments-header {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 16px;
        }

        .comments-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .comment-item {
            padding: 12px;
            background: #F8F9FA;
            border-radius: 8px;
            border-left: 3px solid #E0E0E0;
            position: relative;
        }

        .comment-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .comment-delete-btn {
            background: none;
            border: none;
            color: #ADB5BD;
            cursor: pointer;
            padding: 0;
            font-size: 16px;
            line-height: 1;
            opacity: 0;
            transition: opacity 0.2s ease, color 0.2s ease;
        }

        .comment-item:hover .comment-delete-btn {
            opacity: 1;
        }

        .comment-delete-btn:hover {
            color: #D32F2F;
        }

        .comment-item.cancellation {
            background: #FFF5F5;
            border-left-color: #D32F2F;
        }

        .comment-timestamp {
            font-size: 11px;
            color: #6C757D;
            margin-bottom: 4px;
        }

        .comment-item.cancellation .comment-timestamp {
            color: #D32F2F;
        }

        .comment-text {
            font-size: 13px;
            color: #1F1F1F;
            line-height: 1.5;
        }

        .comment-item.cancellation .comment-text {
            color: #B71C1C;
        }

        .comment-badge {
            display: inline-block;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
        }

        .comment-badge.cancellation {
            background: #FFEBEE;
            color: #D32F2F;
        }

        .no-comments {
            font-size: 13px;
            color: #ADB5BD;
            font-style: italic;
        }

        /* Comment input area */
        .comment-input-area {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #E0E0E0;
        }

        .comment-textarea {
            width: 100%;
            min-height: 80px;
            padding: 10px 12px;
            font-size: 13px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            resize: vertical;
        }

        .comment-textarea:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .comment-textarea::placeholder {
            color: #ADB5BD;
        }

        .comment-submit-btn {
            margin-top: 8px;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 500;
            background: #FFB800;
            color: #1F1F1F;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .comment-submit-btn:hover {
            background: #E5A600;
        }

        .comment-submit-btn:disabled {
            background: #E0E0E0;
            color: #ADB5BD;
            cursor: not-allowed;
        }

        /* Cancel modal with textarea */
        .cancel-modal-content {
            text-align: left;
        }

        .cancel-modal-content .modal-title {
            text-align: center;
        }

        .cancel-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            color: #F57C00;
            display: block;
        }

        .cancel-modal-content .form-group {
            margin-bottom: 20px;
        }

        .form-textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            resize: vertical;
        }

        .form-textarea:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .form-textarea::placeholder {
            color: #ADB5BD;
        }

        .btn-warning {
            background: #F57C00;
            color: #FFFFFF;
        }

        .btn-warning:hover {
            background: #E65100;
        }

        /* People page styles */
        .people-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .person-item {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .person-item:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
        }

        .person-info {
            flex: 1;
            min-width: 0;
        }

        .person-name {
            font-size: 15px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 4px;
        }

        .person-role {
            font-size: 13px;
            color: #6C757D;
        }

        .person-role-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 500;
            color: #6C757D;
            background: #F5F5F5;
            border-radius: 12px;
        }

        .person-actions {
            display: flex;
            gap: 4px;
        }

        /* Roles section */
        .roles-section {
            margin-top: 32px;
            padding-top: 24px;
            border-top: 1px solid #E0E0E0;
        }

        .roles-title {
            font-size: 14px;
            font-weight: 600;
            color: #6C757D;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .roles-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .role-tag {
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            font-size: 13px;
            color: #1F1F1F;
            background: #F5F5F5;
            border-radius: 16px;
        }

        /* Tags styles */
        .tags-section {
            margin-top: 32px;
            padding-top: 24px;
            border-top: 1px solid #E0E0E0;
        }

        .tags-title {
            font-size: 14px;
            font-weight: 600;
            color: #666;
            margin-bottom: 12px;
        }

        .tags-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .tag-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 12px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }

        .tag-item:hover {
            border-color: #BDBDBD;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .tag-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .tag-color-preview {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid rgba(0, 0, 0, 0.1);
        }

        .tag-name {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
        }

        .tag-actions {
            display: flex;
            gap: 4px;
        }

        /* Tag pill/chip for display in lists */
        .tag-pill {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            font-size: 11px;
            font-weight: 500;
            border-radius: 12px;
            margin-right: 4px;
            margin-bottom: 4px;
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            margin-top: 4px;
        }

        /* Color picker styles */
        .color-picker-wrapper {
            position: relative;
        }

        .color-picker-input {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #F5F5F5;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .color-picker-input:hover {
            border-color: #BDBDBD;
        }

        .color-picker-preview {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 2px solid rgba(0, 0, 0, 0.1);
        }

        .color-picker-value {
            font-size: 14px;
            color: #666;
            font-family: monospace;
        }

        .color-picker-native {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        /* Tag selector in modals */
        .tag-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px 0;
        }

        .tag-selector-item {
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            opacity: 0.6;
        }

        .tag-selector-item:hover {
            opacity: 0.8;
        }

        .tag-selector-item.selected {
            opacity: 1;
            border-color: rgba(0, 0, 0, 0.2);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .tag-selector-empty {
            font-size: 13px;
            color: #999;
            font-style: italic;
        }

        /* Tag input control for forms */
        .tag-input-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .selected-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .selected-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 12px;
            color: #fff;
        }

        .selected-tag .remove-tag {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            border: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            padding: 0;
            font-size: 10px;
            color: inherit;
            line-height: 1;
        }

        .selected-tag .remove-tag:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .tag-input-wrapper {
            position: relative;
        }

        .tag-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            font-size: 14px;
            background: #F5F5F5;
            transition: all 0.2s ease;
        }

        .tag-input:focus {
            outline: none;
            border-color: #F59E0B;
            background: #fff;
        }

        .tag-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #fff;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .tag-dropdown.open {
            display: block;
        }

        .tag-dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .tag-dropdown-item:hover,
        .tag-dropdown-item.highlighted {
            background: #F5F5F5;
        }

        .tag-dropdown-item .tag-color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .tag-dropdown-item.create-new {
            border-top: 1px solid #E0E0E0;
            color: #F59E0B;
            font-weight: 500;
        }

        .tag-dropdown-item.create-new .tag-color-dot {
            background: #F59E0B;
        }

        /* Inline person creation form */
        .inline-person-form {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
            background: #F8F9FA;
            border-radius: 8px;
            margin-top: 0;
            padding: 0 16px;
        }

        .inline-person-form.open {
            max-height: 200px;
            padding: 16px;
            margin-top: 12px;
        }

        .inline-person-form .form-group {
            margin-bottom: 12px;
        }

        .inline-person-form .form-group:last-child {
            margin-bottom: 0;
        }

        .inline-person-form .form-label {
            font-size: 12px;
            margin-bottom: 4px;
        }

        .inline-person-form .form-input {
            height: 40px;
            padding: 8px 12px;
            font-size: 13px;
        }

        .inline-person-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .inline-person-title {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .inline-person-actions {
            display: flex;
            gap: 8px;
        }

        .inline-person-actions .btn {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Contact badge in engagement list */
        .eng-contact-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 500;
            color: #1976D2;
            background: #E3F2FD;
            border-radius: 12px;
        }

        /* Settings page layout */
        #settings-page {
            background: #F5F5F5;
        }

        .settings-container {
            display: flex;
            min-height: calc(100vh - 60px);
            margin-top: 60px;
        }

        .settings-menu {
            width: 20%;
            background: #FFFFFF;
            border-right: 1px solid #E0E0E0;
            padding: 24px 0;
        }

        .settings-menu-title {
            font-size: 14px;
            font-weight: 600;
            color: #6C757D;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 0 24px;
            margin-bottom: 16px;
        }

        .settings-menu-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .settings-menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 24px;
            font-size: 15px;
            font-weight: 500;
            color: #1F1F1F;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .settings-menu-item:hover {
            background: #F8F9FA;
        }

        .settings-menu-item.active {
            background: #FFF8E1;
            border-left-color: #FFB800;
            color: #1F1F1F;
        }

        .settings-menu-item svg {
            width: 24px;
            height: 24px;
            color: #6C757D;
            flex-shrink: 0;
        }

        .settings-menu-item.active svg {
            color: #FFB800;
        }

        .settings-content {
            width: 80%;
            position: relative;
            padding: 24px;
            overflow-y: auto;
        }

        .settings-close-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: #FFFFFF;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .settings-close-btn:hover {
            background: #F8F9FA;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .settings-close-btn svg {
            width: 24px;
            height: 24px;
            color: #6C757D;
        }

        .settings-close-btn:hover svg {
            color: #1F1F1F;
        }

        .settings-section-title {
            font-size: 24px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 24px;
        }

        /* Responsive settings */
        @media (max-width: 768px) {
            .settings-container {
                flex-direction: column;
            }

            .settings-menu {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #E0E0E0;
                padding: 16px 0;
            }

            .settings-content {
                width: 100%;
            }
        }

        /* ========================================
           RECOMMENDATION ENGINE STYLES
           ======================================== */

        /* Split-panel layout for Todos page */
        .home-split-container {
            display: flex;
            gap: 24px;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Recommendation Panel (Left) */
        .recommendation-panel {
            width: 450px;
            min-width: 450px;
            background: #FFFFFF;
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        /* Todo Panel (Right) */
        .todo-panel {
            flex: 1;
            min-width: 0;
        }

        /* Recommendation Header */
        .recommendation-header {
            position: relative;
            padding: 20px;
            border-bottom: 1px solid #E0E0E0;
            background: linear-gradient(135deg, #FFF8E1 0%, #FFFFFF 100%);
        }

        .recommendation-date {
            font-size: 18px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .recommendation-date-icon {
            font-size: 20px;
        }

        .recommendation-summary {
            font-size: 13px;
            color: #6C757D;
        }

        /* Recommendation Content */
        .recommendation-content {
            padding: 16px;
        }

        /* Recommendation Section */
        .recommendation-section {
            margin-bottom: 20px;
        }

        .recommendation-section:last-child {
            margin-bottom: 0;
        }

        .recommendation-section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #6C757D;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #F0F0F0;
        }

        .recommendation-section-icon {
            font-size: 14px;
        }

        .recommendation-section-count {
            background: #E9ECEF;
            color: #6C757D;
            font-size: 11px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: auto;
        }

        /* Section-specific colors */
        .recommendation-section.overdue .recommendation-section-header {
            color: #DC3545;
        }

        .recommendation-section.overdue .recommendation-section-count {
            background: #FFEBEE;
            color: #DC3545;
        }

        .recommendation-section.must-do .recommendation-section-header {
            color: #F57C00;
        }

        .recommendation-section.must-do .recommendation-section-count {
            background: #FFF3E0;
            color: #F57C00;
        }

        .recommendation-section.recommended .recommendation-section-header {
            color: #1976D2;
        }

        .recommendation-section.recommended .recommendation-section-count {
            background: #E3F2FD;
            color: #1976D2;
        }

        .recommendation-section.if-time .recommendation-section-header {
            color: #6C757D;
        }

        /* Recommendation Item */
        .recommendation-item {
            background: #F8F9FA;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .recommendation-item:last-child {
            margin-bottom: 0;
        }

        .recommendation-item:hover {
            background: #FFFFFF;
            border-color: #E0E0E0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .recommendation-item-header {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 8px;
        }

        .recommendation-item-checkbox {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #D0D0D0;
            flex-shrink: 0;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 2px;
        }

        .recommendation-item-checkbox:hover {
            border-color: #FFB800;
        }

        .recommendation-item-checkbox.checked {
            background: #00A86B;
            border-color: #00A86B;
        }

        .recommendation-item-title {
            flex: 1;
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            line-height: 1.4;
        }

        .recommendation-item.completed .recommendation-item-title {
            text-decoration: line-through;
            color: #ADB5BD;
        }

        .recommendation-item-meta {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 12px;
            color: #6C757D;
            margin-bottom: 8px;
            margin-left: 30px;
        }

        .recommendation-item-effort,
        .recommendation-item-deadline {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Tag pills in recommendation */
        .recommendation-item-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-left: 30px;
            margin-bottom: 8px;
        }

        /* Priority pill styling (distinct from user tags) */
        .priority-pill {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 10px;
            font-size: 11px;
            font-weight: 600;
            border-radius: 12px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .priority-pill.priority-urgent {
            background: #FFEBEE;
            color: #C62828;
        }

        .priority-pill.priority-high {
            background: #FFF3E0;
            color: #E65100;
        }

        .priority-pill.priority-normal {
            background: #E3F2FD;
            color: #1565C0;
        }

        .priority-pill.priority-low {
            background: #F5F5F5;
            color: #616161;
        }

        .priority-pill.priority-someday {
            background: #FAFAFA;
            color: #9E9E9E;
        }

        /* Reasoning text */
        .recommendation-item-reasoning {
            font-size: 12px;
            color: #6C757D;
            font-style: italic;
            margin-left: 30px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .recommendation-item-reasoning::before {
            content: '\2192';
            color: #ADB5BD;
        }

        /* Score display */
        .recommendation-item-score {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            margin-left: 30px;
            margin-top: 8px;
        }

        .score-badge {
            font-size: 11px;
            font-weight: 600;
            color: #6C757D;
            background: #E9ECEF;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .score-badge.critical {
            background: #FFEBEE;
            color: #C62828;
        }

        .score-badge.high {
            background: #FFF3E0;
            color: #E65100;
        }

        .score-badge.medium {
            background: #E3F2FD;
            color: #1565C0;
        }

        /* Warning Card */
        .warning-card {
            background: #FFF3E0;
            border: 1px solid #FFE0B2;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 12px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .warning-card.critical {
            background: #FFEBEE;
            border-color: #FFCDD2;
        }

        .warning-icon {
            font-size: 16px;
            flex-shrink: 0;
        }

        .warning-message {
            font-size: 13px;
            color: #5D4037;
            line-height: 1.4;
        }

        .warning-card.critical .warning-message {
            color: #B71C1C;
        }

        /* Insight Card */
        .insight-card {
            background: #E8F5E9;
            border: 1px solid #C8E6C9;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 12px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .insight-icon {
            font-size: 16px;
            flex-shrink: 0;
        }

        .insight-message {
            font-size: 13px;
            color: #2E7D32;
            line-height: 1.4;
        }

        /* Warnings section */
        .warnings-section {
            margin-bottom: 16px;
        }

        /* Insights section */
        .insights-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #E0E0E0;
        }

        .insights-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #2E7D32;
            margin-bottom: 12px;
        }

        /* Empty recommendation state */
        .recommendation-empty {
            text-align: center;
            padding: 40px 20px;
            color: #6C757D;
        }

        .recommendation-empty-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .recommendation-empty-text {
            font-size: 14px;
        }

        /* Effort dropdown styles */
        .effort-select {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            cursor: pointer;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236C757D' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 16px center;
        }

        .effort-select:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        /* Priority autocomplete styles */
        .priority-autocomplete-wrapper {
            position: relative;
        }

        .priority-input {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .priority-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .priority-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .priority-dropdown.open {
            display: block;
        }

        .priority-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }

        .priority-option:hover,
        .priority-option.highlighted {
            background: #F8F9FA;
        }

        .priority-option.selected {
            background: #FFF8E1;
        }

        .priority-option-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .priority-option-label {
            font-size: 14px;
            color: #1F1F1F;
        }

        .priority-option-desc {
            font-size: 12px;
            color: #6C757D;
            margin-left: auto;
        }

        /* Datetime input styles */
        .datetime-input {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .datetime-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        /* Description textarea */
        .form-textarea {
            width: 100%;
            min-height: 80px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            resize: vertical;
        }

        .form-textarea:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .form-textarea::placeholder {
            color: #ADB5BD;
        }

        /* Effort display in todo list */
        .todo-effort {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            color: #6C757D;
            background: #F5F5F5;
            padding: 2px 8px;
            border-radius: 10px;
            margin-right: 8px;
        }

        .todo-effort-icon {
            font-size: 10px;
        }

        /* Priority display in todo list */
        .todo-priority {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 10px;
            margin-right: 8px;
        }

        /* Planning settings section */
        .planning-settings-form {
            max-width: 500px;
        }

        .planning-settings-form .form-group {
            margin-bottom: 20px;
        }

        .planning-settings-form .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 6px;
        }

        .planning-settings-form .form-hint {
            font-size: 12px;
            color: #6C757D;
            margin-top: 4px;
        }

        .planning-settings-form .form-input {
            max-width: 200px;
        }

        .planning-settings-form .btn-save-settings {
            margin-top: 24px;
        }

        /* Responsive split-panel */
        @media (max-width: 1024px) {
            .home-split-container {
                flex-direction: column;
            }

            .recommendation-panel {
                width: 100%;
                min-width: 100%;
                margin-bottom: 24px;
            }

            .todo-panel {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- Landing Page -->
    <div id="landing-page" class="container">
        <div class="logo-container">
            <svg class="logo" viewBox="0 0 120 120" fill="none" xmlns="http://www.w3.org/2000/svg">
                <!-- Clipboard background -->
                <rect x="20" y="15" width="80" height="95" rx="8" fill="#FFB800"/>
                <rect x="25" y="20" width="70" height="85" rx="6" fill="#FFFFFF"/>

                <!-- Clipboard clip -->
                <path d="M45 10 H75 C78 10 80 12 80 15 V20 H40 V15 C40 12 42 10 45 10 Z" fill="#FFB800"/>
                <rect x="48" y="5" width="24" height="12" rx="3" fill="#1F1F1F"/>

                <!-- Checkmark items -->
                <g opacity="0.9">
                    <!-- First item - checked -->
                    <circle cx="35" cy="38" r="5" fill="#00A86B"/>
                    <path d="M33 38 L34.5 39.5 L37.5 36.5" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <rect x="45" y="36" width="45" height="4" rx="2" fill="#E0E0E0"/>

                    <!-- Second item - checked -->
                    <circle cx="35" cy="55" r="5" fill="#00A86B"/>
                    <path d="M33 55 L34.5 56.5 L37.5 53.5" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <rect x="45" y="53" width="35" height="4" rx="2" fill="#E0E0E0"/>

                    <!-- Third item - unchecked -->
                    <circle cx="35" cy="72" r="5" fill="#E0E0E0"/>
                    <rect x="45" y="70" width="40" height="4" rx="2" fill="#E0E0E0"/>

                    <!-- Fourth item - unchecked -->
                    <circle cx="35" cy="89" r="5" fill="#E0E0E0"/>
                    <rect x="45" y="87" width="30" height="4" rx="2" fill="#E0E0E0"/>
                </g>
            </svg>
            <h1>TodoManager</h1>
            <p class="tagline">Organize your tasks, achieve your goals</p>
        </div>

        <div class="options-container">
            <div class="option-card" onclick="startFromScratch()">
                <div class="option-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </div>
                <h2 class="option-title">Start from Scratch</h2>
                <p class="option-description">Begin fresh with a clean workspace and create your first task list</p>
            </div>

            <div class="option-card" onclick="continueWorking()">
                <div class="option-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 11l3 3L22 4"></path>
                        <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"></path>
                    </svg>
                </div>
                <h2 class="option-title">Continue Working</h2>
                <p class="option-description">Pick up where you left off and manage your existing tasks</p>
            </div>
        </div>

        <div class="footer">
            <p>&copy; 2025 TodoManager. Built with care.</p>
        </div>
    </div>

    <!-- Hidden file input for importing state -->
    <input type="file" id="import-file-input" accept=".json" style="display: none;" onchange="importData(event)">

    <!-- App Header (shared across pages) -->
    <header id="app-header" class="header hidden">
        <div class="header-left">
            <nav class="tab-nav">
                <button id="tab-home" class="tab-btn active" onclick="switchTab('home')">Todo's</button>
                <button id="tab-engagements" class="tab-btn" onclick="switchTab('engagements')">Engagements</button>
            </nav>
        </div>
        <div class="header-actions">
            <button class="icon-button" onclick="openSettings()" title="Settings">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="3"></circle>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                </svg>
            </button>
            <button class="icon-button" onclick="exportData()" title="Export">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
            </button>
        </div>
    </header>

    <!-- Home Page -->
    <div id="home-page" class="page hidden">

        <!-- Main Content -->
        <main class="main-content">
            <!-- Split Container -->
            <div class="home-split-container">
                <!-- Recommendation Panel (Left) -->
                <div id="recommendation-panel" class="recommendation-panel">
                    <!-- Panel Header -->
                    <div class="recommendation-header">
                        <div class="recommendation-date">
                            <span class="recommendation-date-icon"></span>
                            <span id="recommendation-date-text">Daily Plan</span>
                        </div>
                        <div id="recommendation-summary" class="recommendation-summary"></div>
                    </div>

                    <!-- Panel Content -->
                    <div class="recommendation-content">
                        <!-- Warnings Section -->
                        <div id="warnings-section" class="warnings-section hidden"></div>

                        <!-- Overdue Section -->
                        <div id="overdue-section" class="recommendation-section overdue hidden">
                            <div class="recommendation-section-header">
                                <span class="recommendation-section-icon"></span>
                                <span>Overdue</span>
                                <span id="overdue-count" class="recommendation-section-count">0</span>
                            </div>
                            <div id="overdue-items" class="recommendation-items"></div>
                        </div>

                        <!-- Must Complete Today Section -->
                        <div id="must-do-section" class="recommendation-section must-do hidden">
                            <div class="recommendation-section-header">
                                <span class="recommendation-section-icon"></span>
                                <span>Must Complete Today</span>
                                <span id="must-do-count" class="recommendation-section-count">0</span>
                            </div>
                            <div id="must-do-items" class="recommendation-items"></div>
                        </div>

                        <!-- Recommended Section -->
                        <div id="recommended-section" class="recommendation-section recommended hidden">
                            <div class="recommendation-section-header">
                                <span class="recommendation-section-icon"></span>
                                <span>Recommended</span>
                                <span id="recommended-count" class="recommendation-section-count">0</span>
                            </div>
                            <div id="recommended-items" class="recommendation-items"></div>
                        </div>

                        <!-- If Time Permits Section -->
                        <div id="if-time-section" class="recommendation-section if-time hidden">
                            <div class="recommendation-section-header">
                                <span class="recommendation-section-icon"></span>
                                <span>If Time Permits</span>
                                <span id="if-time-count" class="recommendation-section-count">0</span>
                            </div>
                            <div id="if-time-items" class="recommendation-items"></div>
                        </div>

                        <!-- Insights Section -->
                        <div id="insights-section" class="insights-section hidden">
                            <div class="insights-header">
                                <span></span>
                                <span>Insights</span>
                            </div>
                            <div id="insights-items"></div>
                        </div>

                        <!-- Empty State -->
                        <div id="recommendation-empty" class="recommendation-empty">
                            <div class="recommendation-empty-icon"></div>
                            <p class="recommendation-empty-text">No tasks to recommend.<br>Add some todos to get started!</p>
                        </div>
                    </div>
                </div>

                <!-- Todo Panel (Right) -->
                <div class="todo-panel">
                    <!-- Floating shortcut hint (shown when items exist) -->
                    <p id="todo-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

                    <!-- Todo List Container -->
                    <div id="todo-list" class="todo-list">
                        <!-- Todos will be rendered here -->
                    </div>

                    <!-- Empty State -->
                    <div id="empty-state" class="empty-state">
                        <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"></path>
                            <rect x="9" y="3" width="6" height="4" rx="1"></rect>
                            <line x1="9" y1="12" x2="15" y2="12"></line>
                            <line x1="9" y1="16" x2="13" y2="16"></line>
                        </svg>
                        <p class="empty-text">No Todos</p>
                        <p class="shortcut-hint">Press Shift + N to create new items</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Engagements Page -->
    <div id="engagements-page" class="page hidden">
        <!-- Main Content -->
        <main class="main-content">
            <!-- Archive Toggle -->
            <div class="archive-toggle-container">
                <label class="archive-toggle">
                    <input type="checkbox" id="show-archived-toggle" onchange="toggleShowArchived()">
                    <span>Show Archived</span>
                </label>
            </div>
            <!-- Floating shortcut hint (shown when items exist) -->
            <p id="opp-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

            <!-- Engagement List Container -->
            <div id="engagement-list" class="engagement-list">
                <!-- Engagements will be rendered here -->
            </div>

            <!-- Empty State -->
            <div id="engagement-empty-state" class="empty-state">
                <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                </svg>
                <p class="empty-text">No Engagements</p>
                <p class="shortcut-hint">Press Shift + N to create new items</p>
            </div>
        </main>
    </div>

    <!-- Settings Page -->
    <div id="settings-page" class="page hidden">
        <div class="settings-container">
            <!-- Left Menu -->
            <nav class="settings-menu">
                <h2 class="settings-menu-title">Settings</h2>
                <ul class="settings-menu-list">
                    <li class="settings-menu-item active" data-section="people" onclick="switchSettingsSection('people')">
                        <!-- Multi-user icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                        <span>People</span>
                    </li>
                    <li class="settings-menu-item" data-section="tags" onclick="switchSettingsSection('tags')">
                        <!-- Tag icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                            <line x1="7" y1="7" x2="7.01" y2="7"></line>
                        </svg>
                        <span>Tags</span>
                    </li>
                    <li class="settings-menu-item" data-section="planning" onclick="switchSettingsSection('planning')">
                        <!-- Calendar/Clock icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                            <line x1="16" y1="2" x2="16" y2="6"></line>
                            <line x1="8" y1="2" x2="8" y2="6"></line>
                            <line x1="3" y1="10" x2="21" y2="10"></line>
                            <circle cx="12" cy="15" r="2"></circle>
                        </svg>
                        <span>Planning</span>
                    </li>
                    <li class="settings-menu-item" data-section="storage" onclick="switchSettingsSection('storage')">
                        <!-- Database/Storage icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <ellipse cx="12" cy="5" rx="9" ry="3"></ellipse>
                            <path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path>
                            <path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>
                        </svg>
                        <span>Storage</span>
                    </li>
                </ul>
            </nav>

            <!-- Content Area -->
            <div class="settings-content">
                <!-- Close Button -->
                <button class="settings-close-btn" onclick="closeSettings()" title="Close Settings">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>

                <!-- People Section -->
                <div id="settings-section-people" class="settings-section">
                    <h2 class="settings-section-title">People</h2>

                    <!-- Floating shortcut hint (shown when items exist) -->
                    <p id="people-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

                    <!-- People List Container -->
                    <div id="people-list" class="people-list">
                        <!-- People will be rendered here -->
                    </div>

                    <!-- Empty State -->
                    <div id="people-empty-state" class="empty-state">
                        <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                        <p class="empty-text">No People</p>
                        <p class="shortcut-hint">Press Shift + N to create new items</p>
                    </div>

                    <!-- Roles Section -->
                    <div id="roles-section" class="roles-section hidden">
                        <h3 class="roles-title">Roles</h3>
                        <div id="roles-list" class="roles-list">
                            <!-- Roles will be rendered here -->
                        </div>
                    </div>
                </div>

                <!-- Tags Section -->
                <div id="settings-section-tags" class="settings-section hidden">
                    <h2 class="settings-section-title">Tags</h2>

                    <!-- Floating shortcut hint (shown when items exist) -->
                    <p id="tags-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

                    <!-- Tags List Container -->
                    <div id="tags-list" class="tags-list-container">
                        <!-- Tags will be rendered here -->
                    </div>

                    <!-- Empty State -->
                    <div id="tags-empty-state" class="empty-state">
                        <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                            <line x1="7" y1="7" x2="7.01" y2="7"></line>
                        </svg>
                        <p class="empty-text">No Tags</p>
                        <p class="shortcut-hint">Press Shift + N to create new items</p>
                    </div>
                </div>

                <!-- Planning Section -->
                <div id="settings-section-planning" class="settings-section hidden">
                    <h2 class="settings-section-title">Planning</h2>
                    <p style="color: #6C757D; margin-bottom: 24px;">Configure how the daily recommendation engine calculates and displays your task priorities.</p>

                    <form class="planning-settings-form" onsubmit="savePlanningSettings(event)">
                        <div class="form-group">
                            <label for="workday-minutes" class="form-label">Workday Length (minutes)</label>
                            <input type="number" id="workday-minutes" class="form-input" min="60" max="1440" value="480">
                            <p class="form-hint">How many minutes you plan to work each day (default: 480 = 8 hours)</p>
                        </div>

                        <div class="form-group">
                            <label for="buffer-percentage" class="form-label">Buffer Percentage (%)</label>
                            <input type="number" id="buffer-percentage" class="form-input" min="0" max="50" value="15">
                            <p class="form-hint">Reserve time for interruptions and context switching (default: 15%)</p>
                        </div>

                        <div class="form-group">
                            <label for="max-overdue" class="form-label">Max Overdue Items to Show</label>
                            <input type="number" id="max-overdue" class="form-input" min="1" max="20" value="5">
                            <p class="form-hint">Limit how many overdue items appear in recommendations (default: 5)</p>
                        </div>

                        <div class="form-group">
                            <label for="planning-horizon" class="form-label">Planning Horizon (days)</label>
                            <input type="number" id="planning-horizon" class="form-input" min="1" max="30" value="14">
                            <p class="form-hint">How far ahead to look when recommending tasks (default: 14 days)</p>
                        </div>

                        <button type="submit" class="btn btn-primary btn-save-settings">Save Settings</button>
                    </form>
                </div>

                <!-- Storage Section -->
                <div id="settings-section-storage" class="settings-section hidden">
                    <h2 class="settings-section-title">Storage</h2>
                    <p style="color: #6C757D; margin-bottom: 24px;">View storage statistics and manage browser-stored data.</p>

                    <div class="storage-stats" style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin-bottom: 24px;">
                        <h3 style="font-size: 16px; font-weight: 600; color: #1F1F1F; margin-bottom: 16px;">Storage Statistics</h3>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;">
                            <div style="text-align: center; padding: 16px; background: white; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                <div id="storage-size" style="font-size: 24px; font-weight: 700; color: #3B82F6;">--</div>
                                <div style="font-size: 12px; color: #6C757D; margin-top: 4px;">Estimated Size</div>
                            </div>
                            <div style="text-align: center; padding: 16px; background: white; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                <div id="storage-todos" style="font-size: 24px; font-weight: 700; color: #10B981;">--</div>
                                <div style="font-size: 12px; color: #6C757D; margin-top: 4px;">Todos</div>
                            </div>
                            <div style="text-align: center; padding: 16px; background: white; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                <div id="storage-engagements" style="font-size: 24px; font-weight: 700; color: #F59E0B;">--</div>
                                <div style="font-size: 12px; color: #6C757D; margin-top: 4px;">Engagements</div>
                            </div>
                        </div>
                    </div>

                    <div style="border-top: 1px solid #e5e7eb; padding-top: 24px;">
                        <h3 style="font-size: 16px; font-weight: 600; color: #1F1F1F; margin-bottom: 12px;">Clear Browser State</h3>
                        <p style="color: #6C757D; margin-bottom: 16px; font-size: 14px;">
                            Remove all data stored in your browser. This will delete all todos, engagements, people, tags, and settings.
                        </p>
                        <button type="button" class="btn btn-danger" onclick="openClearStateModal()">
                            Clear Browser State
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tag Modal -->
    <div id="tag-modal" class="modal hidden">
        <div class="modal-content">
            <h2 id="tag-modal-title">New Tag</h2>
            <form id="tag-form" onsubmit="saveTag(event)">
                <div class="form-group">
                    <label for="tag-name" class="form-label">Name *</label>
                    <input type="text" id="tag-name" class="form-input" placeholder="Tag name" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Color *</label>
                    <div class="color-picker-wrapper">
                        <div class="color-picker-input">
                            <div id="tag-color-preview" class="color-picker-preview" style="background-color: #F59E0B;"></div>
                            <span id="tag-color-value" class="color-picker-value">#F59E0B</span>
                        </div>
                        <input type="color" id="tag-color" class="color-picker-native" value="#F59E0B" onchange="updateColorPreview(this.value)">
                    </div>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeTagModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Side Panel for Engagement Details -->
    <div id="side-panel-backdrop" class="side-panel-backdrop" onclick="closeSidePanel()"></div>
    <div id="side-panel" class="side-panel">
        <div class="side-panel-header">
            <h2 class="side-panel-title">Engagement Details</h2>
            <button class="side-panel-close" onclick="closeSidePanel()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="side-panel-body">
            <div class="detail-group">
                <div class="detail-label">Name</div>
                <input type="text" id="panel-eng-name" class="detail-input" placeholder="Enter name..." onblur="savePanelEngagementField('name', this.value)">
            </div>
            <div class="detail-group">
                <div class="detail-label">Description</div>
                <textarea id="panel-eng-description" class="detail-textarea" placeholder="Enter description..." onblur="savePanelEngagementField('description', this.value)"></textarea>
            </div>
            <div class="detail-group">
                <div class="detail-label">Start Date</div>
                <div id="panel-eng-date" class="detail-value"></div>
            </div>
            <div class="detail-group">
                <div class="detail-label">Contact</div>
                <div class="panel-contact-wrapper">
                    <input type="text" id="panel-eng-contact" class="detail-input" placeholder="Search contacts..." autocomplete="off" oninput="filterPanelContacts(this.value)" onfocus="openPanelContactDropdown()" onblur="handlePanelContactBlur(event)">
                    <div id="panel-contact-dropdown" class="panel-contact-dropdown">
                        <!-- Contact dropdown items will be rendered here -->
                    </div>
                </div>
            </div>
            <div class="detail-group">
                <div class="detail-label">Status</div>
                <span id="panel-eng-status" class="status-badge"></span>
            </div>
            <!-- Comments Section -->
            <div class="comments-section">
                <div class="comments-header">Comments</div>
                <div id="panel-comments" class="comments-list">
                    <!-- Comments will be rendered here -->
                </div>
                <!-- Comment Input Area -->
                <div class="comment-input-area">
                    <textarea id="comment-input" class="comment-textarea" placeholder="Add a comment..."></textarea>
                    <button type="button" class="comment-submit-btn" onclick="addComment()">Add Comment</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Create Todo Modal -->
    <div id="todo-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeModal()"></div>
        <div class="modal-content">
            <h2 id="modal-title" class="modal-title">New Todo</h2>
            <form id="todo-form" onsubmit="saveTodo(event)">
                <div class="form-group">
                    <label for="todo-title" class="form-label">Title <span class="required">*</span></label>
                    <input type="text" id="todo-title" class="form-input" placeholder="What needs to be done?" required autofocus>
                </div>
                <div class="form-group">
                    <label for="todo-description" class="form-label">Description</label>
                    <textarea id="todo-description" class="form-textarea" placeholder="Additional details (optional)"></textarea>
                </div>
                <div class="form-group">
                    <label for="todo-deadline" class="form-label">Deadline <span class="required">*</span></label>
                    <input type="datetime-local" id="todo-deadline" class="datetime-input" required>
                </div>
                <div class="form-group">
                    <label for="todo-effort" class="form-label">Effort Level <span class="required">*</span></label>
                    <select id="todo-effort" class="effort-select" required>
                        <option value="very_low">Very Low (30 min)</option>
                        <option value="low">Low (2 hours)</option>
                        <option value="average" selected>Average (4 hours)</option>
                        <option value="high">High (6 hours)</option>
                        <option value="very_high">Very High (8 hours)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="todo-priority" class="form-label">Priority <span class="required">*</span></label>
                    <div class="priority-autocomplete-wrapper">
                        <input type="text" id="todo-priority" class="priority-input" placeholder="Type to select priority..." autocomplete="off" required>
                        <div id="priority-dropdown" class="priority-dropdown">
                            <!-- Priority options will be rendered here -->
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label for="todo-engagement" class="form-label">Linked Engagement</label>
                    <div class="autocomplete-wrapper">
                        <div class="autocomplete-input-wrapper">
                            <input type="text" id="todo-engagement" class="autocomplete-input" placeholder="Type to search or create..." autocomplete="off">
                            <button type="button" id="todo-engagement-clear" class="autocomplete-clear" onclick="clearEngagementSelection()">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="18" y1="6" x2="6" y2="18"></line>
                                    <line x1="6" y1="6" x2="18" y2="18"></line>
                                </svg>
                            </button>
                        </div>
                        <div id="engagement-dropdown" class="autocomplete-dropdown">
                            <!-- Dropdown items will be rendered here -->
                        </div>
                    </div>
                    <!-- Inline Engagement Creation Form -->
                    <div id="inline-eng-form" class="inline-eng-form">
                        <div class="inline-eng-header">
                            <span class="inline-eng-title">Create New Engagement</span>
                            <div class="inline-eng-actions">
                                <button type="button" class="btn btn-secondary" onclick="cancelInlineEngagement()">Cancel</button>
                                <button type="button" class="btn btn-primary" onclick="confirmInlineEngagement()">Add</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="inline-eng-name" class="form-label">Name</label>
                            <input type="text" id="inline-eng-name" class="form-input" placeholder="Engagement name" readonly>
                        </div>
                        <div class="form-group">
                            <label for="inline-eng-description" class="form-label">Description</label>
                            <input type="text" id="inline-eng-description" class="form-input" placeholder="Brief description">
                        </div>
                        <div class="form-group">
                            <label for="inline-eng-start-date" class="form-label">Start Date</label>
                            <input type="date" id="inline-eng-start-date" class="form-input">
                        </div>
                        <div class="form-group">
                            <label for="inline-eng-contact" class="form-label">Contact</label>
                            <div class="autocomplete-wrapper">
                                <input type="text" id="inline-eng-contact" class="form-input" placeholder="Type to search or create person..." autocomplete="off">
                                <button type="button" id="inline-eng-contact-clear" class="autocomplete-clear" onclick="clearInlineOppContact()"></button>
                                <div id="inline-eng-contact-dropdown" class="autocomplete-dropdown">
                                    <!-- Contact dropdown items will be rendered here -->
                                </div>
                            </div>
                            <!-- Inline Person Creation Form (within inline engagement) -->
                            <div id="inline-eng-person-form" class="inline-person-form">
                                <div class="inline-person-header">
                                    <span class="inline-person-title">Create New Person</span>
                                    <div class="inline-person-actions">
                                        <button type="button" class="btn btn-secondary" onclick="cancelInlineOppPerson()">Cancel</button>
                                        <button type="button" class="btn btn-primary" onclick="confirmInlineOppPerson()">Add</button>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label for="inline-eng-person-name" class="form-label">Name</label>
                                    <input type="text" id="inline-eng-person-name" class="form-input" placeholder="Person's name" readonly>
                                </div>
                                <div class="form-group">
                                    <label for="inline-eng-person-role" class="form-label">Role</label>
                                    <input type="text" id="inline-eng-person-role" class="form-input" placeholder="Person's role">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Tags Section -->
                <div class="form-group">
                    <label class="form-label">Tags</label>
                    <div class="tag-input-container" id="todo-tag-container">
                        <div class="selected-tags" id="todo-selected-tags">
                            <!-- Selected tags will be rendered here -->
                        </div>
                        <div class="tag-input-wrapper">
                            <input type="text" id="todo-tag-input" class="tag-input" placeholder="Type to add tags..." autocomplete="off">
                            <div id="todo-tag-dropdown" class="tag-dropdown">
                                <!-- Tag suggestions will be rendered here -->
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                    <span id="todo-save-wrapper" class="btn-tooltip-wrapper">
                        <button type="submit" id="todo-save-btn" class="btn btn-primary">Save</button>
                    </span>
                </div>
            </form>
        </div>
    </div>

    <!-- Create Engagement Modal -->
    <div id="engagement-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeEngagementModal()"></div>
        <div class="modal-content">
            <h2 class="modal-title">New Engagement</h2>
            <form id="engagement-form" onsubmit="saveEngagement(event)">
                <div class="form-group">
                    <label for="eng-name" class="form-label">Name <span class="required">*</span></label>
                    <input type="text" id="eng-name" class="form-input" placeholder="Engagement name" required autofocus>
                </div>
                <div class="form-group">
                    <label for="eng-description" class="form-label">Description</label>
                    <input type="text" id="eng-description" class="form-input" placeholder="Brief description">
                </div>
                <div class="form-group">
                    <label for="eng-start-date" class="form-label">Start Date</label>
                    <input type="date" id="eng-start-date" class="form-input">
                </div>
                <div class="form-group">
                    <label for="eng-contact" class="form-label">Contact</label>
                    <div class="autocomplete-wrapper">
                        <input type="text" id="eng-contact" class="form-input" placeholder="Type to search or create person..." autocomplete="off">
                        <button type="button" id="eng-contact-clear" class="autocomplete-clear" onclick="clearOppContact()"></button>
                        <div id="contact-dropdown" class="autocomplete-dropdown">
                            <!-- Contact dropdown items will be rendered here -->
                        </div>
                    </div>
                    <!-- Inline Person Creation Form -->
                    <div id="inline-person-form" class="inline-person-form">
                        <div class="inline-person-header">
                            <span class="inline-person-title">Create New Person</span>
                            <div class="inline-person-actions">
                                <button type="button" class="btn btn-secondary" onclick="cancelInlinePerson()">Cancel</button>
                                <button type="button" class="btn btn-primary" onclick="confirmInlinePerson()">Add</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="inline-person-name" class="form-label">Name</label>
                            <input type="text" id="inline-person-name" class="form-input" placeholder="Person's name">
                        </div>
                        <div class="form-group">
                            <label for="inline-person-role" class="form-label">Role</label>
                            <input type="text" id="inline-person-role" class="form-input" placeholder="Person's role">
                        </div>
                    </div>
                </div>
                <!-- Tags Section -->
                <div class="form-group">
                    <label class="form-label">Tags</label>
                    <div class="tag-input-container" id="opp-tag-container">
                        <div class="selected-tags" id="opp-selected-tags">
                            <!-- Selected tags will be rendered here -->
                        </div>
                        <div class="tag-input-wrapper">
                            <input type="text" id="opp-tag-input" class="tag-input" placeholder="Type to add tags..." autocomplete="off">
                            <div id="opp-tag-dropdown" class="tag-dropdown">
                                <!-- Tag suggestions will be rendered here -->
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeEngagementModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="confirm-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeConfirmModal()"></div>
        <div class="modal-content confirm-modal-content">
            <svg class="confirm-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
            <h2 class="confirm-title">Delete Engagement?</h2>
            <p id="confirm-message" class="confirm-message">Are you sure you want to delete this engagement? This action cannot be undone.</p>
            <div class="confirm-actions">
                <button type="button" class="btn btn-secondary" onclick="closeConfirmModal()">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="confirmDeleteEngagement()">Delete</button>
            </div>
        </div>
    </div>

    <!-- Cancel Engagement Modal -->
    <div id="cancel-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeCancelModal()"></div>
        <div class="modal-content cancel-modal-content">
            <svg class="cancel-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="15" y1="9" x2="9" y2="15"></line>
                <line x1="9" y1="9" x2="15" y2="15"></line>
            </svg>
            <h2 class="modal-title">Cancel Engagement</h2>
            <p id="cancel-eng-name" style="text-align: center; color: #6C757D; margin-bottom: 20px;"></p>
            <div class="form-group">
                <label for="cancel-reason" class="form-label">Reason for Cancellation <span class="required">*</span></label>
                <textarea id="cancel-reason" class="form-textarea" placeholder="Please provide a reason for cancelling this engagement..." required></textarea>
            </div>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeCancelModal()">Back</button>
                <button type="button" class="btn btn-warning" onclick="confirmCancelEngagement()">Cancel Engagement</button>
            </div>
        </div>
    </div>

    <!-- Person Modal -->
    <div id="person-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closePersonModal()"></div>
        <div class="modal-content">
            <h2 id="person-modal-title" class="modal-title">New Person</h2>
            <form id="person-form" onsubmit="savePerson(event)">
                <div class="form-group">
                    <label for="person-name" class="form-label">Name <span class="required">*</span></label>
                    <input type="text" id="person-name" class="form-input" placeholder="Person's name" required>
                </div>
                <div class="form-group">
                    <label for="person-role" class="form-label">Role</label>
                    <div class="autocomplete-wrapper">
                        <input type="text" id="person-role" class="form-input" placeholder="Type to search or create role..." autocomplete="off">
                        <button type="button" id="person-role-clear" class="autocomplete-clear" onclick="clearPersonRole()"></button>
                        <div id="role-dropdown" class="autocomplete-dropdown">
                            <!-- Role dropdown items will be rendered here -->
                        </div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closePersonModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- IndexedDB Unavailable Warning Modal -->
    <div id="indexeddb-warning-modal" class="modal hidden">
        <div class="modal-backdrop"></div>
        <div class="modal-content confirm-modal-content">
            <svg class="confirm-icon" style="stroke: #EF4444;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
            <h2 class="modal-title">Browser Storage Unavailable</h2>
            <p style="text-align: center; color: #6C757D; margin-bottom: 20px;">
                IndexedDB is not available in your browser. This usually happens when using private/incognito browsing mode.
            </p>
            <p style="text-align: center; color: #6C757D; margin-bottom: 20px;">
                Please switch to a regular browser window to use TodoManager, as your data cannot be saved in private browsing mode.
            </p>
        </div>
    </div>

    <!-- Clear State Confirmation Modal -->
    <div id="clear-state-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeClearStateModal()"></div>
        <div class="modal-content confirm-modal-content">
            <svg class="confirm-icon" style="stroke: #EF4444;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
            <h2 class="modal-title">Clear Browser State</h2>
            <p style="text-align: center; color: #6C757D; margin-bottom: 20px;">
                This will permanently delete all your data stored in the browser, including todos, engagements, people, and settings.
            </p>
            <p style="text-align: center; color: #6C757D; margin-bottom: 20px;">
                Would you like to export your data before clearing?
            </p>
            <div class="modal-actions" style="flex-direction: column; gap: 12px;">
                <button type="button" class="btn btn-primary" onclick="exportThenClear()" style="width: 100%;">Export Data & Clear</button>
                <button type="button" class="btn btn-danger" onclick="confirmClearState()" style="width: 100%;">Clear Without Export</button>
                <button type="button" class="btn btn-secondary" onclick="closeClearStateModal()" style="width: 100%;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Delete Person Confirmation Modal -->
    <div id="delete-person-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeDeletePersonModal()"></div>
        <div class="modal-content confirm-modal-content">
            <svg class="confirm-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
            <h2 class="modal-title">Delete Person</h2>
            <p id="delete-person-name" style="text-align: center; color: #6C757D; margin-bottom: 20px;"></p>
            <p style="text-align: center; margin-bottom: 20px;">Are you sure you want to delete this person? This will remove them from any linked engagements.</p>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeDeletePersonModal()">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="confirmDeletePerson()">Delete</button>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // PRIORITY TAGS - System-defined constants
        // ========================================
        const PRIORITY_TAGS = Object.freeze({
            urgent: {
                id: "priority-urgent",
                name: "urgent",
                label: "Urgent",
                color: "#ef4444",
                weight: 100,
                description: "Must be addressed immediately"
            },
            high: {
                id: "priority-high",
                name: "high",
                label: "High Priority",
                color: "#f97316",
                weight: 75,
                description: "Important, should be done soon"
            },
            normal: {
                id: "priority-normal",
                name: "normal",
                label: "Normal",
                color: "#3b82f6",
                weight: 50,
                description: "Standard priority"
            },
            low: {
                id: "priority-low",
                name: "low",
                label: "Low Priority",
                color: "#6b7280",
                weight: 25,
                description: "Can wait, do when time permits"
            },
            someday: {
                id: "priority-someday",
                name: "someday",
                label: "Someday",
                color: "#9ca3af",
                weight: 10,
                description: "No urgency, backlog item"
            }
        });

        const DEFAULT_PRIORITY = "normal";

        // ========================================
        // EFFORT LEVELS - Configuration
        // ========================================
        const EFFORT_CONFIG = Object.freeze({
            very_low:  { label: "Very Low",  minutes: 30,  icon: "" },
            low:       { label: "Low",       minutes: 120, icon: "" },
            average:   { label: "Average",   minutes: 240, icon: "" },
            high:      { label: "High",      minutes: 360, icon: "" },
            very_high: { label: "Very High", minutes: 480, icon: "" }
        });

        const DEFAULT_EFFORT = "average";

        // ========================================
        // PLANNING SETTINGS - Defaults
        // ========================================
        const DEFAULT_SETTINGS = Object.freeze({
            workdayMinutes: 480,        // 8-hour workday
            bufferPercentage: 15,       // 15% buffer for interruptions
            maxOverdueToShow: 5,        // Limit overdue display
            planningHorizonDays: 14     // Look-ahead window
        });

        // ========================================
        // INDEXEDDB - State Persistence
        // ========================================
        const DB_NAME = 'TodoManagerDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'appState';
        let db = null;

        // Check if IndexedDB is available
        function isIndexedDBAvailable() {
            try {
                if (!window.indexedDB) {
                    return false;
                }
                // Test if we can actually open a database (fails in private mode on some browsers)
                return true;
            } catch (e) {
                return false;
            }
        }

        // Initialize IndexedDB
        function initDB() {
            return new Promise((resolve, reject) => {
                if (!isIndexedDBAvailable()) {
                    reject(new Error('IndexedDB is not available. Please ensure you are not in private browsing mode.'));
                    return;
                }

                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = (event) => {
                    reject(new Error('Failed to open database: ' + event.target.error));
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    const database = event.target.result;
                    if (!database.objectStoreNames.contains(STORE_NAME)) {
                        database.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    }
                };
            });
        }

        // Save state to IndexedDB
        function saveStateToIndexedDB() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const persistableState = {
                    id: 'state',
                    todos: state.todos,
                    engagements: state.engagements,
                    people: state.people,
                    roles: state.roles,
                    tags: state.tags,
                    settings: state.settings,
                    lastModified: new Date().toISOString()
                };

                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(persistableState);

                request.onsuccess = () => resolve();
                request.onerror = () => reject(new Error('Failed to save state'));
            });
        }

        // Load state from IndexedDB
        function loadStateFromIndexedDB() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get('state');

                request.onsuccess = (event) => {
                    const savedState = event.target.result;
                    if (savedState) {
                        resolve(savedState);
                    } else {
                        resolve(null);
                    }
                };

                request.onerror = () => reject(new Error('Failed to load state'));
            });
        }

        // Clear all data from IndexedDB
        function clearIndexedDB() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.clear();

                request.onsuccess = () => resolve();
                request.onerror = () => reject(new Error('Failed to clear database'));
            });
        }

        // Get storage statistics
        async function getStorageStats() {
            const stats = {
                todoCount: state.todos.length,
                engagementCount: state.engagements.length,
                estimatedSize: 0
            };

            // Calculate estimated size
            const dataToMeasure = {
                todos: state.todos,
                engagements: state.engagements,
                people: state.people,
                roles: state.roles,
                tags: state.tags,
                settings: state.settings
            };

            const jsonString = JSON.stringify(dataToMeasure);
            stats.estimatedSize = new Blob([jsonString]).size;

            return stats;
        }

        // Format bytes to human-readable string
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Application state
        const state = {
            todos: [],
            engagements: [],
            people: [],
            roles: [],
            tags: [],
            currentPage: 'landing',
            currentTab: 'home',  // 'home', 'engagements', or 'settings'
            previousTab: 'home',  // Track previous tab for settings return navigation
            settingsSection: 'people',  // Current settings section
            modalOpen: false,
            engagementModalOpen: false,
            personModalOpen: false,
            confirmModalOpen: false,
            cancelModalOpen: false,
            sidePanelOpen: false,
            editingTodoIndex: null,  // Track which todo is being edited (null = create mode)
            editingPersonIndex: null,  // Track which person is being edited (null = create mode)
            editingTagIndex: null,  // Track which tag is being edited (null = create mode)
            tagModalOpen: false,
            selectedEngagementIndex: null,  // Track which engagement is open in side panel
            editingEngagementIndex: null,  // Track which engagement is being edited (null = create mode)
            panelContactId: null,  // Track selected contact in side panel
            panelContactDropdownOpen: false,  // Track panel contact dropdown state
            deleteEngagementIndex: null,  // Track which engagement is pending deletion
            deletePersonIndex: null,  // Track which person is pending deletion
            cancelEngagementIndex: null,  // Track which engagement is pending cancellation
            // Autocomplete state
            selectedEngagementId: null,  // ID of selected engagement for todo linking
            selectedPersonId: null,  // ID of selected person for engagement contact
            pendingEngagement: null,  // New engagement to create when saving todo
            pendingPerson: null,  // New person to create when saving engagement
            autocompleteOpen: false,
            autocompleteHighlightIndex: -1,
            roleAutocompleteOpen: false,
            roleAutocompleteHighlightIndex: -1,
            contactAutocompleteOpen: false,
            contactAutocompleteHighlightIndex: -1,
            inlineEngFormOpen: false,
            inlinePersonFormOpen: false,
            // Inline person form within inline engagement (in Todo modal)
            inlineEngContactAutocompleteOpen: false,
            inlineEngContactAutocompleteHighlightIndex: -1,
            inlineEngPersonFormOpen: false,
            selectedInlineOppPersonId: null,
            pendingInlineOppPerson: null,
            showArchived: false,
            // Tag assignment state
            selectedTodoTagIds: [],  // Tag IDs selected for current todo
            selectedOppTagIds: [],   // Tag IDs selected for current engagement
            todoTagDropdownOpen: false,
            todoTagHighlightIndex: -1,
            engTagDropdownOpen: false,
            oppTagHighlightIndex: -1,
            // Planning settings
            settings: { ...DEFAULT_SETTINGS },
            // Priority autocomplete state
            selectedPriority: DEFAULT_PRIORITY,
            priorityDropdownOpen: false,
            priorityHighlightIndex: -1
        };

        // DOM Elements - Landing and Home
        const landingPage = document.getElementById('landing-page');
        const homePage = document.getElementById('home-page');
        const todoList = document.getElementById('todo-list');
        const emptyState = document.getElementById('empty-state');
        const todoShortcutHintFloating = document.getElementById('todo-shortcut-hint-floating');
        const todoModal = document.getElementById('todo-modal');
        const todoForm = document.getElementById('todo-form');
        const todoTitleInput = document.getElementById('todo-title');
        const todoDescriptionInput = document.getElementById('todo-description');
        const todoDeadlineInput = document.getElementById('todo-deadline');
        const todoEffortSelect = document.getElementById('todo-effort');
        const todoPriorityInput = document.getElementById('todo-priority');
        const priorityDropdown = document.getElementById('priority-dropdown');
        const modalTitle = document.getElementById('modal-title');
        const todoSaveBtn = document.getElementById('todo-save-btn');
        const todoSaveWrapper = document.getElementById('todo-save-wrapper');

        // DOM Elements - Recommendation Panel
        const recommendationPanel = document.getElementById('recommendation-panel');
        const recommendationDateText = document.getElementById('recommendation-date-text');
        const recommendationSummary = document.getElementById('recommendation-summary');
        const warningsSection = document.getElementById('warnings-section');
        const overdueSection = document.getElementById('overdue-section');
        const overdueItems = document.getElementById('overdue-items');
        const overdueCount = document.getElementById('overdue-count');
        const mustDoSection = document.getElementById('must-do-section');
        const mustDoItems = document.getElementById('must-do-items');
        const mustDoCount = document.getElementById('must-do-count');
        const recommendedSection = document.getElementById('recommended-section');
        const recommendedItems = document.getElementById('recommended-items');
        const recommendedCount = document.getElementById('recommended-count');
        const ifTimeSection = document.getElementById('if-time-section');
        const ifTimeItems = document.getElementById('if-time-items');
        const ifTimeCount = document.getElementById('if-time-count');
        const insightsSection = document.getElementById('insights-section');
        const insightsItems = document.getElementById('insights-items');
        const recommendationEmpty = document.getElementById('recommendation-empty');

        // DOM Elements - Autocomplete
        const todoEngagementInput = document.getElementById('todo-engagement');
        const todoEngagementClear = document.getElementById('todo-engagement-clear');
        const engagementDropdown = document.getElementById('engagement-dropdown');
        const inlineEngForm = document.getElementById('inline-eng-form');
        const inlineEngName = document.getElementById('inline-eng-name');
        const inlineEngDescription = document.getElementById('inline-eng-description');
        const inlineEngStartDate = document.getElementById('inline-eng-start-date');
        const inlineEngContact = document.getElementById('inline-eng-contact');
        const inlineEngContactClear = document.getElementById('inline-eng-contact-clear');
        const inlineEngContactDropdown = document.getElementById('inline-eng-contact-dropdown');
        const inlineEngPersonForm = document.getElementById('inline-eng-person-form');
        const inlineEngPersonName = document.getElementById('inline-eng-person-name');
        const inlineEngPersonRole = document.getElementById('inline-eng-person-role');

        // DOM Elements - Engagements
        const engagementsPage = document.getElementById('engagements-page');
        const engagementList = document.getElementById('engagement-list');
        const engagementEmptyState = document.getElementById('engagement-empty-state');
        const oppShortcutHintFloating = document.getElementById('opp-shortcut-hint-floating');
        const engagementModal = document.getElementById('engagement-modal');
        const engagementForm = document.getElementById('engagement-form');
        const engNameInput = document.getElementById('eng-name');
        const engDescriptionInput = document.getElementById('eng-description');
        const engStartDateInput = document.getElementById('eng-start-date');
        const engContactInput = document.getElementById('eng-contact');
        const engContactClear = document.getElementById('eng-contact-clear');
        const contactDropdown = document.getElementById('contact-dropdown');
        const inlinePersonForm = document.getElementById('inline-person-form');
        const inlinePersonName = document.getElementById('inline-person-name');
        const inlinePersonRole = document.getElementById('inline-person-role');

        // DOM Elements - Side Panel
        const sidePanel = document.getElementById('side-panel');
        const sidePanelBackdrop = document.getElementById('side-panel-backdrop');
        const panelEngName = document.getElementById('panel-eng-name');
        const panelEngDescription = document.getElementById('panel-eng-description');
        const panelEngDate = document.getElementById('panel-eng-date');
        const panelEngContact = document.getElementById('panel-eng-contact');
        const panelContactDropdown = document.getElementById('panel-contact-dropdown');
        const panelEngStatus = document.getElementById('panel-eng-status');

        // DOM Elements - Header and Tabs
        const appHeader = document.getElementById('app-header');
        const tabHome = document.getElementById('tab-home');
        const tabEngagements = document.getElementById('tab-engagements');

        // DOM Elements - Confirmation Modal
        const confirmModal = document.getElementById('confirm-modal');
        const confirmMessage = document.getElementById('confirm-message');

        // DOM Elements - Cancel Modal
        const cancelModal = document.getElementById('cancel-modal');
        const cancelOppName = document.getElementById('cancel-eng-name');
        const cancelReason = document.getElementById('cancel-reason');

        // DOM Elements - Comments
        const panelComments = document.getElementById('panel-comments');
        const commentInput = document.getElementById('comment-input');

        // DOM Elements - Archive Toggle
        const showArchivedToggle = document.getElementById('show-archived-toggle');

        // DOM Elements - Settings
        const settingsPage = document.getElementById('settings-page');
        const peopleList = document.getElementById('people-list');
        const peopleEmptyState = document.getElementById('people-empty-state');
        const peopleShortcutHintFloating = document.getElementById('people-shortcut-hint-floating');
        const rolesSection = document.getElementById('roles-section');
        const rolesList = document.getElementById('roles-list');

        // DOM Elements - Tags
        const tagsList = document.getElementById('tags-list');
        const tagsEmptyState = document.getElementById('tags-empty-state');
        const tagsShortcutHintFloating = document.getElementById('tags-shortcut-hint-floating');
        const settingsSectionPeople = document.getElementById('settings-section-people');
        const settingsSectionTags = document.getElementById('settings-section-tags');

        // DOM Elements - Tag Modal
        const tagModal = document.getElementById('tag-modal');
        const tagModalTitle = document.getElementById('tag-modal-title');
        const tagForm = document.getElementById('tag-form');
        const tagNameInput = document.getElementById('tag-name');
        const tagColorInput = document.getElementById('tag-color');
        const tagColorPreview = document.getElementById('tag-color-preview');
        const tagColorValue = document.getElementById('tag-color-value');

        // DOM Elements - Tag Input (Todo form)
        const todoTagInput = document.getElementById('todo-tag-input');
        const todoTagDropdown = document.getElementById('todo-tag-dropdown');
        const todoSelectedTags = document.getElementById('todo-selected-tags');

        // DOM Elements - Tag Input (Engagement form)
        const engTagInput = document.getElementById('opp-tag-input');
        const engTagDropdown = document.getElementById('opp-tag-dropdown');
        const engSelectedTags = document.getElementById('opp-selected-tags');

        // DOM Elements - Person Modal
        const personModal = document.getElementById('person-modal');
        const personModalTitle = document.getElementById('person-modal-title');
        const personForm = document.getElementById('person-form');
        const personNameInput = document.getElementById('person-name');
        const personRoleInput = document.getElementById('person-role');
        const personRoleClear = document.getElementById('person-role-clear');
        const roleDropdown = document.getElementById('role-dropdown');

        // DOM Elements - Delete Person Modal
        const deletePersonModal = document.getElementById('delete-person-modal');
        const deletePersonName = document.getElementById('delete-person-name');

        // Navigation functions
        function navigateTo(page) {
            // Hide all pages
            landingPage.classList.add('hidden');
            landingPage.classList.remove('container');
            homePage.classList.add('hidden');
            engagementsPage.classList.add('hidden');
            settingsPage.classList.add('hidden');
            appHeader.classList.add('hidden');

            // Show requested page
            if (page === 'landing') {
                landingPage.classList.remove('hidden');
                landingPage.classList.add('container');
                document.body.style.display = 'flex';
                document.body.style.alignItems = 'center';
                document.body.style.justifyContent = 'center';
            } else if (page === 'app') {
                // Show app with header and current tab
                appHeader.classList.remove('hidden');
                document.body.style.display = 'block';
                document.body.style.alignItems = '';
                document.body.style.justifyContent = '';
                // Set currentPage before switchTab so render functions pass their guards
                state.currentPage = page;
                switchTab(state.currentTab);
            }

            state.currentPage = page;
        }

        // Tab switching function
        function switchTab(tab) {
            state.currentTab = tab;

            // Update tab buttons (settings doesn't have a tab button)
            tabHome.classList.toggle('active', tab === 'home');
            tabEngagements.classList.toggle('active', tab === 'engagements');

            // Show/hide pages
            homePage.classList.toggle('hidden', tab !== 'home');
            engagementsPage.classList.toggle('hidden', tab !== 'engagements');
            settingsPage.classList.toggle('hidden', tab !== 'settings');

            // Render content
            if (tab === 'home') {
                renderTodos();
            } else if (tab === 'engagements') {
                renderEngagements();
            } else if (tab === 'settings') {
                renderPeople();
            }
        }

        // Open Settings page
        function openSettings() {
            // Save current tab before navigating to settings
            if (state.currentTab !== 'settings') {
                state.previousTab = state.currentTab;
            }
            switchTab('settings');
        }

        // Close Settings and return to previous page
        function closeSettings() {
            switchTab(state.previousTab);
        }

        // Switch settings section
        function switchSettingsSection(section) {
            state.settingsSection = section;

            // Update menu item active state
            const menuItems = document.querySelectorAll('.settings-menu-item');
            menuItems.forEach(item => {
                item.classList.toggle('active', item.dataset.section === section);
            });

            // Toggle section visibility
            const peopleSection = document.getElementById('settings-section-people');
            const tagsSection = document.getElementById('settings-section-tags');
            const planningSection = document.getElementById('settings-section-planning');
            const storageSection = document.getElementById('settings-section-storage');

            // Hide all sections
            peopleSection.classList.add('hidden');
            tagsSection.classList.add('hidden');
            planningSection.classList.add('hidden');
            storageSection.classList.add('hidden');

            if (section === 'people') {
                peopleSection.classList.remove('hidden');
                renderPeople();
            } else if (section === 'tags') {
                tagsSection.classList.remove('hidden');
                renderTags();
            } else if (section === 'planning') {
                planningSection.classList.remove('hidden');
                renderPlanningSettings();
            } else if (section === 'storage') {
                storageSection.classList.remove('hidden');
                renderStorageSection();
            }
        }

        function startFromScratch() {
            // Clear data and navigate to app
            state.todos = [];
            state.engagements = [];
            state.people = [];
            state.roles = [];
            state.tags = [];
            state.settings = { ...DEFAULT_SETTINGS };
            state.currentTab = 'home';
            navigateTo('app');
            // Save initial empty state to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save initial state:', err));
        }

        function continueWorking() {
            // Trigger file input to load previous state (for importing from file)
            document.getElementById('import-file-input').click();
        }

        // Export app state to JSON file
        function exportData() {
            // Collect all data entities from state
            const exportableData = {
                version: '1.0',
                lastModified: new Date().toISOString(),
                settings: state.settings,
                userTags: state.tags,  // Renamed for spec compliance
                todos: state.todos,
                engagements: state.engagements,
                people: state.people,
                roles: state.roles,
                tags: state.tags,  // Keep for backward compatibility
                exportedAt: new Date().toISOString()
            };

            // Create JSON blob
            const jsonString = JSON.stringify(exportableData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });

            // Generate filename with timestamp
            const now = new Date();
            const timestamp = now.toISOString()
                .replace(/T/, '_')
                .replace(/:/g, '-')
                .replace(/\..+/, '');
            const filename = `todoApp_${timestamp}.json`;

            // Create download link and trigger download
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Import app state from JSON file
        function importData(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);

                    // Validate required data structure
                    if (!importedData || typeof importedData !== 'object') {
                        throw new Error('Invalid file format');
                    }

                    // Restore state data entities (with fallbacks for missing fields)
                    state.todos = Array.isArray(importedData.todos) ? importedData.todos : [];
                    state.engagements = Array.isArray(importedData.engagements) ? importedData.engagements : [];
                    state.people = Array.isArray(importedData.people) ? importedData.people : [];
                    state.roles = Array.isArray(importedData.roles) ? importedData.roles : [];
                    // Support both old 'tags' and new 'userTags' format
                    state.tags = Array.isArray(importedData.userTags) ? importedData.userTags :
                                 Array.isArray(importedData.tags) ? importedData.tags : [];

                    // Restore planning settings (merge with defaults)
                    if (importedData.settings && typeof importedData.settings === 'object') {
                        state.settings = { ...DEFAULT_SETTINGS, ...importedData.settings };
                    } else {
                        state.settings = { ...DEFAULT_SETTINGS };
                    }

                    // Ensure all todos have required new fields with defaults
                    state.todos = state.todos.map(todo => ({
                        ...todo,
                        title: todo.title || todo.description || 'Untitled',
                        description: todo.description || null,
                        deadline: todo.deadline || (todo.dueDate ? new Date(todo.dueDate).toISOString() : null),
                        effort: todo.effort || DEFAULT_EFFORT,
                        priority: PRIORITY_TAGS[todo.priority] ? todo.priority : DEFAULT_PRIORITY,
                        completedAt: todo.completedAt || null,
                        createdAt: todo.createdAt || new Date().toISOString(),
                        updatedAt: todo.updatedAt || new Date().toISOString()
                    }));

                    // Navigate to app and render
                    navigateTo('app');
                    renderTodos();
                    renderEngagements();
                    renderPeople();
                    renderTags();
                    loadPlanningSettings();

                    // Save imported data to IndexedDB
                    saveStateToIndexedDB().catch(err => console.error('Failed to save imported state:', err));

                } catch (error) {
                    alert('Error importing file: ' + error.message + '\n\nPlease ensure you selected a valid TodoApp export file.');
                }

                // Reset file input for future imports
                event.target.value = '';
            };

            reader.onerror = function() {
                alert('Error reading file. Please try again.');
                event.target.value = '';
            };

            reader.readAsText(file);
        }

        // Data persistence - saves to IndexedDB
        function saveData() {
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Modal functions
        function openModal(todoIndex = null) {
            todoModal.classList.remove('hidden');
            state.modalOpen = true;
            state.editingTodoIndex = todoIndex;

            // Reset form
            todoForm.reset();

            // Reset autocomplete state
            state.selectedEngagementId = null;
            state.pendingEngagement = null;
            state.autocompleteOpen = false;
            state.autocompleteHighlightIndex = -1;
            state.inlineEngFormOpen = false;
            // Reset inline opp person state
            state.inlineEngContactAutocompleteOpen = false;
            state.inlineEngContactAutocompleteHighlightIndex = -1;
            state.inlineEngPersonFormOpen = false;
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;
            todoEngagementInput.value = '';
            todoEngagementClear.classList.remove('visible');
            engagementDropdown.classList.remove('open');
            inlineEngForm.classList.remove('open');
            // Reset inline opp contact fields
            inlineEngContact.value = '';
            inlineEngContactClear.classList.remove('visible');
            inlineEngContactDropdown.classList.remove('open');
            inlineEngPersonForm.classList.remove('open');

            // Reset tag input state
            state.selectedTodoTagIds = [];
            state.todoTagDropdownOpen = false;
            state.todoTagHighlightIndex = -1;
            todoTagInput.value = '';
            closeTodoTagDropdown();

            // Reset priority state
            state.selectedPriority = DEFAULT_PRIORITY;
            state.priorityDropdownOpen = false;
            state.priorityHighlightIndex = -1;
            closePriorityDropdown();

            // Reset Save button state
            updateTodoSaveButtonState();

            if (todoIndex !== null) {
                // Edit mode - populate with existing todo data
                const todo = state.todos[todoIndex];
                modalTitle.textContent = 'Edit Todo';
                todoTitleInput.value = todo.title || '';
                todoDescriptionInput.value = todo.description || '';

                // Handle deadline (support both new deadline and old dueDate)
                if (todo.deadline) {
                    todoDeadlineInput.value = formatDateTimeLocal(new Date(todo.deadline));
                } else if (todo.dueDate) {
                    // Convert old dueDate to deadline with default time
                    const oldDate = new Date(todo.dueDate);
                    oldDate.setHours(17, 0, 0, 0);
                    todoDeadlineInput.value = formatDateTimeLocal(oldDate);
                } else {
                    todoDeadlineInput.value = getDefaultDeadline();
                }

                // Set effort
                todoEffortSelect.value = todo.effort || DEFAULT_EFFORT;

                // Set priority
                state.selectedPriority = todo.priority || DEFAULT_PRIORITY;
                todoPriorityInput.value = PRIORITY_TAGS[state.selectedPriority].label;

                // Pre-populate linked engagement
                if (todo.engagementId) {
                    const opp = state.engagements.find(o => o.id === todo.engagementId);
                    if (opp) {
                        state.selectedEngagementId = opp.id;
                        todoEngagementInput.value = opp.name;
                        todoEngagementClear.classList.add('visible');
                    }
                }

                // Pre-populate tags
                if (todo.tagIds && Array.isArray(todo.tagIds)) {
                    state.selectedTodoTagIds = [...todo.tagIds];
                }
            } else {
                // Create mode
                modalTitle.textContent = 'New Todo';
                // Set default deadline to 5 PM today
                todoDeadlineInput.value = getDefaultDeadline();
                // Set default effort
                todoEffortSelect.value = DEFAULT_EFFORT;
                // Set default priority
                state.selectedPriority = DEFAULT_PRIORITY;
                todoPriorityInput.value = PRIORITY_TAGS[DEFAULT_PRIORITY].label;
            }

            // Render selected tags
            renderTodoSelectedTags();

            // Focus on title input
            setTimeout(() => todoTitleInput.focus(), 100);
        }

        // Edit a todo - opens modal in edit mode
        function editTodo(index) {
            openModal(index);
        }

        // Get today's date in YYYY-MM-DD format for date input
        function getTodayDate() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function closeModal() {
            todoModal.classList.add('hidden');
            state.modalOpen = false;
            state.editingTodoIndex = null;
            state.selectedEngagementId = null;
            state.pendingEngagement = null;
            state.autocompleteOpen = false;
            state.inlineEngFormOpen = false;
            todoForm.reset();
            engagementDropdown.classList.remove('open');
            inlineEngForm.classList.remove('open');
        }

        // Generate unique ID
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
        }

        // Save todo (handles both create and update)
        function saveTodo(event) {
            event.preventDefault();

            const title = todoTitleInput.value.trim();
            const description = todoDescriptionInput.value.trim();
            const deadline = todoDeadlineInput.value;
            const effort = todoEffortSelect.value;
            const priority = state.selectedPriority;

            if (!title) return;
            if (!deadline) return;

            // Handle pending engagement creation
            let engagementId = state.selectedEngagementId;
            if (state.pendingEngagement) {
                // First, handle person creation if needed
                let contactPersonId = state.pendingEngagement.contactPersonId;

                // Check for pending person from inline eng form (may be set after engagement was confirmed)
                const pendingPersonData = state.pendingEngagement.pendingPerson || state.pendingInlineOppPerson;

                if (pendingPersonData) {
                    // Create the new person (use the combined pending person data)
                    const pendingPerson = pendingPersonData;

                    // Handle role creation if needed
                    let roleId = null;
                    if (pendingPerson.role) {
                        // Check if role exists
                        const existingRole = state.roles.find(r => r.name.toLowerCase() === pendingPerson.role.toLowerCase());
                        if (existingRole) {
                            roleId = existingRole.id;
                        } else {
                            // Create new role
                            const newRole = {
                                id: generateId(),
                                name: pendingPerson.role,
                                createdAt: new Date().toISOString()
                            };
                            state.roles.push(newRole);
                            roleId = newRole.id;
                        }
                    }

                    // Create the person
                    const newPerson = {
                        id: generateId(),
                        name: pendingPerson.name,
                        roleId: roleId,
                        createdAt: new Date().toISOString()
                    };
                    state.people.push(newPerson);
                    contactPersonId = newPerson.id;
                }

                // Create the new engagement
                const newOpp = {
                    id: generateId(),
                    name: state.pendingEngagement.name,
                    description: state.pendingEngagement.description || null,
                    startDate: state.pendingEngagement.startDate || getTodayDate(),
                    contactPersonId: contactPersonId || null,
                    status: 'requested',
                    comments: [],
                    archived: false,
                    createdAt: new Date().toISOString()
                };
                state.engagements.push(newOpp);
                engagementId = newOpp.id;
            }

            if (state.editingTodoIndex !== null) {
                // Update existing todo
                const todo = state.todos[state.editingTodoIndex];
                todo.title = title;
                todo.description = description || null;
                todo.deadline = new Date(deadline).toISOString();
                todo.effort = effort;
                todo.priority = priority;
                todo.engagementId = engagementId;
                todo.tagIds = [...state.selectedTodoTagIds];
                todo.updatedAt = new Date().toISOString();
                // Preserve id, completed, completedAt, and createdAt
            } else {
                // Create new todo
                const now = new Date().toISOString();
                const newTodo = {
                    id: generateId(),
                    title: title,
                    description: description || null,
                    deadline: new Date(deadline).toISOString(),
                    effort: effort,
                    priority: priority,
                    engagementId: engagementId,
                    tagIds: [...state.selectedTodoTagIds],
                    completed: false,
                    completedAt: null,
                    createdAt: now,
                    updatedAt: now
                };
                state.todos.push(newTodo);
            }

            // Auto-update engagement status to Open if todo is linked and not completed
            if (engagementId) {
                updateEngagementAutoStatus(engagementId);
            }

            closeModal();
            renderTodos();
            // Also re-render engagements if on that tab
            if (state.currentTab === 'engagements') {
                renderEngagements();
            }
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Auto-update engagement status based on linked todos
        // Status Flow: Requested  Open (when todo linked)  Paused (all todos complete)  Closed
        function updateEngagementAutoStatus(engagementId) {
            const opp = state.engagements.find(o => o.id === engagementId);
            if (!opp) return;

            // Don't change closed or cancelled engagements
            if (opp.status === 'closed' || opp.status === 'cancelled') return;

            // Get all todos linked to this engagement
            const linkedTodos = state.todos.filter(t => t.engagementId === engagementId);

            // Check if any linked todo is not completed
            const hasActiveTodo = linkedTodos.some(t => !t.completed);
            const hasAnyTodo = linkedTodos.length > 0;

            if (hasActiveTodo) {
                // Has non-completed todos  Open
                if (opp.status !== 'open') {
                    opp.status = 'open';
                }
            } else if (hasAnyTodo) {
                // All todos are completed  Paused
                if (opp.status !== 'paused') {
                    opp.status = 'paused';
                }
            }
            // If no todos linked, keep current status
        }

        // Render functions
        function renderTodos() {
            if (state.currentPage !== 'app' || state.currentTab !== 'home') return;

            // Clear current list
            todoList.innerHTML = '';

            // Also render recommendation panel
            renderRecommendationPanel();

            if (state.todos.length === 0) {
                // Show empty state
                todoList.classList.add('hidden');
                emptyState.classList.remove('hidden');
                todoShortcutHintFloating.classList.add('hidden');
            } else {
                // Show todo list
                todoList.classList.remove('hidden');
                emptyState.classList.add('hidden');
                todoShortcutHintFloating.classList.remove('hidden');

                // Create sorted array with original indices preserved
                const sortedTodos = state.todos
                    .map((todo, index) => ({ todo, originalIndex: index }))
                    .sort((a, b) => {
                        // Incomplete todos first, then completed
                        if (a.todo.completed !== b.todo.completed) {
                            return a.todo.completed ? 1 : -1;
                        }

                        if (a.todo.completed) {
                            // Both completed: sort by completedAt (most recent first)
                            const aTime = a.todo.completedAt ? new Date(a.todo.completedAt).getTime() : 0;
                            const bTime = b.todo.completedAt ? new Date(b.todo.completedAt).getTime() : 0;
                            return bTime - aTime;
                        } else {
                            // Both incomplete: sort by dueDate (earliest first)
                            const aDate = a.todo.dueDate ? new Date(a.todo.dueDate).getTime() : Infinity;
                            const bDate = b.todo.dueDate ? new Date(b.todo.dueDate).getTime() : Infinity;
                            return aDate - bDate;
                        }
                    });

                sortedTodos.forEach(({ todo, originalIndex: index }) => {
                    const todoItem = document.createElement('div');
                    todoItem.className = `todo-item ${todo.completed ? 'completed' : ''}`;

                    // Format deadline (supports both old dueDate and new deadline)
                    let dueDateHtml = '';
                    const deadlineValue = todo.deadline || todo.dueDate;
                    if (deadlineValue) {
                        const dueDate = new Date(deadlineValue);
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);
                        const isOverdue = dueDate < today && !todo.completed;
                        dueDateHtml = `<div class="todo-due-date ${isOverdue ? 'overdue' : ''}"> ${formatDeadlineDisplay(deadlineValue)}</div>`;
                    }

                    // Format effort
                    let effortHtml = '';
                    const effort = todo.effort || DEFAULT_EFFORT;
                    const effortConfig = EFFORT_CONFIG[effort];
                    if (effortConfig) {
                        effortHtml = `<span class="todo-effort"><span class="todo-effort-icon">${effortConfig.icon}</span> ${formatEffortDisplay(effort)}</span>`;
                    }

                    // Format priority
                    let priorityHtml = '';
                    const priority = todo.priority || DEFAULT_PRIORITY;
                    if (priority && priority !== 'normal') {
                        const priorityTag = PRIORITY_TAGS[priority];
                        if (priorityTag) {
                            priorityHtml = `<span class="priority-pill priority-${priority}">${priorityTag.label}</span>`;
                        }
                    }

                    // Format linked engagement
                    let engagementHtml = '';
                    if (todo.engagementId) {
                        const opp = state.engagements.find(o => o.id === todo.engagementId);
                        if (opp) {
                            engagementHtml = `
                                <div class="todo-engagement">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <circle cx="12" cy="12" r="10"></circle>
                                        <polyline points="12 6 12 12 16 14"></polyline>
                                    </svg>
                                    ${escapeHtml(opp.name)}
                                </div>
                            `;
                        }
                    }

                    // Format tags (combine priority pill with user tags)
                    let tagsHtml = '';
                    const tagPills = [];

                    // Add priority pill first (if not normal)
                    if (priorityHtml) {
                        tagPills.push(priorityHtml);
                    }

                    // Add effort badge
                    if (effortHtml) {
                        tagPills.push(effortHtml);
                    }

                    // Add user tags
                    if (todo.tagIds && todo.tagIds.length > 0) {
                        todo.tagIds.forEach(tagId => {
                            const tag = getTagById(tagId);
                            if (tag) {
                                tagPills.push(`<span class="tag-pill" style="background-color: ${tag.color}; color: #fff;">${escapeHtml(tag.name)}</span>`);
                            }
                        });
                    }

                    if (tagPills.length > 0) {
                        tagsHtml = `<div class="tags-container">${tagPills.join('')}</div>`;
                    }

                    // Format description for two-column layout
                    let descriptionHtml = '';
                    if (todo.description && todo.description.trim()) {
                        descriptionHtml = `<div class="todo-description">${escapeHtml(todo.description)}</div>`;
                    }

                    todoItem.innerHTML = `
                        <div class="todo-checkbox ${todo.completed ? 'checked' : ''}" onclick="toggleTodo(${index})"></div>
                        <div class="todo-content">
                            <div class="todo-info">
                                <div class="todo-title">${escapeHtml(todo.title)}</div>
                                ${dueDateHtml}
                                ${engagementHtml}
                                ${tagsHtml}
                            </div>
                            ${descriptionHtml}
                        </div>
                        <div class="todo-actions">
                            <button class="todo-edit-btn" onclick="editTodo(${index})" title="Edit">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                        </div>
                    `;
                    todoList.appendChild(todoItem);
                });
            }
        }

        function toggleTodo(index) {
            const todo = state.todos[index];
            todo.completed = !todo.completed;
            todo.completedAt = todo.completed ? new Date().toISOString() : null;
            todo.updatedAt = new Date().toISOString();

            // Track completion timestamp
            if (todo.completed) {
                todo.completedAt = new Date().toISOString();
            } else {
                todo.completedAt = null;
            }

            // Check and update engagement status if linked
            if (todo.engagementId) {
                updateEngagementAutoStatus(todo.engagementId);
            }

            renderTodos();
            // Re-render engagements if on that tab to update status badges
            if (state.currentTab === 'engagements') {
                renderEngagements();
            }
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Utility function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Format date for display
        function formatDate(dateString) {
            const date = new Date(dateString);
            const options = { year: 'numeric', month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        // Engagement Modal functions
        function openEngagementModal() {
            engagementModal.classList.remove('hidden');
            state.engagementModalOpen = true;
            state.editingEngagementIndex = null;  // Create mode

            // Update modal title
            const modalTitle = engagementModal.querySelector('.modal-title');
            if (modalTitle) modalTitle.textContent = 'New Engagement';

            // Reset form
            engagementForm.reset();
            // Set default start date to today
            engStartDateInput.value = getTodayDate();

            // Reset contact autocomplete state
            state.selectedPersonId = null;
            state.pendingPerson = null;
            state.contactAutocompleteOpen = false;
            state.contactAutocompleteHighlightIndex = -1;
            state.inlinePersonFormOpen = false;
            engContactClear.classList.remove('visible');
            contactDropdown.classList.remove('open');
            inlinePersonForm.classList.remove('open');

            // Reset tag input state
            state.selectedOppTagIds = [];
            state.engTagDropdownOpen = false;
            state.oppTagHighlightIndex = -1;
            engTagInput.value = '';
            closeOppTagDropdown();
            renderOppSelectedTags();

            // Focus on name input
            setTimeout(() => engNameInput.focus(), 100);
        }

        // Open engagement modal in edit mode
        function openEditEngagement(index) {
            const eng = state.engagements[index];
            if (!eng) return;

            engagementModal.classList.remove('hidden');
            state.engagementModalOpen = true;
            state.editingEngagementIndex = index;

            // Update modal title
            const modalTitle = engagementModal.querySelector('.modal-title');
            if (modalTitle) modalTitle.textContent = 'Edit Engagement';

            // Reset form first
            engagementForm.reset();

            // Populate form with existing data
            engNameInput.value = eng.name || '';
            engDescriptionInput.value = eng.description || '';
            engStartDateInput.value = eng.startDate || '';

            // Handle contact
            if (eng.contactId) {
                const person = state.people.find(p => p.id === eng.contactId);
                if (person) {
                    state.selectedPersonId = eng.contactId;
                    engContactInput.value = person.name;
                    engContactClear.classList.add('visible');
                } else {
                    state.selectedPersonId = null;
                    engContactInput.value = eng.contact || '';
                    engContactClear.classList.remove('visible');
                }
            } else if (eng.contact) {
                state.selectedPersonId = null;
                engContactInput.value = eng.contact;
                engContactClear.classList.remove('visible');
            } else {
                state.selectedPersonId = null;
                engContactInput.value = '';
                engContactClear.classList.remove('visible');
            }

            // Reset autocomplete state
            state.pendingPerson = null;
            state.contactAutocompleteOpen = false;
            state.contactAutocompleteHighlightIndex = -1;
            state.inlinePersonFormOpen = false;
            contactDropdown.classList.remove('open');
            inlinePersonForm.classList.remove('open');

            // Handle tags
            state.selectedOppTagIds = eng.tagIds ? [...eng.tagIds] : [];
            state.engTagDropdownOpen = false;
            state.oppTagHighlightIndex = -1;
            engTagInput.value = '';
            closeOppTagDropdown();
            renderOppSelectedTags();

            // Focus on name input
            setTimeout(() => engNameInput.focus(), 100);
        }

        function closeEngagementModal() {
            engagementModal.classList.add('hidden');
            state.engagementModalOpen = false;
            state.selectedPersonId = null;
            state.pendingPerson = null;
            state.contactAutocompleteOpen = false;
            state.inlinePersonFormOpen = false;
            engagementForm.reset();
            contactDropdown.classList.remove('open');
            inlinePersonForm.classList.remove('open');
        }

        // Save engagement
        function saveEngagement(event) {
            event.preventDefault();

            const name = engNameInput.value.trim();
            const description = engDescriptionInput.value.trim();
            const startDate = engStartDateInput.value;
            const contactName = engContactInput.value.trim();

            if (!name) return;

            // Handle pending person creation
            let contactId = state.selectedPersonId;
            if (state.pendingPerson) {
                // Create the pending person
                const roleId = getOrCreateRole(state.pendingPerson.role);
                const newPerson = {
                    id: generateId(),
                    name: state.pendingPerson.name,
                    roleId: roleId
                };
                state.people.push(newPerson);
                contactId = newPerson.id;
            }

            if (state.editingEngagementIndex !== null) {
                // Edit mode - update existing engagement
                const eng = state.engagements[state.editingEngagementIndex];
                if (eng) {
                    eng.name = name;
                    eng.description = description || null;
                    eng.startDate = startDate || eng.startDate;
                    eng.contact = contactName || null;
                    eng.contactId = contactId || null;
                    eng.tagIds = [...state.selectedOppTagIds];
                    // Don't change status, comments, archived, createdAt
                }
            } else {
                // Create mode - add new engagement
                const newEngagement = {
                    id: generateId(),
                    name: name,
                    description: description || null,
                    startDate: startDate || getTodayDate(),
                    contact: contactName || null,  // Keep text for display
                    contactId: contactId || null,  // Link to person
                    tagIds: [...state.selectedOppTagIds],
                    status: 'requested',  // Default status
                    comments: [],
                    archived: false,
                    createdAt: new Date().toISOString()
                };
                state.engagements.push(newEngagement);
            }

            closeEngagementModal();
            renderEngagements();
            renderPeople();  // Refresh people list if new person was created

            // Update side panel if open and editing the same engagement
            if (state.sidePanelOpen && state.selectedEngagementIndex === state.editingEngagementIndex) {
                openSidePanel(state.selectedEngagementIndex);
            }

            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Toggle show archived engagements
        function toggleShowArchived() {
            state.showArchived = showArchivedToggle.checked;
            renderEngagements();
        }

        // Render engagements list
        function renderEngagements() {
            if (state.currentPage !== 'app' || state.currentTab !== 'engagements') return;

            // Clear current list
            engagementList.innerHTML = '';

            // Filter engagements based on archived state
            const filteredEngagements = state.engagements.filter(opp => {
                if (state.showArchived) return true;
                return !opp.archived;
            });

            if (filteredEngagements.length === 0) {
                // Show empty state
                engagementList.classList.add('hidden');
                engagementEmptyState.classList.remove('hidden');
                oppShortcutHintFloating.classList.add('hidden');
            } else {
                // Show engagement list
                engagementList.classList.remove('hidden');
                engagementEmptyState.classList.add('hidden');
                oppShortcutHintFloating.classList.remove('hidden');

                filteredEngagements.forEach((opp) => {
                    // Find original index in state.engagements
                    const index = state.engagements.indexOf(opp);
                    const oppItem = document.createElement('div');
                    oppItem.className = 'engagement-item' + (opp.archived ? ' archived' : '');

                    const statusClass = `status-${opp.status}`;
                    const canClose = opp.status === 'paused';
                    const isClosedOrCancelled = opp.status === 'closed' || opp.status === 'cancelled';

                    // Build action buttons based on status
                    let actionButtons = '';
                    if (isClosedOrCancelled && !opp.archived) {
                        // Only show Archive button for closed/cancelled (not yet archived)
                        actionButtons = `
                            <button class="opp-action-btn archive-btn" onclick="event.stopPropagation(); archiveEngagement(${index})" title="Archive Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="21 8 21 21 3 21 3 8"></polyline>
                                    <rect x="1" y="3" width="22" height="5"></rect>
                                    <line x1="10" y1="12" x2="14" y2="12"></line>
                                </svg>
                            </button>
                        `;
                    } else if (!opp.archived) {
                        // Show normal action buttons for non-archived, non-closed/cancelled
                        actionButtons = `
                            <button class="opp-action-btn edit-btn" onclick="event.stopPropagation(); openEditEngagement(${index})" title="Edit Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                            <button class="opp-action-btn close-btn" onclick="event.stopPropagation(); closeEngagementAction(${index})" title="${canClose ? 'Close Engagement' : 'Only Paused engagements can be closed'}" ${canClose ? '' : 'disabled'}>
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                            </button>
                            <button class="opp-action-btn cancel-btn" onclick="event.stopPropagation(); openCancelConfirmation(${index})" title="Cancel Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="15" y1="9" x2="9" y2="15"></line>
                                    <line x1="9" y1="9" x2="15" y2="15"></line>
                                </svg>
                            </button>
                            <button class="opp-action-btn delete-btn" onclick="event.stopPropagation(); openDeleteConfirmation(${index})" title="Delete Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                    <line x1="10" y1="11" x2="10" y2="17"></line>
                                    <line x1="14" y1="11" x2="14" y2="17"></line>
                                </svg>
                            </button>
                        `;
                    }
                    // No buttons for archived engagements

                    // Format tags for engagement
                    let oppTagsHtml = '';
                    if (opp.tagIds && opp.tagIds.length > 0) {
                        const tagPills = opp.tagIds.map(tagId => {
                            const tag = getTagById(tagId);
                            if (tag) {
                                return `<span class="tag-pill" style="background-color: ${tag.color}; color: #fff;">${escapeHtml(tag.name)}</span>`;
                            }
                            return '';
                        }).filter(Boolean).join('');
                        if (tagPills) {
                            oppTagsHtml = `<div class="tags-container">${tagPills}</div>`;
                        }
                    }

                    oppItem.innerHTML = `
                        <div class="engagement-content" onclick="openSidePanel(${index})">
                            <div class="engagement-name">${escapeHtml(opp.name)}</div>
                            ${opp.contact ? `<div class="engagement-contact">${escapeHtml(opp.contact)}</div>` : ''}
                            ${oppTagsHtml}
                        </div>
                        <span class="status-badge ${statusClass}">${capitalizeFirst(opp.status)}</span>
                        <div class="engagement-actions">
                            ${actionButtons}
                        </div>
                    `;
                    engagementList.appendChild(oppItem);
                });
            }
        }

        // Capitalize first letter
        function capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        // Side Panel functions
        function openSidePanel(index) {
            state.selectedEngagementIndex = index;
            state.sidePanelOpen = true;

            const opp = state.engagements[index];

            // Populate panel (use .value for input elements)
            panelEngName.value = opp.name || '';
            panelEngDescription.value = opp.description || '';
            panelEngDate.textContent = opp.startDate ? formatDate(opp.startDate) : 'Not set';
            // Get contact name - either from contactId or legacy contact field
            let contactDisplay = '';
            state.panelContactId = null;  // Track selected contact in panel
            if (opp.contactId) {
                const person = state.people.find(p => p.id === opp.contactId);
                if (person) {
                    contactDisplay = person.name;
                    state.panelContactId = opp.contactId;
                }
            } else if (opp.contact) {
                contactDisplay = opp.contact;
            }
            panelEngContact.value = contactDisplay;

            // Update status badge
            updatePanelStatusBadge(opp.status);

            // Render comments
            renderCommentsInPanel(opp);

            // Show panel
            sidePanel.classList.add('open');
            sidePanelBackdrop.classList.add('open');
        }

        function closeSidePanel() {
            state.sidePanelOpen = false;
            state.selectedEngagementIndex = null;

            sidePanel.classList.remove('open');
            sidePanelBackdrop.classList.remove('open');
        }

        // Update status badge in side panel
        function updatePanelStatusBadge(status) {
            panelEngStatus.textContent = capitalizeFirst(status);
            panelEngStatus.className = `status-badge status-${status}`;
        }

        // Save engagement field from side panel inline edit
        function savePanelEngagementField(field, value) {
            if (state.selectedEngagementIndex === null) return;

            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng) return;

            const trimmedValue = value.trim();

            if (field === 'name') {
                if (!trimmedValue) {
                    // Don't allow empty name, revert
                    panelEngName.value = eng.name || '';
                    return;
                }
                if (eng.name !== trimmedValue) {
                    eng.name = trimmedValue;
                    renderEngagements();
                    saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
                }
            } else if (field === 'description') {
                const newValue = trimmedValue || null;
                if (eng.description !== newValue) {
                    eng.description = newValue;
                    saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
                }
            }
        }

        // Panel contact autocomplete functions
        function openPanelContactDropdown() {
            state.panelContactDropdownOpen = true;
            filterPanelContacts(panelEngContact.value);
            panelContactDropdown.classList.add('open');
        }

        function closePanelContactDropdown() {
            state.panelContactDropdownOpen = false;
            panelContactDropdown.classList.remove('open');
        }

        function filterPanelContacts(query) {
            const q = query.toLowerCase();
            const matches = state.people.filter(p =>
                p.name.toLowerCase().includes(q)
            );

            panelContactDropdown.innerHTML = '';

            if (matches.length === 0 && !query.trim()) {
                panelContactDropdown.innerHTML = '<div class="panel-contact-item" style="color: #6C757D;">No contacts available</div>';
                return;
            }

            if (matches.length === 0 && query.trim()) {
                panelContactDropdown.innerHTML = '<div class="panel-contact-item" style="color: #6C757D;">No matching contacts</div>';
                return;
            }

            matches.forEach(person => {
                const item = document.createElement('div');
                item.className = 'panel-contact-item';
                item.textContent = person.name;
                item.onclick = () => selectPanelContact(person);
                panelContactDropdown.appendChild(item);
            });
        }

        function selectPanelContact(person) {
            if (state.selectedEngagementIndex === null) return;

            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng) return;

            eng.contactId = person.id;
            eng.contact = person.name;
            state.panelContactId = person.id;
            panelEngContact.value = person.name;

            closePanelContactDropdown();
            renderEngagements();
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        function handlePanelContactBlur(event) {
            // Delay to allow click on dropdown item
            setTimeout(() => {
                if (state.panelContactDropdownOpen) {
                    closePanelContactDropdown();

                    // If value changed but no selection made, save as text contact
                    if (state.selectedEngagementIndex !== null) {
                        const eng = state.engagements[state.selectedEngagementIndex];
                        if (eng) {
                            const newContact = panelEngContact.value.trim();
                            if (newContact !== eng.contact) {
                                eng.contact = newContact || null;
                                eng.contactId = state.panelContactId;  // Keep existing contactId
                                renderEngagements();
                                saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
                            }
                        }
                    }
                }
            }, 200);
        }

        // Archive engagement (for closed/cancelled engagements)
        function archiveEngagement(index) {
            const opp = state.engagements[index];
            if (opp.status !== 'closed' && opp.status !== 'cancelled') return;

            opp.archived = true;

            // Close side panel if this engagement was open
            if (state.sidePanelOpen && state.selectedEngagementIndex === index) {
                closeSidePanel();
            }

            // Re-render engagements list
            renderEngagements();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Close engagement action (set status to Closed)
        function closeEngagementAction(index) {
            const opp = state.engagements[index];
            if (opp.status !== 'paused') return; // Only paused can be closed

            opp.status = 'closed';
            renderEngagements();

            // Also update side panel if open
            if (state.sidePanelOpen && state.selectedEngagementIndex === index) {
                updatePanelStatusBadge('closed');
            }
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Open delete confirmation modal
        function openDeleteConfirmation(index) {
            state.deleteEngagementIndex = index;
            state.confirmModalOpen = true;

            const opp = state.engagements[index];
            confirmMessage.textContent = `Are you sure you want to delete "${opp.name}"? This action cannot be undone.`;

            confirmModal.classList.remove('hidden');
        }

        // Close confirmation modal
        function closeConfirmModal() {
            confirmModal.classList.add('hidden');
            state.confirmModalOpen = false;
            state.deleteEngagementIndex = null;
        }

        // Confirm and execute engagement deletion
        function confirmDeleteEngagement() {
            if (state.deleteEngagementIndex === null) return;

            const oppId = state.engagements[state.deleteEngagementIndex].id;

            // Remove engagement link from all associated todos
            state.todos.forEach(todo => {
                if (todo.engagementId === oppId) {
                    todo.engagementId = null;
                }
            });

            // Remove the engagement
            state.engagements.splice(state.deleteEngagementIndex, 1);

            // Close side panel if the deleted engagement was open
            if (state.sidePanelOpen && state.selectedEngagementIndex === state.deleteEngagementIndex) {
                closeSidePanel();
            } else if (state.sidePanelOpen && state.selectedEngagementIndex > state.deleteEngagementIndex) {
                // Adjust index if needed
                state.selectedEngagementIndex--;
            }

            // Close confirmation modal
            closeConfirmModal();

            // Re-render both lists
            renderEngagements();
            renderTodos();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // =============================================
        // Cancel Engagement Functions
        // =============================================

        // Open cancel confirmation modal
        function openCancelConfirmation(index) {
            state.cancelEngagementIndex = index;
            state.cancelModalOpen = true;

            const opp = state.engagements[index];
            cancelOppName.textContent = `"${opp.name}"`;
            cancelReason.value = '';

            cancelModal.classList.remove('hidden');
            setTimeout(() => cancelReason.focus(), 100);
        }

        // Close cancel modal
        function closeCancelModal() {
            cancelModal.classList.add('hidden');
            state.cancelModalOpen = false;
            state.cancelEngagementIndex = null;
            cancelReason.value = '';
        }

        // Confirm and execute engagement cancellation
        function confirmCancelEngagement() {
            if (state.cancelEngagementIndex === null) return;

            const reason = cancelReason.value.trim();
            if (!reason) {
                cancelReason.focus();
                return;
            }

            const opp = state.engagements[state.cancelEngagementIndex];

            // Initialize comments array if not exists (for backwards compatibility)
            if (!opp.comments) {
                opp.comments = [];
            }

            // Add cancellation comment
            opp.comments.push({
                text: reason,
                timestamp: new Date().toISOString(),
                type: 'cancellation'
            });

            // Set status to cancelled
            opp.status = 'cancelled';

            // Update side panel if this engagement is open
            if (state.sidePanelOpen && state.selectedEngagementIndex === state.cancelEngagementIndex) {
                updatePanelStatusBadge('cancelled');
                renderCommentsInPanel(opp);
            }

            // Close cancel modal
            closeCancelModal();

            // Re-render engagements list
            renderEngagements();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Format datetime for display
        function formatDateTime(isoString) {
            const date = new Date(isoString);
            const options = {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            };
            return date.toLocaleString('en-US', options);
        }

        // Render comments in side panel
        function renderCommentsInPanel(opp) {
            // Initialize comments array if not exists
            const comments = opp.comments || [];

            if (comments.length === 0) {
                panelComments.innerHTML = '<p class="no-comments">No comments yet</p>';
                return;
            }

            panelComments.innerHTML = comments.map((comment, index) => {
                const isCancellation = comment.type === 'cancellation';
                const badge = isCancellation ? '<span class="comment-badge cancellation">Cancellation</span>' : '';
                return `
                    <div class="comment-item ${isCancellation ? 'cancellation' : ''}">
                        <div class="comment-header">
                            <div class="comment-timestamp">${formatDateTime(comment.timestamp)}${badge}</div>
                            <button class="comment-delete-btn" onclick="deleteComment(${index})" title="Delete comment">&times;</button>
                        </div>
                        <div class="comment-text">${escapeHtml(comment.text)}</div>
                    </div>
                `;
            }).join('');
        }

        // Add a new comment to the current engagement
        function addComment() {
            if (state.selectedEngagementIndex === null) return;

            const text = commentInput.value.trim();
            if (!text) return;

            const opp = state.engagements[state.selectedEngagementIndex];

            // Initialize comments array if not exists
            if (!opp.comments) {
                opp.comments = [];
            }

            // Add new standard comment
            opp.comments.push({
                text: text,
                timestamp: new Date().toISOString(),
                type: 'standard'
            });

            // Clear input
            commentInput.value = '';

            // Re-render comments
            renderCommentsInPanel(opp);
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Delete a comment from the current engagement
        function deleteComment(commentIndex) {
            if (state.selectedEngagementIndex === null) return;

            const opp = state.engagements[state.selectedEngagementIndex];
            if (!opp || !opp.comments || commentIndex < 0 || commentIndex >= opp.comments.length) return;

            // Remove the comment
            opp.comments.splice(commentIndex, 1);

            // Re-render comments
            renderCommentsInPanel(opp);
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // =============================================
        // Autocomplete Functions for Todo-Engagement Linking
        // =============================================

        // Filter engagements based on search query
        function filterEngagements(query) {
            if (!query || query.trim() === '') return [];
            const lowerQuery = query.toLowerCase().trim();
            return state.engagements.filter(opp =>
                opp.name.toLowerCase().includes(lowerQuery)
            );
        }

        // Render autocomplete dropdown
        function renderAutocompleteDropdown(query) {
            const matches = filterEngagements(query);
            engagementDropdown.innerHTML = '';

            if (matches.length > 0) {
                matches.forEach((opp, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.setAttribute('data-index', index);
                    item.setAttribute('data-id', opp.id);
                    item.innerHTML = `
                        <div class="autocomplete-item-name">${escapeHtml(opp.name)}</div>
                        ${opp.contact ? `<div class="autocomplete-item-contact">${escapeHtml(opp.contact)}</div>` : ''}
                    `;
                    item.onclick = () => selectEngagement(opp);
                    engagementDropdown.appendChild(item);
                });
            } else if (query && query.trim() !== '') {
                // Show hint to create new
                const hint = document.createElement('div');
                hint.className = 'autocomplete-empty';
                hint.textContent = 'No matches found';
                engagementDropdown.appendChild(hint);

                const createHint = document.createElement('div');
                createHint.className = 'autocomplete-create-hint';
                createHint.textContent = 'Press Enter to create new engagement';
                engagementDropdown.appendChild(createHint);
            }

            // Update highlight
            state.autocompleteHighlightIndex = -1;
            updateAutocompleteHighlight();
        }

        // Update autocomplete item highlight
        function updateAutocompleteHighlight() {
            const items = engagementDropdown.querySelectorAll('.autocomplete-item');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.autocompleteHighlightIndex);
            });
        }

        // Select an engagement from dropdown
        function selectEngagement(opp) {
            state.selectedEngagementId = opp.id;
            state.pendingEngagement = null;
            todoEngagementInput.value = opp.name;
            todoEngagementClear.classList.add('visible');
            closeAutocompleteDropdown();
            closeInlineOppForm();
        }

        // Clear engagement selection
        function clearEngagementSelection() {
            state.selectedEngagementId = null;
            state.pendingEngagement = null;
            todoEngagementInput.value = '';
            todoEngagementClear.classList.remove('visible');
            closeAutocompleteDropdown();
            closeInlineOppForm();
        }

        // Open autocomplete dropdown
        function openAutocompleteDropdown() {
            state.autocompleteOpen = true;
            engagementDropdown.classList.add('open');
        }

        // Close autocomplete dropdown
        function closeAutocompleteDropdown() {
            state.autocompleteOpen = false;
            state.autocompleteHighlightIndex = -1;
            engagementDropdown.classList.remove('open');
        }

        // Update Todo Save button state based on inline forms
        function updateTodoSaveButtonState() {
            const isInlineFormOpen = state.inlineEngFormOpen || state.inlineEngPersonFormOpen;

            if (isInlineFormOpen) {
                todoSaveBtn.disabled = true;
                todoSaveBtn.classList.add('btn-disabled');
                todoSaveWrapper.setAttribute('data-tooltip', 'Complete or cancel the inline form first');
            } else {
                todoSaveBtn.disabled = false;
                todoSaveBtn.classList.remove('btn-disabled');
                todoSaveWrapper.removeAttribute('data-tooltip');
            }
        }

        // Toggle tabindex on focusable elements inside a form container
        // When enabled=false, sets tabindex=-1 to remove from tab order
        // When enabled=true, removes tabindex to restore default tab behavior
        function setFormTabIndex(formElement, enabled, excludeSelector = null) {
            const focusables = formElement.querySelectorAll('input, button, select, textarea, [tabindex]');
            focusables.forEach(el => {
                // Skip elements that match the exclude selector
                if (excludeSelector && el.closest(excludeSelector)) return;

                if (enabled) {
                    el.removeAttribute('tabindex');
                } else {
                    el.setAttribute('tabindex', '-1');
                }
            });
        }

        // Open inline engagement form with slide animation
        function openInlineEngForm(name) {
            state.inlineEngFormOpen = true;
            updateTodoSaveButtonState();
            inlineEngName.value = name;
            inlineEngDescription.value = '';
            inlineEngStartDate.value = getTodayDate();
            inlineEngContact.value = '';
            inlineEngForm.classList.add('open');
            closeAutocompleteDropdown();

            // Enable tab navigation for opp form elements, but exclude nested person form
            setFormTabIndex(inlineEngForm, true, '#inline-eng-person-form');

            // Focus on description after animation
            setTimeout(() => inlineEngDescription.focus(), 350);
        }

        // Close inline engagement form
        function closeInlineOppForm() {
            state.inlineEngFormOpen = false;
            inlineEngForm.classList.remove('open');
            updateTodoSaveButtonState();

            // Disable tab navigation for all elements inside opp form
            setFormTabIndex(inlineEngForm, false);
        }

        // Cancel inline engagement creation
        function cancelInlineEngagement() {
            state.pendingEngagement = null;
            todoEngagementInput.value = '';
            todoEngagementClear.classList.remove('visible');
            closeInlineOppForm();
        }

        // Confirm inline engagement creation
        function confirmInlineEngagement() {
            const name = inlineEngName.value.trim();
            if (!name) return;

            // Store pending engagement data (will be created when todo is saved)
            state.pendingEngagement = {
                name: name,
                description: inlineEngDescription.value.trim(),
                startDate: inlineEngStartDate.value,
                contact: inlineEngContact.value.trim(),
                // Include person data for the contact
                contactPersonId: state.selectedInlineOppPersonId,
                pendingPerson: state.pendingInlineOppPerson
            };

            // Update UI to show it's selected
            todoEngagementInput.value = name + ' (new)';
            todoEngagementClear.classList.add('visible');
            closeInlineOppForm();
        }

        // Handle autocomplete input events
        todoEngagementInput.addEventListener('input', (e) => {
            const query = e.target.value;

            // Reset selection when typing
            state.selectedEngagementId = null;
            state.pendingEngagement = null;

            // Show/hide clear button
            todoEngagementClear.classList.toggle('visible', query.length > 0);

            // Close inline form if open
            if (state.inlineEngFormOpen) {
                closeInlineOppForm();
            }

            // Render and open dropdown
            if (query.trim() !== '') {
                renderAutocompleteDropdown(query);
                openAutocompleteDropdown();
                // Auto-highlight first match when typing
                const matches = filterEngagements(query);
                if (matches.length > 0) {
                    state.autocompleteHighlightIndex = 0;
                    updateAutocompleteHighlight();
                }
            } else {
                closeAutocompleteDropdown();
            }
        });

        // Handle autocomplete keyboard navigation
        todoEngagementInput.addEventListener('keydown', (e) => {
            const items = engagementDropdown.querySelectorAll('.autocomplete-item');
            const matches = filterEngagements(todoEngagementInput.value);
            const query = todoEngagementInput.value.trim();

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.autocompleteOpen && items.length > 0) {
                    state.autocompleteHighlightIndex = Math.min(state.autocompleteHighlightIndex + 1, items.length - 1);
                    updateAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.autocompleteOpen && items.length > 0) {
                    state.autocompleteHighlightIndex = Math.max(state.autocompleteHighlightIndex - 1, 0);
                    updateAutocompleteHighlight();
                }
            } else if (e.key === 'Tab' && !e.shiftKey) {
                // Tab behavior (forward only, let Shift+Tab work naturally):
                // 1. If matches exist, select first/highlighted and move to Tags
                // 2. If no matches but text entered, open inline creation
                // 3. If no text, natural tab
                if (matches.length > 0) {
                    e.preventDefault();
                    const indexToSelect = state.autocompleteHighlightIndex >= 0 ? state.autocompleteHighlightIndex : 0;
                    selectEngagement(matches[indexToSelect]);
                    todoTagInput.focus();
                } else if (query && !state.inlineEngFormOpen) {
                    e.preventDefault();
                    openInlineEngForm(query);
                }
                // If no text entered, let Tab naturally move to next control
            } else if (e.key === 'Enter') {
                e.preventDefault();

                // Check for exact match (case-insensitive)
                const exactMatch = matches.find(opp => opp.name.toLowerCase() === query.toLowerCase());

                if (state.autocompleteHighlightIndex >= 0 && matches.length > 0) {
                    // Select highlighted item
                    selectEngagement(matches[state.autocompleteHighlightIndex]);
                } else if (exactMatch) {
                    // Exact match - select it and move to next field
                    selectEngagement(exactMatch);
                    todoTagInput.focus();
                } else if (query && !state.inlineEngFormOpen) {
                    // Partial match or no matches - open inline creation form
                    openInlineEngForm(query);
                }
            } else if (e.key === 'Escape') {
                if (state.autocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeAutocompleteDropdown();
                }
            }
        });

        // Handle inline engagement description Enter key - move to Contact field
        inlineEngDescription.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                // Move focus to Contact field and scroll
                inlineEngContact.focus();
                setTimeout(() => {
                    inlineEngContact.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        });

        // Handle inline engagement name Enter key - move to Description field
        inlineEngName.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                inlineEngDescription.focus();
            }
        });

        // Handle inline engagement start date Enter key - move to Contact field
        inlineEngStartDate.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                inlineEngContact.focus();
                setTimeout(() => {
                    inlineEngContact.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        });

        // =============================================
        // People Management Functions
        // =============================================

        // Render people list
        function renderPeople() {
            peopleList.innerHTML = '';

            if (state.people.length === 0) {
                // Show empty state
                peopleList.classList.add('hidden');
                peopleEmptyState.classList.remove('hidden');
                peopleShortcutHintFloating.classList.add('hidden');
                rolesSection.classList.add('hidden');
            } else {
                // Show people list
                peopleList.classList.remove('hidden');
                peopleEmptyState.classList.add('hidden');
                peopleShortcutHintFloating.classList.remove('hidden');

                state.people.forEach((person, index) => {
                    const personItem = document.createElement('div');
                    personItem.className = 'person-item';

                    const roleName = person.roleId ? getRoleName(person.roleId) : '';

                    personItem.innerHTML = `
                        <div class="person-info">
                            <div class="person-name">${escapeHtml(person.name)}</div>
                            ${roleName ? `<span class="person-role-badge">${escapeHtml(roleName)}</span>` : ''}
                        </div>
                        <div class="person-actions">
                            <button class="action-btn" onclick="event.stopPropagation(); openPersonModal(${index})" title="Edit">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                            <button class="action-btn action-btn-danger" onclick="event.stopPropagation(); openDeletePersonModal(${index})" title="Delete">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                            </button>
                        </div>
                    `;

                    peopleList.appendChild(personItem);
                });

                // Show roles section if there are roles
                if (state.roles.length > 0) {
                    rolesSection.classList.remove('hidden');
                    renderRoles();
                } else {
                    rolesSection.classList.add('hidden');
                }
            }

            saveData();
        }

        // Render roles list
        function renderRoles() {
            rolesList.innerHTML = '';
            state.roles.forEach(role => {
                const roleTag = document.createElement('span');
                roleTag.className = 'role-tag';
                roleTag.textContent = role.name;
                rolesList.appendChild(roleTag);
            });
        }

        // Render tags list in Settings
        function renderTags() {
            tagsList.innerHTML = '';

            if (state.tags.length === 0) {
                // Show empty state
                tagsList.classList.add('hidden');
                tagsEmptyState.classList.remove('hidden');
                tagsShortcutHintFloating.classList.add('hidden');
            } else {
                // Show tags list
                tagsList.classList.remove('hidden');
                tagsEmptyState.classList.add('hidden');
                tagsShortcutHintFloating.classList.remove('hidden');

                state.tags.forEach((tag, index) => {
                    const tagItem = document.createElement('div');
                    tagItem.className = 'tag-item';

                    tagItem.innerHTML = `
                        <div class="tag-info">
                            <div class="tag-color-preview" style="background-color: ${tag.color}"></div>
                            <div class="tag-name">${escapeHtml(tag.name)}</div>
                        </div>
                        <div class="tag-actions">
                            <button class="action-btn" onclick="event.stopPropagation(); openTagModal(${index})" title="Edit">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                            <button class="action-btn action-btn-danger" onclick="event.stopPropagation(); deleteTag(${index})" title="Delete">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                            </button>
                        </div>
                    `;

                    tagsList.appendChild(tagItem);
                });
            }

            saveData();
        }

        // Open tag modal
        function openTagModal(tagIndex = null) {
            state.tagModalOpen = true;
            state.editingTagIndex = tagIndex;

            if (tagIndex !== null) {
                // Edit mode
                const tag = state.tags[tagIndex];
                tagModalTitle.textContent = 'Edit Tag';
                tagNameInput.value = tag.name;
                tagColorInput.value = tag.color;
                updateColorPreview(tag.color);
            } else {
                // Create mode
                tagModalTitle.textContent = 'New Tag';
                tagNameInput.value = '';
                tagColorInput.value = '#F59E0B';
                updateColorPreview('#F59E0B');
            }

            tagModal.classList.remove('hidden');
            setTimeout(() => tagNameInput.focus(), 100);
        }

        // Close tag modal
        function closeTagModal() {
            state.tagModalOpen = false;
            state.editingTagIndex = null;
            tagModal.classList.add('hidden');
            tagForm.reset();
        }

        // Update color preview
        function updateColorPreview(color) {
            tagColorPreview.style.backgroundColor = color;
            tagColorValue.textContent = color.toUpperCase();
        }

        // Save tag
        function saveTag(e) {
            e.preventDefault();

            const name = tagNameInput.value.trim();
            if (!name) return;

            const color = tagColorInput.value;

            if (state.editingTagIndex !== null) {
                // Update existing tag
                state.tags[state.editingTagIndex].name = name;
                state.tags[state.editingTagIndex].color = color;
            } else {
                // Create new tag
                const newTag = {
                    id: generateId(),
                    name: name,
                    color: color,
                    createdAt: new Date().toISOString()
                };
                state.tags.push(newTag);
            }

            closeTagModal();
            renderTags();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Delete tag
        function deleteTag(index) {
            const tag = state.tags[index];

            // Remove tag from all todos and engagements
            state.todos.forEach(todo => {
                if (todo.tagIds) {
                    todo.tagIds = todo.tagIds.filter(id => id !== tag.id);
                }
            });
            state.engagements.forEach(opp => {
                if (opp.tagIds) {
                    opp.tagIds = opp.tagIds.filter(id => id !== tag.id);
                }
            });

            // Remove tag from array
            state.tags.splice(index, 1);
            renderTags();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Get tag by ID
        function getTagById(tagId) {
            return state.tags.find(t => t.id === tagId);
        }

        // Get or create tag by name (for inline creation)
        function getOrCreateTag(tagName) {
            if (!tagName || tagName.trim() === '') return null;
            const trimmedName = tagName.trim();
            const existingTag = state.tags.find(t => t.name.toLowerCase() === trimmedName.toLowerCase());
            if (existingTag) return existingTag.id;

            // Create new tag with default color
            const defaultColors = ['#F59E0B', '#10B981', '#3B82F6', '#8B5CF6', '#EC4899', '#EF4444'];
            const colorIndex = state.tags.length % defaultColors.length;
            const newTag = {
                id: generateId(),
                name: trimmedName,
                color: defaultColors[colorIndex],
                createdAt: new Date().toISOString()
            };
            state.tags.push(newTag);
            return newTag.id;
        }

        // ==================== Tag Input Functions ====================

        // Render selected tags for Todo form
        function renderTodoSelectedTags() {
            todoSelectedTags.innerHTML = '';
            state.selectedTodoTagIds.forEach(tagId => {
                const tag = getTagById(tagId);
                if (tag) {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'selected-tag';
                    tagEl.style.backgroundColor = tag.color;
                    tagEl.innerHTML = `
                        ${escapeHtml(tag.name)}
                        <button type="button" class="remove-tag" onclick="removeTodoTag('${tagId}')"></button>
                    `;
                    todoSelectedTags.appendChild(tagEl);
                }
            });
        }

        // Render selected tags for Engagement form
        function renderOppSelectedTags() {
            engSelectedTags.innerHTML = '';
            state.selectedOppTagIds.forEach(tagId => {
                const tag = getTagById(tagId);
                if (tag) {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'selected-tag';
                    tagEl.style.backgroundColor = tag.color;
                    tagEl.innerHTML = `
                        ${escapeHtml(tag.name)}
                        <button type="button" class="remove-tag" onclick="removeOppTag('${tagId}')"></button>
                    `;
                    engSelectedTags.appendChild(tagEl);
                }
            });
        }

        // Remove tag from Todo
        function removeTodoTag(tagId) {
            state.selectedTodoTagIds = state.selectedTodoTagIds.filter(id => id !== tagId);
            renderTodoSelectedTags();
        }

        // Remove tag from Engagement
        function removeOppTag(tagId) {
            state.selectedOppTagIds = state.selectedOppTagIds.filter(id => id !== tagId);
            renderOppSelectedTags();
        }

        // Render tag dropdown for Todo
        function renderTodoTagDropdown(filter = '') {
            todoTagDropdown.innerHTML = '';
            const filterLower = filter.toLowerCase();

            // Filter tags not already selected and matching the filter
            const availableTags = state.tags.filter(tag =>
                !state.selectedTodoTagIds.includes(tag.id) &&
                tag.name.toLowerCase().includes(filterLower)
            );

            availableTags.forEach((tag, index) => {
                const item = document.createElement('div');
                item.className = 'tag-dropdown-item' + (index === state.todoTagHighlightIndex ? ' highlighted' : '');
                item.innerHTML = `
                    <span class="tag-color-dot" style="background-color: ${tag.color}"></span>
                    ${escapeHtml(tag.name)}
                `;
                item.onclick = () => selectTodoTag(tag.id);
                todoTagDropdown.appendChild(item);
            });

            // Show "create new" option if filter doesn't match existing tag exactly
            if (filter.trim() && !state.tags.some(t => t.name.toLowerCase() === filterLower)) {
                const createItem = document.createElement('div');
                createItem.className = 'tag-dropdown-item create-new' + (availableTags.length === state.todoTagHighlightIndex ? ' highlighted' : '');
                createItem.innerHTML = `
                    <span class="tag-color-dot"></span>
                    Create "${escapeHtml(filter.trim())}"
                `;
                createItem.onclick = () => createAndSelectTodoTag(filter.trim());
                todoTagDropdown.appendChild(createItem);
            }

            if (todoTagDropdown.children.length > 0) {
                todoTagDropdown.classList.add('open');
                state.todoTagDropdownOpen = true;
            } else {
                todoTagDropdown.classList.remove('open');
                state.todoTagDropdownOpen = false;
            }
        }

        // Render tag dropdown for Engagement
        function renderOppTagDropdown(filter = '') {
            engTagDropdown.innerHTML = '';
            const filterLower = filter.toLowerCase();

            // Filter tags not already selected and matching the filter
            const availableTags = state.tags.filter(tag =>
                !state.selectedOppTagIds.includes(tag.id) &&
                tag.name.toLowerCase().includes(filterLower)
            );

            availableTags.forEach((tag, index) => {
                const item = document.createElement('div');
                item.className = 'tag-dropdown-item' + (index === state.oppTagHighlightIndex ? ' highlighted' : '');
                item.innerHTML = `
                    <span class="tag-color-dot" style="background-color: ${tag.color}"></span>
                    ${escapeHtml(tag.name)}
                `;
                item.onclick = () => selectOppTag(tag.id);
                engTagDropdown.appendChild(item);
            });

            // Show "create new" option if filter doesn't match existing tag exactly
            if (filter.trim() && !state.tags.some(t => t.name.toLowerCase() === filterLower)) {
                const createItem = document.createElement('div');
                createItem.className = 'tag-dropdown-item create-new' + (availableTags.length === state.oppTagHighlightIndex ? ' highlighted' : '');
                createItem.innerHTML = `
                    <span class="tag-color-dot"></span>
                    Create "${escapeHtml(filter.trim())}"
                `;
                createItem.onclick = () => createAndSelectOppTag(filter.trim());
                engTagDropdown.appendChild(createItem);
            }

            if (engTagDropdown.children.length > 0) {
                engTagDropdown.classList.add('open');
                state.engTagDropdownOpen = true;
            } else {
                engTagDropdown.classList.remove('open');
                state.engTagDropdownOpen = false;
            }
        }

        // Select existing tag for Todo
        function selectTodoTag(tagId) {
            if (!state.selectedTodoTagIds.includes(tagId)) {
                state.selectedTodoTagIds.push(tagId);
                renderTodoSelectedTags();
            }
            todoTagInput.value = '';
            closeTodoTagDropdown();
        }

        // Select existing tag for Engagement
        function selectOppTag(tagId) {
            if (!state.selectedOppTagIds.includes(tagId)) {
                state.selectedOppTagIds.push(tagId);
                renderOppSelectedTags();
            }
            engTagInput.value = '';
            closeOppTagDropdown();
        }

        // Create new tag and select it for Todo
        function createAndSelectTodoTag(name) {
            const tagId = getOrCreateTag(name);
            if (tagId) {
                selectTodoTag(tagId);
            }
        }

        // Create new tag and select it for Engagement
        function createAndSelectOppTag(name) {
            const tagId = getOrCreateTag(name);
            if (tagId) {
                selectOppTag(tagId);
            }
        }

        // Close Todo tag dropdown
        function closeTodoTagDropdown() {
            todoTagDropdown.classList.remove('open');
            state.todoTagDropdownOpen = false;
            state.todoTagHighlightIndex = -1;
        }

        // Close Engagement tag dropdown
        function closeOppTagDropdown() {
            engTagDropdown.classList.remove('open');
            state.engTagDropdownOpen = false;
            state.oppTagHighlightIndex = -1;
        }

        // Setup tag input event listeners
        function setupTagInputListeners() {
            // Todo tag input
            todoTagInput.addEventListener('input', (e) => {
                renderTodoTagDropdown(e.target.value);
                // Auto-highlight first item when typing
                const items = todoTagDropdown.querySelectorAll('.tag-dropdown-item');
                if (items.length > 0) {
                    state.todoTagHighlightIndex = 0;
                    renderTodoTagDropdown(e.target.value);
                } else {
                    state.todoTagHighlightIndex = -1;
                }
            });

            todoTagInput.addEventListener('focus', () => {
                renderTodoTagDropdown(todoTagInput.value);
            });

            todoTagInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    e.stopPropagation();
                    closeTodoTagDropdown();
                    todoTagInput.value = '';
                    return;
                }

                if (e.key === 'Tab' && !e.shiftKey) {
                    // Tab (forward only) with dropdown open: select first/highlighted item and move on
                    const items = todoTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (items.length > 0) {
                        e.preventDefault();
                        const indexToSelect = state.todoTagHighlightIndex >= 0 ? state.todoTagHighlightIndex : 0;
                        items[indexToSelect].click();
                    } else if (todoTagInput.value.trim()) {
                        // If text entered but no matches, create tag and move on
                        e.preventDefault();
                        createAndSelectTodoTag(todoTagInput.value.trim());
                    }
                    // If nothing, let Tab naturally move to next control
                    return;
                }

                if (e.key === 'Enter') {
                    e.preventDefault();
                    const items = todoTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (items.length > 0) {
                        const indexToSelect = state.todoTagHighlightIndex >= 0 ? state.todoTagHighlightIndex : 0;
                        items[indexToSelect].click();
                    } else if (todoTagInput.value.trim()) {
                        createAndSelectTodoTag(todoTagInput.value.trim());
                    }
                    return;
                }

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const items = todoTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (items.length > 0) {
                        state.todoTagHighlightIndex = Math.min(state.todoTagHighlightIndex + 1, items.length - 1);
                        renderTodoTagDropdown(todoTagInput.value);
                    }
                    return;
                }

                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (state.todoTagHighlightIndex > 0) {
                        state.todoTagHighlightIndex--;
                        renderTodoTagDropdown(todoTagInput.value);
                    }
                    return;
                }
            });

            // Engagement tag input
            engTagInput.addEventListener('input', (e) => {
                renderOppTagDropdown(e.target.value);
                // Auto-highlight first item when typing
                const items = engTagDropdown.querySelectorAll('.tag-dropdown-item');
                if (items.length > 0) {
                    state.oppTagHighlightIndex = 0;
                    renderOppTagDropdown(e.target.value);
                } else {
                    state.oppTagHighlightIndex = -1;
                }
            });

            engTagInput.addEventListener('focus', () => {
                renderOppTagDropdown(engTagInput.value);
            });

            engTagInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    e.stopPropagation();
                    closeOppTagDropdown();
                    engTagInput.value = '';
                    return;
                }

                if (e.key === 'Tab' && !e.shiftKey) {
                    // Tab (forward only) with dropdown open: select first/highlighted item and move on
                    const items = engTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (items.length > 0) {
                        e.preventDefault();
                        const indexToSelect = state.oppTagHighlightIndex >= 0 ? state.oppTagHighlightIndex : 0;
                        items[indexToSelect].click();
                    } else if (engTagInput.value.trim()) {
                        // If text entered but no matches, create tag and move on
                        e.preventDefault();
                        createAndSelectOppTag(engTagInput.value.trim());
                    }
                    // If nothing, let Tab naturally move to next control
                    return;
                }

                if (e.key === 'Enter') {
                    e.preventDefault();
                    const items = engTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (items.length > 0) {
                        const indexToSelect = state.oppTagHighlightIndex >= 0 ? state.oppTagHighlightIndex : 0;
                        items[indexToSelect].click();
                    } else if (engTagInput.value.trim()) {
                        createAndSelectOppTag(engTagInput.value.trim());
                    }
                    return;
                }

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const items = engTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (items.length > 0) {
                        state.oppTagHighlightIndex = Math.min(state.oppTagHighlightIndex + 1, items.length - 1);
                        renderOppTagDropdown(engTagInput.value);
                    }
                    return;
                }

                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (state.oppTagHighlightIndex > 0) {
                        state.oppTagHighlightIndex--;
                        renderOppTagDropdown(engTagInput.value);
                    }
                    return;
                }
            });

            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#todo-tag-container')) {
                    closeTodoTagDropdown();
                }
                if (!e.target.closest('#opp-tag-container')) {
                    closeOppTagDropdown();
                }
            });
        }

        // Initialize tag input listeners
        setupTagInputListeners();

        // ==================== End Tag Input Functions ====================

        // Get role name by ID
        function getRoleName(roleId) {
            const role = state.roles.find(r => r.id === roleId);
            return role ? role.name : '';
        }

        // Get or create role by name
        function getOrCreateRole(roleName) {
            if (!roleName || roleName.trim() === '') return null;
            const trimmedName = roleName.trim();
            const existingRole = state.roles.find(r => r.name.toLowerCase() === trimmedName.toLowerCase());
            if (existingRole) return existingRole.id;

            // Create new role
            const newRole = {
                id: generateId(),
                name: trimmedName
            };
            state.roles.push(newRole);
            return newRole.id;
        }

        // Open person modal
        function openPersonModal(personIndex = null) {
            state.personModalOpen = true;
            state.editingPersonIndex = personIndex;
            state.roleAutocompleteOpen = false;
            state.roleAutocompleteHighlightIndex = -1;

            personRoleInput.value = '';
            personRoleClear.classList.remove('visible');
            roleDropdown.classList.remove('open');

            if (personIndex !== null) {
                // Edit mode
                const person = state.people[personIndex];
                personModalTitle.textContent = 'Edit Person';
                personNameInput.value = person.name;
                if (person.roleId) {
                    personRoleInput.value = getRoleName(person.roleId);
                    personRoleClear.classList.add('visible');
                }
            } else {
                // Create mode
                personModalTitle.textContent = 'New Person';
                personNameInput.value = '';
            }

            personModal.classList.remove('hidden');
            setTimeout(() => personNameInput.focus(), 100);
        }

        // Close person modal
        function closePersonModal() {
            state.personModalOpen = false;
            state.editingPersonIndex = null;
            state.roleAutocompleteOpen = false;
            personModal.classList.add('hidden');
            personForm.reset();
            roleDropdown.classList.remove('open');
        }

        // Save person
        function savePerson(e) {
            e.preventDefault();

            const name = personNameInput.value.trim();
            if (!name) return;

            const roleName = personRoleInput.value.trim();
            const roleId = getOrCreateRole(roleName);

            if (state.editingPersonIndex !== null) {
                // Update existing person
                state.people[state.editingPersonIndex].name = name;
                state.people[state.editingPersonIndex].roleId = roleId;
            } else {
                // Create new person
                const newPerson = {
                    id: generateId(),
                    name: name,
                    roleId: roleId
                };
                state.people.push(newPerson);
            }

            closePersonModal();
            renderPeople();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Open delete person modal
        function openDeletePersonModal(index) {
            state.deletePersonIndex = index;
            const person = state.people[index];
            deletePersonName.textContent = person.name;
            deletePersonModal.classList.remove('hidden');
        }

        // Close delete person modal
        function closeDeletePersonModal() {
            state.deletePersonIndex = null;
            deletePersonModal.classList.add('hidden');
        }

        // Confirm delete person
        function confirmDeletePerson() {
            if (state.deletePersonIndex !== null) {
                const personId = state.people[state.deletePersonIndex].id;

                // Remove person from array
                state.people.splice(state.deletePersonIndex, 1);

                // Update engagements that referenced this person
                state.engagements.forEach(opp => {
                    if (opp.contactId === personId) {
                        opp.contactId = null;
                        opp.contact = ''; // Clear the text contact as well
                    }
                });

                closeDeletePersonModal();
                renderPeople();
                renderEngagements();
                // Auto-save to IndexedDB
                saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
            }
        }

        // Clear person role input
        function clearPersonRole() {
            personRoleInput.value = '';
            personRoleClear.classList.remove('visible');
            roleDropdown.classList.remove('open');
            state.roleAutocompleteOpen = false;
        }

        // Filter roles based on search query
        function filterRoles(query) {
            if (!query || query.trim() === '') return [];
            const lowerQuery = query.toLowerCase().trim();
            return state.roles.filter(role =>
                role.name.toLowerCase().includes(lowerQuery)
            );
        }

        // Render role autocomplete dropdown
        function renderRoleDropdown(query) {
            const matches = filterRoles(query);
            roleDropdown.innerHTML = '';

            if (matches.length > 0) {
                matches.forEach((role, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.setAttribute('data-index', index);
                    item.setAttribute('data-id', role.id);
                    item.innerHTML = `<div class="autocomplete-item-name">${escapeHtml(role.name)}</div>`;
                    item.onclick = () => selectRole(role);
                    roleDropdown.appendChild(item);
                });
            } else if (query && query.trim() !== '') {
                // Show create option
                const createItem = document.createElement('div');
                createItem.className = 'autocomplete-item autocomplete-create';
                createItem.innerHTML = `
                    <div class="autocomplete-item-name">Create "${escapeHtml(query.trim())}"</div>
                `;
                createItem.onclick = () => {
                    personRoleInput.value = query.trim();
                    personRoleClear.classList.add('visible');
                    closeRoleDropdown();
                };
                roleDropdown.appendChild(createItem);
            }

            state.roleAutocompleteHighlightIndex = -1;
            updateRoleAutocompleteHighlight();
        }

        // Update role autocomplete highlight
        function updateRoleAutocompleteHighlight() {
            const items = roleDropdown.querySelectorAll('.autocomplete-item');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.roleAutocompleteHighlightIndex);
            });
        }

        // Select role from autocomplete
        function selectRole(role) {
            personRoleInput.value = role.name;
            personRoleClear.classList.add('visible');
            closeRoleDropdown();
        }

        // Open role dropdown
        function openRoleDropdown() {
            state.roleAutocompleteOpen = true;
            roleDropdown.classList.add('open');
        }

        // Close role dropdown
        function closeRoleDropdown() {
            state.roleAutocompleteOpen = false;
            roleDropdown.classList.remove('open');
            state.roleAutocompleteHighlightIndex = -1;
        }

        // Person role input event handlers
        personRoleInput.addEventListener('input', (e) => {
            const query = e.target.value;

            // Show/hide clear button
            personRoleClear.classList.toggle('visible', query.length > 0);

            // Render and open dropdown
            if (query.trim() !== '') {
                renderRoleDropdown(query);
                openRoleDropdown();
                // Auto-highlight first match when typing
                const matches = filterRoles(query);
                if (matches.length > 0) {
                    state.roleAutocompleteHighlightIndex = 0;
                    updateRoleAutocompleteHighlight();
                }
            } else {
                closeRoleDropdown();
            }
        });

        personRoleInput.addEventListener('focus', () => {
            const query = personRoleInput.value;
            if (query.trim() !== '') {
                renderRoleDropdown(query);
                openRoleDropdown();
            }
        });

        personRoleInput.addEventListener('keydown', (e) => {
            const items = roleDropdown.querySelectorAll('.autocomplete-item');
            const matches = filterRoles(personRoleInput.value);

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.roleAutocompleteOpen && items.length > 0) {
                    state.roleAutocompleteHighlightIndex = Math.min(state.roleAutocompleteHighlightIndex + 1, items.length - 1);
                    updateRoleAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.roleAutocompleteOpen && items.length > 0) {
                    state.roleAutocompleteHighlightIndex = Math.max(state.roleAutocompleteHighlightIndex - 1, 0);
                    updateRoleAutocompleteHighlight();
                }
            } else if (e.key === 'Tab' && !e.shiftKey) {
                // Tab (forward only) with dropdown open: select first/highlighted match and move on
                if (state.roleAutocompleteOpen && matches.length > 0) {
                    e.preventDefault();
                    const indexToSelect = state.roleAutocompleteHighlightIndex >= 0 ? state.roleAutocompleteHighlightIndex : 0;
                    selectRole(matches[indexToSelect]);
                }
                // If no matches, let Tab naturally move to next control
            } else if (e.key === 'Enter') {
                e.preventDefault();
                const query = personRoleInput.value.trim();

                if (state.roleAutocompleteOpen && matches.length > 0) {
                    // Select first/highlighted item
                    const indexToSelect = state.roleAutocompleteHighlightIndex >= 0 ? state.roleAutocompleteHighlightIndex : 0;
                    selectRole(matches[indexToSelect]);
                } else if (query) {
                    // Just accept the typed value
                    personRoleClear.classList.add('visible');
                    closeRoleDropdown();
                }
            } else if (e.key === 'Escape') {
                if (state.roleAutocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeRoleDropdown();
                }
            }
        });

        // =============================================
        // Contact Autocomplete Functions (Engagement Modal)
        // =============================================

        // Filter people based on search query
        function filterPeople(query) {
            if (!query || query.trim() === '') return [];
            const lowerQuery = query.toLowerCase().trim();
            return state.people.filter(person =>
                person.name.toLowerCase().includes(lowerQuery)
            );
        }

        // Render contact autocomplete dropdown
        function renderContactDropdown(query) {
            const matches = filterPeople(query);
            contactDropdown.innerHTML = '';

            if (matches.length > 0) {
                matches.forEach((person, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.setAttribute('data-index', index);
                    item.setAttribute('data-id', person.id);
                    const roleName = person.roleId ? getRoleName(person.roleId) : '';
                    item.innerHTML = `
                        <div class="autocomplete-item-name">${escapeHtml(person.name)}</div>
                        ${roleName ? `<div class="autocomplete-item-contact">${escapeHtml(roleName)}</div>` : ''}
                    `;
                    item.onclick = () => selectContact(person);
                    contactDropdown.appendChild(item);
                });
            } else if (query && query.trim() !== '') {
                // Show create option
                const createItem = document.createElement('div');
                createItem.className = 'autocomplete-item autocomplete-create';
                createItem.innerHTML = `
                    <div class="autocomplete-item-name">Create "${escapeHtml(query.trim())}" - press Enter</div>
                `;
                createItem.onclick = () => openInlinePersonForm(query.trim());
                contactDropdown.appendChild(createItem);
            }

            state.contactAutocompleteHighlightIndex = -1;
            updateContactAutocompleteHighlight();
        }

        // Update contact autocomplete highlight
        function updateContactAutocompleteHighlight() {
            const items = contactDropdown.querySelectorAll('.autocomplete-item');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.contactAutocompleteHighlightIndex);
            });
        }

        // Select contact from autocomplete
        function selectContact(person) {
            state.selectedPersonId = person.id;
            state.pendingPerson = null;
            engContactInput.value = person.name;
            engContactClear.classList.add('visible');
            closeContactDropdown();
            closeInlinePersonForm();
        }

        // Open contact dropdown
        function openContactDropdown() {
            state.contactAutocompleteOpen = true;
            contactDropdown.classList.add('open');
        }

        // Close contact dropdown
        function closeContactDropdown() {
            state.contactAutocompleteOpen = false;
            contactDropdown.classList.remove('open');
            state.contactAutocompleteHighlightIndex = -1;
        }

        // Clear engagement contact input
        function clearOppContact() {
            state.selectedPersonId = null;
            state.pendingPerson = null;
            engContactInput.value = '';
            engContactClear.classList.remove('visible');
            closeContactDropdown();
            closeInlinePersonForm();
        }

        // Open inline person form
        function openInlinePersonForm(name) {
            state.inlinePersonFormOpen = true;
            inlinePersonName.value = name;
            inlinePersonRole.value = '';
            inlinePersonForm.classList.add('open');
            closeContactDropdown();

            // Enable tab navigation for person form elements
            setFormTabIndex(inlinePersonForm, true);

            // Focus on role after animation
            setTimeout(() => inlinePersonRole.focus(), 350);
        }

        // Close inline person form
        function closeInlinePersonForm() {
            state.inlinePersonFormOpen = false;
            inlinePersonForm.classList.remove('open');

            // Disable tab navigation for person form elements
            setFormTabIndex(inlinePersonForm, false);
        }

        // Cancel inline person creation
        function cancelInlinePerson() {
            state.pendingPerson = null;
            engContactInput.value = '';
            engContactClear.classList.remove('visible');
            closeInlinePersonForm();
        }

        // Confirm inline person creation
        function confirmInlinePerson() {
            const name = inlinePersonName.value.trim();
            const role = inlinePersonRole.value.trim();

            if (!name) {
                inlinePersonName.focus();
                return;
            }

            // Store as pending person
            state.pendingPerson = { name, role };
            state.selectedPersonId = null;

            // Update the contact input to show the name
            engContactInput.value = name;
            engContactClear.classList.add('visible');

            closeInlinePersonForm();
        }

        // ============================================
        // Inline Person Creation within Inline Engagement (Todo Modal)
        // ============================================

        // Render inline opp contact dropdown
        function renderInlineOppContactDropdown(query) {
            const matches = filterPeople(query);
            inlineEngContactDropdown.innerHTML = '';

            if (matches.length === 0) {
                const item = document.createElement('div');
                item.className = 'autocomplete-item autocomplete-no-match';
                item.textContent = `Press Enter to create "${query}"`;
                inlineEngContactDropdown.appendChild(item);
            } else {
                matches.forEach((person, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.dataset.index = index;

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'autocomplete-item-name';
                    nameSpan.textContent = person.name;
                    item.appendChild(nameSpan);

                    if (person.roleId) {
                        const role = state.roles.find(r => r.id === person.roleId);
                        if (role) {
                            const roleSpan = document.createElement('span');
                            roleSpan.className = 'autocomplete-item-role';
                            roleSpan.textContent = role.name;
                            item.appendChild(roleSpan);
                        }
                    }

                    item.addEventListener('click', () => selectInlineOppContact(person));
                    inlineEngContactDropdown.appendChild(item);
                });
            }
        }

        // Open inline opp contact dropdown
        function openInlineOppContactDropdown() {
            state.inlineEngContactAutocompleteOpen = true;
            state.inlineEngContactAutocompleteHighlightIndex = -1;
            inlineEngContactDropdown.classList.add('open');
        }

        // Close inline opp contact dropdown
        function closeInlineOppContactDropdown() {
            state.inlineEngContactAutocompleteOpen = false;
            state.inlineEngContactAutocompleteHighlightIndex = -1;
            inlineEngContactDropdown.classList.remove('open');
        }

        // Select contact for inline engagement
        function selectInlineOppContact(person) {
            state.selectedInlineOppPersonId = person.id;
            state.pendingInlineOppPerson = null;
            inlineEngContact.value = person.name;
            inlineEngContactClear.classList.add('visible');
            closeInlineOppContactDropdown();
            closeInlineOppPersonForm();
        }

        // Clear inline opp contact selection
        function clearInlineOppContact() {
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;
            inlineEngContact.value = '';
            inlineEngContactClear.classList.remove('visible');
            closeInlineOppContactDropdown();
            closeInlineOppPersonForm();
        }

        // Open inline person form within inline engagement
        function openInlineOppPersonForm(name) {
            state.inlineEngPersonFormOpen = true;
            updateTodoSaveButtonState();
            inlineEngPersonName.value = name;
            inlineEngPersonRole.value = '';
            inlineEngPersonForm.classList.add('open');
            closeInlineOppContactDropdown();

            // Enable tab navigation for person form elements
            setFormTabIndex(inlineEngPersonForm, true);

            // Scroll to make the form visible
            setTimeout(() => {
                inlineEngPersonRole.focus();
                inlineEngPersonForm.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 350);
        }

        // Close inline person form within inline engagement
        function closeInlineOppPersonForm() {
            state.inlineEngPersonFormOpen = false;
            inlineEngPersonForm.classList.remove('open');
            updateTodoSaveButtonState();

            // Disable tab navigation for person form elements
            setFormTabIndex(inlineEngPersonForm, false);
        }

        // Cancel inline person creation within inline engagement
        function cancelInlineOppPerson() {
            state.pendingInlineOppPerson = null;
            inlineEngContact.value = '';
            inlineEngContactClear.classList.remove('visible');
            closeInlineOppPersonForm();
        }

        // Confirm inline person creation within inline engagement
        function confirmInlineOppPerson() {
            const name = inlineEngPersonName.value.trim();
            const role = inlineEngPersonRole.value.trim();

            if (!name) {
                inlineEngPersonName.focus();
                return;
            }

            // Store as pending person for inline engagement
            state.pendingInlineOppPerson = { name, role };
            state.selectedInlineOppPersonId = null;

            // Update the contact input to show the name
            inlineEngContact.value = name;
            inlineEngContactClear.classList.add('visible');

            closeInlineOppPersonForm();
        }

        // Update autocomplete highlight for inline opp contact
        function updateInlineOppContactAutocompleteHighlight() {
            const items = inlineEngContactDropdown.querySelectorAll('.autocomplete-item:not(.autocomplete-no-match)');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.inlineEngContactAutocompleteHighlightIndex);
            });
        }

        // Inline opp contact input event handlers
        inlineEngContact.addEventListener('input', (e) => {
            const query = e.target.value;

            // Clear selected person if user types
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;

            // Show/hide clear button
            inlineEngContactClear.classList.toggle('visible', query.length > 0);

            // Close inline form if open
            if (state.inlineEngPersonFormOpen) {
                closeInlineOppPersonForm();
            }

            // Render and open dropdown
            if (query.trim() !== '') {
                renderInlineOppContactDropdown(query);
                openInlineOppContactDropdown();
            } else {
                closeInlineOppContactDropdown();
            }
        });

        inlineEngContact.addEventListener('focus', (e) => {
            const query = inlineEngContact.value;
            if (query.trim() !== '' && !state.selectedInlineOppPersonId && !state.pendingInlineOppPerson) {
                renderInlineOppContactDropdown(query);
                openInlineOppContactDropdown();
            }
            // Scroll to make contact field visible
            setTimeout(() => {
                inlineEngContact.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
        });

        inlineEngContact.addEventListener('keydown', (e) => {
            const items = inlineEngContactDropdown.querySelectorAll('.autocomplete-item:not(.autocomplete-no-match)');
            const matches = filterPeople(inlineEngContact.value);
            const query = inlineEngContact.value.trim();

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.inlineEngContactAutocompleteOpen && items.length > 0) {
                    state.inlineEngContactAutocompleteHighlightIndex = Math.min(state.inlineEngContactAutocompleteHighlightIndex + 1, items.length - 1);
                    updateInlineOppContactAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.inlineEngContactAutocompleteOpen && items.length > 0) {
                    state.inlineEngContactAutocompleteHighlightIndex = Math.max(state.inlineEngContactAutocompleteHighlightIndex - 1, 0);
                    updateInlineOppContactAutocompleteHighlight();
                }
            } else if (e.key === 'Tab' && !e.shiftKey) {
                // Tab (forward only) behavior:
                // 1. If contact already selected, confirm inline opp and move to Tags
                // 2. If matches exist, select first/highlighted and move on
                // 3. If no matches but text entered, open inline person form
                // 4. If no text, natural tab
                if (state.selectedInlineOppPersonId || state.pendingInlineOppPerson) {
                    // Contact is selected - confirm the inline engagement and move to Tags
                    e.preventDefault();
                    confirmInlineEngagement();
                    todoTagInput.focus();
                } else if (matches.length > 0) {
                    e.preventDefault();
                    const indexToSelect = state.inlineEngContactAutocompleteHighlightIndex >= 0 ? state.inlineEngContactAutocompleteHighlightIndex : 0;
                    selectInlineOppContact(matches[indexToSelect]);
                } else if (query && !state.inlineEngPersonFormOpen) {
                    e.preventDefault();
                    openInlineOppPersonForm(query);
                }
                // If no text entered, let Tab naturally move
            } else if (e.key === 'Enter') {
                e.preventDefault();

                // Check for exact match (case-insensitive)
                const exactMatch = matches.find(person => person.name.toLowerCase() === query.toLowerCase());

                if (state.selectedInlineOppPersonId || state.pendingInlineOppPerson) {
                    // Contact is selected - confirm the inline engagement and move to Tags
                    confirmInlineEngagement();
                    todoTagInput.focus();
                } else if (state.inlineEngContactAutocompleteHighlightIndex >= 0 && matches.length > 0) {
                    // Select highlighted item
                    selectInlineOppContact(matches[state.inlineEngContactAutocompleteHighlightIndex]);
                } else if (exactMatch) {
                    // Exact match - select it
                    selectInlineOppContact(exactMatch);
                } else if (query && !state.inlineEngPersonFormOpen) {
                    // Partial match or no matches - open inline creation form for new person
                    openInlineOppPersonForm(query);
                } else if (state.inlineEngContactAutocompleteOpen) {
                    // Just close dropdown
                    closeInlineOppContactDropdown();
                }
            } else if (e.key === 'Escape') {
                if (state.inlineEngContactAutocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeInlineOppContactDropdown();
                }
            }
        });

        // Handle inline eng person form Enter key - confirm person AND engagement
        inlineEngPersonForm.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target.tagName === 'INPUT') {
                e.preventDefault();
                // First confirm the person
                confirmInlineOppPerson();
                // Then confirm the engagement (which will include the person)
                confirmInlineEngagement();
            }
        });

        // Contact input event handlers
        engContactInput.addEventListener('input', (e) => {
            const query = e.target.value;

            // Clear selected person if user types
            state.selectedPersonId = null;
            state.pendingPerson = null;

            // Show/hide clear button
            engContactClear.classList.toggle('visible', query.length > 0);

            // Close inline form if open
            if (state.inlinePersonFormOpen) {
                closeInlinePersonForm();
            }

            // Render and open dropdown
            if (query.trim() !== '') {
                renderContactDropdown(query);
                openContactDropdown();
                // Auto-highlight first match when typing
                const matches = filterPeople(query);
                if (matches.length > 0) {
                    state.contactAutocompleteHighlightIndex = 0;
                    updateContactAutocompleteHighlight();
                }
            } else {
                closeContactDropdown();
            }
        });

        engContactInput.addEventListener('focus', () => {
            const query = engContactInput.value;
            if (query.trim() !== '' && !state.selectedPersonId && !state.pendingPerson) {
                renderContactDropdown(query);
                openContactDropdown();
            }
        });

        engContactInput.addEventListener('keydown', (e) => {
            const items = contactDropdown.querySelectorAll('.autocomplete-item');
            const matches = filterPeople(engContactInput.value);
            const query = engContactInput.value.trim();

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.contactAutocompleteOpen && items.length > 0) {
                    state.contactAutocompleteHighlightIndex = Math.min(state.contactAutocompleteHighlightIndex + 1, items.length - 1);
                    updateContactAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.contactAutocompleteOpen && items.length > 0) {
                    state.contactAutocompleteHighlightIndex = Math.max(state.contactAutocompleteHighlightIndex - 1, 0);
                    updateContactAutocompleteHighlight();
                }
            } else if (e.key === 'Tab' && !e.shiftKey) {
                // Tab (forward only) behavior:
                // 1. If matches exist, select first/highlighted and move to Tags
                // 2. If no matches but text entered, open inline creation
                // 3. If no text, natural tab
                if (matches.length > 0) {
                    e.preventDefault();
                    const indexToSelect = state.contactAutocompleteHighlightIndex >= 0 ? state.contactAutocompleteHighlightIndex : 0;
                    selectContact(matches[indexToSelect]);
                    engTagInput.focus();
                } else if (query && !state.inlinePersonFormOpen) {
                    e.preventDefault();
                    openInlinePersonForm(query);
                }
                // If no text entered, let Tab naturally move to next control
            } else if (e.key === 'Enter') {
                e.preventDefault();

                // Check for exact match (case-insensitive)
                const exactMatch = matches.find(person => person.name.toLowerCase() === query.toLowerCase());

                if (state.contactAutocompleteHighlightIndex >= 0 && matches.length > 0) {
                    // Select highlighted item
                    selectContact(matches[state.contactAutocompleteHighlightIndex]);
                } else if (exactMatch) {
                    // Exact match - select it and move to next field
                    selectContact(exactMatch);
                    engTagInput.focus();
                } else if (query && !state.inlinePersonFormOpen) {
                    // Partial match or no matches - open inline creation form
                    openInlinePersonForm(query);
                }
            } else if (e.key === 'Escape') {
                if (state.contactAutocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeContactDropdown();
                }
            }
        });

        // Handle inline person form Enter key
        inlinePersonForm.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target.tagName === 'INPUT') {
                e.preventDefault();
                confirmInlinePerson();
            }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.autocomplete-wrapper') && state.autocompleteOpen) {
                closeAutocompleteDropdown();
            }
            if (!e.target.closest('.autocomplete-wrapper') && state.contactAutocompleteOpen) {
                closeContactDropdown();
            }
            if (!e.target.closest('.autocomplete-wrapper') && state.roleAutocompleteOpen) {
                closeRoleDropdown();
            }
            if (!e.target.closest('.autocomplete-wrapper') && state.inlineEngContactAutocompleteOpen) {
                closeInlineOppContactDropdown();
            }
        });

        // Add keyboard navigation (capture phase to intercept browser shortcuts)
        document.addEventListener('keydown', (e) => {
            // Skip if any modal is open and it's not Escape
            const anyModalOpen = state.modalOpen || state.engagementModalOpen || state.personModalOpen;

            // Handle Shift+N to open todo modal (only on home tab)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'home' && !anyModalOpen) {
                e.preventDefault();
                openModal();
                return;
            }

            // Handle Shift+N to open engagement modal (only on engagements tab)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'engagements' && !anyModalOpen) {
                e.preventDefault();
                openEngagementModal();
                return;
            }

            // Handle Shift+N to open person modal (only on settings page with people section)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'settings' && state.settingsSection === 'people' && !anyModalOpen) {
                e.preventDefault();
                openPersonModal();
                return;
            }

            // Handle Shift+N to open tag modal (only on settings page with tags section)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'settings' && state.settingsSection === 'tags' && !anyModalOpen) {
                e.preventDefault();
                openTagModal();
                return;
            }

            // Handle Escape key to close modals or side panel
            if (e.key === 'Escape') {
                if (state.cancelModalOpen) {
                    e.preventDefault();
                    closeCancelModal();
                    return;
                }
                if (state.confirmModalOpen) {
                    e.preventDefault();
                    closeConfirmModal();
                    return;
                }
                if (state.modalOpen) {
                    e.preventDefault();
                    closeModal();
                    return;
                }
                if (state.engagementModalOpen) {
                    e.preventDefault();
                    closeEngagementModal();
                    return;
                }
                if (state.personModalOpen) {
                    e.preventDefault();
                    closePersonModal();
                    return;
                }
                if (state.tagModalOpen) {
                    e.preventDefault();
                    closeTagModal();
                    return;
                }
                if (state.deletePersonIndex !== null) {
                    e.preventDefault();
                    closeDeletePersonModal();
                    return;
                }
                if (state.sidePanelOpen) {
                    e.preventDefault();
                    closeSidePanel();
                    return;
                }
            }

            // Landing page keyboard shortcuts
            if (state.currentPage === 'landing') {
                if (e.key === '1') {
                    startFromScratch();
                } else if (e.key === '2') {
                    continueWorking();
                }
            }
        }, true);  // Use capture phase to intercept before browser handles it

        // Migrate existing contacts to people
        function migrateContactsToPeople() {
            // Get all unique contacts from engagements that don't have a contactId
            const contactsToMigrate = new Map();

            state.engagements.forEach(opp => {
                if (opp.contact && !opp.contactId) {
                    const normalizedContact = opp.contact.trim().toLowerCase();
                    if (!contactsToMigrate.has(normalizedContact)) {
                        contactsToMigrate.set(normalizedContact, opp.contact.trim());
                    }
                }
            });

            // Create people for unique contacts
            contactsToMigrate.forEach((originalName, normalizedName) => {
                // Check if person already exists
                const existingPerson = state.people.find(p => p.name.toLowerCase() === normalizedName);
                if (!existingPerson) {
                    const newPerson = {
                        id: generateId(),
                        name: originalName,
                        roleId: null
                    };
                    state.people.push(newPerson);
                }
            });

            // Update engagements to reference the person
            state.engagements.forEach(opp => {
                if (opp.contact && !opp.contactId) {
                    const normalizedContact = opp.contact.trim().toLowerCase();
                    const person = state.people.find(p => p.name.toLowerCase() === normalizedContact);
                    if (person) {
                        opp.contactId = person.id;
                    }
                }
            });
        }

        // ========================================
        // SCORING ALGORITHM FUNCTIONS
        // ========================================

        function getDaysUntilDeadline(deadline, currentDate = new Date()) {
            const deadlineDate = new Date(deadline);
            const today = new Date(currentDate);

            // Reset to start of day for comparison
            today.setHours(0, 0, 0, 0);
            const deadlineDay = new Date(deadlineDate);
            deadlineDay.setHours(0, 0, 0, 0);

            const msPerDay = 24 * 60 * 60 * 1000;
            return Math.floor((deadlineDay - today) / msPerDay);
        }

        function calculateDeadlineScore(todo, currentDate = new Date()) {
            if (!todo.deadline) return 0;

            const daysUntilDue = getDaysUntilDeadline(todo.deadline, currentDate);

            if (daysUntilDue < 0) {
                // OVERDUE: 150 base + 10 per day overdue, max 200
                return Math.min(200, 150 + (Math.abs(daysUntilDue) * 10));
            }

            if (daysUntilDue === 0) return 140;  // Due today
            if (daysUntilDue === 1) return 120;  // Due tomorrow
            if (daysUntilDue <= 3) return 100 - (daysUntilDue * 10);  // 70-90
            if (daysUntilDue <= 7) return 70 - (daysUntilDue * 5);    // 35-55
            if (daysUntilDue <= 14) return 30 - (daysUntilDue - 7);   // 23-30

            return Math.max(0, 20 - (daysUntilDue - 14));  // Distant future
        }

        function calculatePriorityScore(todo) {
            const priority = todo.priority || DEFAULT_PRIORITY;
            const weight = PRIORITY_TAGS[priority]?.weight;
            return weight ?? PRIORITY_TAGS[DEFAULT_PRIORITY].weight;
        }

        function calculateStalenessBonus(todo, currentDate = new Date()) {
            if (!todo.createdAt) return 0;

            const created = new Date(todo.createdAt);
            const today = new Date(currentDate);
            const msPerDay = 24 * 60 * 60 * 1000;
            const daysOld = Math.floor((today - created) / msPerDay);

            if (daysOld <= 7) return 0;
            if (daysOld <= 14) return 10;
            if (daysOld <= 30) return 20;
            return 30;
        }

        function calculateUrgencyScore(todo, currentDate = new Date()) {
            const deadline = calculateDeadlineScore(todo, currentDate);
            const priority = calculatePriorityScore(todo);
            const staleness = calculateStalenessBonus(todo, currentDate);

            return {
                total: deadline + priority + staleness,
                breakdown: { deadline, priority, staleness }
            };
        }

        function getScoreClassification(score) {
            if (score >= 250) return { label: 'Critical', class: 'critical' };
            if (score >= 200) return { label: 'Must Do Today', class: 'high' };
            if (score >= 150) return { label: 'High Priority', class: 'high' };
            if (score >= 100) return { label: 'Should Do Soon', class: 'medium' };
            if (score >= 50) return { label: 'Plan Ahead', class: '' };
            return { label: 'Backlog', class: '' };
        }

        // ========================================
        // DAILY PLAN GENERATION
        // ========================================

        function classifyTodos(scored, currentDate = new Date()) {
            const today = new Date(currentDate);
            today.setHours(0, 0, 0, 0);

            return {
                overdue: scored.filter(s => {
                    if (!s.todo.deadline) return false;
                    const d = new Date(s.todo.deadline);
                    d.setHours(0, 0, 0, 0);
                    return d < today;
                }),
                dueToday: scored.filter(s => {
                    if (!s.todo.deadline) return false;
                    const d = new Date(s.todo.deadline);
                    d.setHours(0, 0, 0, 0);
                    return d.getTime() === today.getTime();
                }),
                upcoming: scored.filter(s => {
                    if (!s.todo.deadline) return true; // Include todos without deadlines
                    const d = new Date(s.todo.deadline);
                    d.setHours(0, 0, 0, 0);
                    return d > today;
                })
            };
        }

        function buildPlan(classified, effectiveMinutes, config) {
            const plan = {
                date: new Date(),
                availableMinutes: effectiveMinutes,
                allocatedMinutes: 0,
                sections: {
                    overdue: [],
                    mustDoToday: [],
                    recommended: [],
                    ifTimePermits: []
                },
                warnings: [],
                insights: []
            };

            let remainingMinutes = effectiveMinutes;

            // Add overdue (capped, always shown)
            const overdueToShow = classified.overdue.slice(0, config.maxOverdueToShow);
            for (const item of overdueToShow) {
                plan.sections.overdue.push(formatScheduledItem(item));
                plan.allocatedMinutes += item.minutes;
            }

            // Add due today (always shown)
            for (const item of classified.dueToday) {
                plan.sections.mustDoToday.push(formatScheduledItem(item));
                plan.allocatedMinutes += item.minutes;
            }

            // Calculate remaining capacity
            remainingMinutes = effectiveMinutes - plan.allocatedMinutes;

            // Fill recommended from upcoming, respecting capacity
            for (const item of classified.upcoming) {
                if (remainingMinutes >= item.minutes) {
                    plan.sections.recommended.push(formatScheduledItem(item));
                    remainingMinutes -= item.minutes;
                    plan.allocatedMinutes += item.minutes;
                } else if (item.score.total >= 100) {
                    // High priority but doesn't fit
                    plan.sections.ifTimePermits.push(formatScheduledItem(item));
                }
            }

            return plan;
        }

        function formatScheduledItem(item) {
            return {
                todo: item.todo,
                urgencyScore: item.score.total,
                scoreBreakdown: item.score.breakdown,
                estimatedMinutes: item.minutes,
                reasoning: generateReasoning(item)
            };
        }

        function generateReasoning(item) {
            const parts = [];
            const daysUntil = getDaysUntilDeadline(item.todo.deadline);

            // Deadline reasoning
            if (daysUntil < 0) {
                parts.push(`Overdue by ${Math.abs(daysUntil)} day(s)`);
            } else if (daysUntil === 0) {
                parts.push("Due today");
            } else if (daysUntil === 1) {
                parts.push("Due tomorrow");
            } else if (daysUntil <= 7) {
                parts.push(`Due in ${daysUntil} days`);
            }

            // Priority reasoning (only mention if not normal)
            const priority = item.todo.priority || DEFAULT_PRIORITY;
            if (priority && priority !== "normal") {
                const priorityTag = PRIORITY_TAGS[priority];
                if (priorityTag) {
                    parts.push(priorityTag.label);
                }
            }

            // Effort reasoning
            const effort = item.todo.effort || DEFAULT_EFFORT;
            if (effort === "very_low") {
                parts.push("Quick win");
            } else if (effort === "very_high") {
                parts.push("Requires full day");
            }

            return parts.join("  ") || "Scheduled based on priority";
        }

        function generateDailyPlan(currentDate = new Date()) {
            const config = { ...DEFAULT_SETTINGS, ...state.settings };

            // Calculate effective work time
            const effectiveMinutes = Math.floor(
                config.workdayMinutes * (1 - config.bufferPercentage / 100)
            );

            // 1. Filter incomplete todos
            const incomplete = state.todos.filter(t => !t.completed);

            // 2. Score and sort
            const scored = incomplete
                .map(todo => ({
                    todo,
                    score: calculateUrgencyScore(todo, currentDate),
                    minutes: EFFORT_CONFIG[todo.effort || DEFAULT_EFFORT]?.minutes || 240
                }))
                .sort((a, b) => b.score.total - a.score.total);

            // 3. Classify by deadline status
            const classified = classifyTodos(scored, currentDate);

            // 4. Build the plan with time constraints
            const plan = buildPlan(classified, effectiveMinutes, config);

            // 5. Generate warnings and insights
            plan.warnings = generateWarnings(plan, scored, currentDate, config);
            plan.insights = generateInsights(plan, scored, currentDate);

            return plan;
        }

        // ========================================
        // WARNINGS AND INSIGHTS
        // ========================================

        function generateWarnings(plan, allScored, currentDate, config) {
            const warnings = [];

            // Check for overloaded day
            if (plan.allocatedMinutes > plan.availableMinutes) {
                const overloadHours = ((plan.allocatedMinutes - plan.availableMinutes) / 60).toFixed(1);
                warnings.push({
                    type: "overloaded",
                    severity: "critical",
                    message: `Today's critical items exceed available time by ${overloadHours} hours. Consider renegotiating deadlines or delegating.`
                });
            }

            // Check for large overdue backlog
            const totalOverdue = allScored.filter(s => getDaysUntilDeadline(s.todo.deadline) < 0).length;
            if (totalOverdue > config.maxOverdueToShow) {
                warnings.push({
                    type: "overdue_backlog",
                    severity: "warning",
                    message: `You have ${totalOverdue} overdue items total. Consider a backlog review session.`
                });
            }

            // Check for deadline cluster
            const next3Days = allScored.filter(s => {
                const d = getDaysUntilDeadline(s.todo.deadline);
                return d >= 0 && d <= 3;
            });
            const clusterMinutes = next3Days.reduce((sum, s) => sum + s.minutes, 0);

            if (clusterMinutes > config.workdayMinutes * 2) {
                const clusterHours = Math.round(clusterMinutes / 60);
                warnings.push({
                    type: "deadline_cluster",
                    severity: "warning",
                    message: `Heavy deadline cluster ahead: ${clusterHours} hours of work due in the next 3 days.`
                });
            }

            // Check for impossible single task
            const impossibleTask = allScored.find(s =>
                s.minutes > config.workdayMinutes && getDaysUntilDeadline(s.todo.deadline) <= 1
            );
            if (impossibleTask) {
                warnings.push({
                    type: "impossible_task",
                    severity: "critical",
                    message: `"${impossibleTask.todo.title}" requires ${(impossibleTask.minutes / 60).toFixed(1)} hours but is due very soon. Consider breaking it down.`
                });
            }

            return warnings;
        }

        function generateInsights(plan, allScored, currentDate) {
            const insights = [];

            // Light day - good opportunity
            const utilization = plan.availableMinutes > 0
                ? (plan.allocatedMinutes / plan.availableMinutes) * 100
                : 0;
            if (utilization < 50 && allScored.length > 0) {
                insights.push({
                    type: "light_day",
                    message: "Light day ahead! Good chance to get ahead on upcoming tasks or clear some backlog."
                });
            }

            // Quick wins available
            const quickWins = allScored.filter(s =>
                (s.todo.effort === "very_low") && s.score.total >= 50
            );
            if (quickWins.length >= 3) {
                insights.push({
                    type: "quick_wins",
                    message: `${quickWins.length} quick-win tasks available. Consider batching them to build momentum.`
                });
            }

            // All caught up
            if (plan.sections.overdue.length === 0 && plan.sections.mustDoToday.length === 0) {
                insights.push({
                    type: "caught_up",
                    message: "No overdue or urgent items! Great time to work on important-but-not-urgent tasks."
                });
            }

            // High effort concentration
            const highEffortToday = [...plan.sections.mustDoToday, ...plan.sections.recommended]
                .filter(s => s.todo.effort === "high" || s.todo.effort === "very_high");
            if (highEffortToday.length >= 2) {
                insights.push({
                    type: "high_effort",
                    message: "Multiple high-effort tasks today. Consider tackling the hardest one during your peak energy hours."
                });
            }

            return insights;
        }

        // ========================================
        // FORMATTING HELPERS
        // ========================================

        function formatDeadlineDisplay(deadline, currentDate = new Date()) {
            if (!deadline) return 'No deadline';

            const days = getDaysUntilDeadline(deadline, currentDate);

            if (days < -1) return `${Math.abs(days)} days overdue`;
            if (days === -1) return "Yesterday";
            if (days === 0) return "Today";
            if (days === 1) return "Tomorrow";
            if (days <= 7) return `In ${days} days`;

            return new Date(deadline).toLocaleDateString("en-US", {
                month: "short",
                day: "numeric"
            });
        }

        function formatEffortDisplay(effort) {
            const config = EFFORT_CONFIG[effort || DEFAULT_EFFORT];
            if (!config) return '4 hrs';
            if (config.minutes < 60) {
                return `${config.minutes} min`;
            }
            return `${config.minutes / 60} hrs`;
        }

        function formatPlanSummary(plan) {
            const overdueCount = plan.sections.overdue.length;
            const todayCount = plan.sections.mustDoToday.length;
            const totalHours = (plan.allocatedMinutes / 60).toFixed(1);

            const parts = [];
            if (overdueCount > 0) parts.push(`${overdueCount} overdue`);
            if (todayCount > 0) parts.push(`${todayCount} due today`);
            parts.push(`${totalHours} hrs planned`);

            return parts.join("  ");
        }

        function formatDateHeader(date = new Date()) {
            return date.toLocaleDateString("en-US", {
                weekday: "long",
                month: "long",
                day: "numeric",
                year: "numeric"
            });
        }

        // ========================================
        // RECOMMENDATION PANEL RENDERING
        // ========================================

        function renderRecommendationPanel() {
            const plan = generateDailyPlan();

            // Update header
            recommendationDateText.textContent = `Daily Plan  ${formatDateHeader()}`;
            recommendationSummary.textContent = formatPlanSummary(plan);

            // Render warnings
            renderWarnings(plan.warnings);

            // Render sections
            renderRecommendationSection(overdueSection, overdueItems, overdueCount, plan.sections.overdue);
            renderRecommendationSection(mustDoSection, mustDoItems, mustDoCount, plan.sections.mustDoToday);
            renderRecommendationSection(recommendedSection, recommendedItems, recommendedCount, plan.sections.recommended);
            renderRecommendationSection(ifTimeSection, ifTimeItems, ifTimeCount, plan.sections.ifTimePermits);

            // Render insights
            renderInsights(plan.insights);

            // Show/hide empty state
            const hasItems = plan.sections.overdue.length > 0 ||
                           plan.sections.mustDoToday.length > 0 ||
                           plan.sections.recommended.length > 0 ||
                           plan.sections.ifTimePermits.length > 0;
            recommendationEmpty.classList.toggle('hidden', hasItems);
        }

        function renderRecommendationSection(sectionEl, itemsEl, countEl, items) {
            sectionEl.classList.toggle('hidden', items.length === 0);
            countEl.textContent = items.length;
            itemsEl.innerHTML = '';

            items.forEach((item, index) => {
                const itemEl = createRecommendationItemElement(item, index);
                itemsEl.appendChild(itemEl);
            });
        }

        function createRecommendationItemElement(item, index) {
            const div = document.createElement('div');
            div.className = `recommendation-item ${item.todo.completed ? 'completed' : ''}`;

            const priority = item.todo.priority || DEFAULT_PRIORITY;
            const effort = item.todo.effort || DEFAULT_EFFORT;
            const scoreClass = getScoreClassification(item.urgencyScore);

            // Build tags HTML
            let tagsHtml = '';
            if (priority !== 'normal') {
                const priorityTag = PRIORITY_TAGS[priority];
                tagsHtml += `<span class="priority-pill priority-${priority}">${priorityTag.label}</span>`;
            }

            // Add user tags
            if (item.todo.tagIds && item.todo.tagIds.length > 0) {
                item.todo.tagIds.forEach(tagId => {
                    const tag = state.tags.find(t => t.id === tagId);
                    if (tag) {
                        tagsHtml += `<span class="tag-pill" style="background-color: ${tag.color}20; color: ${tag.color}; border: 1px solid ${tag.color}40;">${escapeHtml(tag.name)}</span>`;
                    }
                });
            }

            div.innerHTML = `
                <div class="recommendation-item-header">
                    <div class="recommendation-item-checkbox ${item.todo.completed ? 'checked' : ''}"
                         onclick="toggleTodoFromRecommendation('${item.todo.id}')"></div>
                    <div class="recommendation-item-title">${escapeHtml(item.todo.title)}</div>
                </div>
                <div class="recommendation-item-meta">
                    <span class="recommendation-item-effort"> ${formatEffortDisplay(effort)}</span>
                    <span class="recommendation-item-deadline"> ${formatDeadlineDisplay(item.todo.deadline)}</span>
                </div>
                ${tagsHtml ? `<div class="recommendation-item-tags">${tagsHtml}</div>` : ''}
                <div class="recommendation-item-reasoning">${item.reasoning}</div>
                <div class="recommendation-item-score">
                    <span class="score-badge ${scoreClass.class}">Score: ${item.urgencyScore}</span>
                </div>
            `;

            return div;
        }

        function renderWarnings(warnings) {
            warningsSection.innerHTML = '';
            warningsSection.classList.toggle('hidden', warnings.length === 0);

            warnings.forEach(warning => {
                const card = document.createElement('div');
                card.className = `warning-card ${warning.severity === 'critical' ? 'critical' : ''}`;
                card.innerHTML = `
                    <span class="warning-icon"></span>
                    <span class="warning-message">${escapeHtml(warning.message)}</span>
                `;
                warningsSection.appendChild(card);
            });
        }

        function renderInsights(insights) {
            insightsSection.classList.toggle('hidden', insights.length === 0);
            insightsItems.innerHTML = '';

            insights.forEach(insight => {
                const card = document.createElement('div');
                card.className = 'insight-card';
                card.innerHTML = `
                    <span class="insight-icon"></span>
                    <span class="insight-message">${escapeHtml(insight.message)}</span>
                `;
                insightsItems.appendChild(card);
            });
        }

        function toggleTodoFromRecommendation(todoId) {
            const index = state.todos.findIndex(t => t.id === todoId);
            if (index !== -1) {
                toggleTodo(index);
            }
        }

        // ========================================
        // PRIORITY AUTOCOMPLETE FUNCTIONS
        // ========================================

        function getFilteredPriorityOptions(filter = '') {
            const filterLower = filter.toLowerCase();
            return Object.keys(PRIORITY_TAGS).filter(key => {
                const priority = PRIORITY_TAGS[key];
                if (filter && !priority.label.toLowerCase().includes(filterLower) &&
                    !priority.name.toLowerCase().includes(filterLower)) {
                    return false;
                }
                return true;
            });
        }

        function renderPriorityDropdown(filter = '') {
            priorityDropdown.innerHTML = '';
            const filteredOptions = getFilteredPriorityOptions(filter);

            filteredOptions.forEach((key, filteredIndex) => {
                const priority = PRIORITY_TAGS[key];
                const option = document.createElement('div');
                option.className = `priority-option ${state.selectedPriority === key ? 'selected' : ''} ${state.priorityHighlightIndex === filteredIndex ? 'highlighted' : ''}`;
                option.innerHTML = `
                    <span class="priority-option-color" style="background-color: ${priority.color}"></span>
                    <span class="priority-option-label">${priority.label}</span>
                    <span class="priority-option-desc">${priority.description}</span>
                `;
                option.onclick = () => selectPriority(key);
                priorityDropdown.appendChild(option);
            });
        }

        function selectPriority(key) {
            state.selectedPriority = key;
            todoPriorityInput.value = PRIORITY_TAGS[key].label;
            closePriorityDropdown();
        }

        function openPriorityDropdown() {
            state.priorityDropdownOpen = true;
            state.priorityHighlightIndex = -1;
            renderPriorityDropdown(todoPriorityInput.value);
            priorityDropdown.classList.add('open');
        }

        function closePriorityDropdown() {
            state.priorityDropdownOpen = false;
            state.priorityHighlightIndex = -1;
            priorityDropdown.classList.remove('open');
        }

        // Priority input event listeners
        if (todoPriorityInput) {
            todoPriorityInput.addEventListener('focus', () => {
                openPriorityDropdown();
            });

            todoPriorityInput.addEventListener('input', (e) => {
                openPriorityDropdown();
                renderPriorityDropdown(e.target.value);
                // Auto-highlight first match when typing
                const filteredOptions = getFilteredPriorityOptions(e.target.value);
                if (filteredOptions.length > 0) {
                    state.priorityHighlightIndex = 0;
                    renderPriorityDropdown(e.target.value);
                }
            });

            todoPriorityInput.addEventListener('keydown', (e) => {
                const filteredOptions = getFilteredPriorityOptions(todoPriorityInput.value);

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    state.priorityHighlightIndex = Math.min(state.priorityHighlightIndex + 1, filteredOptions.length - 1);
                    renderPriorityDropdown(todoPriorityInput.value);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    state.priorityHighlightIndex = Math.max(state.priorityHighlightIndex - 1, 0);
                    renderPriorityDropdown(todoPriorityInput.value);
                } else if (e.key === 'Tab' && !e.shiftKey && state.priorityDropdownOpen) {
                    // Tab (forward only) with dropdown open: select first/highlighted match and move on
                    if (filteredOptions.length > 0) {
                        e.preventDefault();
                        const indexToSelect = state.priorityHighlightIndex >= 0 ? state.priorityHighlightIndex : 0;
                        selectPriority(filteredOptions[indexToSelect]);
                        // Move focus to the next focusable element
                        todoEngagementInput.focus();
                    }
                    // If no filtered options, let Tab naturally move to next control
                } else if (e.key === 'Enter' && state.priorityDropdownOpen) {
                    e.preventDefault();
                    if (filteredOptions.length > 0) {
                        const indexToSelect = state.priorityHighlightIndex >= 0 ? state.priorityHighlightIndex : 0;
                        selectPriority(filteredOptions[indexToSelect]);
                    }
                } else if (e.key === 'Escape') {
                    closePriorityDropdown();
                }
            });

            todoPriorityInput.addEventListener('blur', () => {
                // Delay to allow click events on dropdown items
                setTimeout(() => {
                    // Validate input - if not a valid priority, reset to selected
                    const inputValue = todoPriorityInput.value.toLowerCase();
                    const matchingKey = Object.keys(PRIORITY_TAGS).find(
                        key => PRIORITY_TAGS[key].label.toLowerCase() === inputValue ||
                               PRIORITY_TAGS[key].name.toLowerCase() === inputValue
                    );

                    if (matchingKey) {
                        state.selectedPriority = matchingKey;
                    }

                    // Always show the selected priority label
                    todoPriorityInput.value = PRIORITY_TAGS[state.selectedPriority].label;
                    closePriorityDropdown();
                }, 200);
            });
        }

        // ========================================
        // PLANNING SETTINGS FUNCTIONS
        // ========================================

        function savePlanningSettings(event) {
            event.preventDefault();

            state.settings.workdayMinutes = parseInt(document.getElementById('workday-minutes').value) || DEFAULT_SETTINGS.workdayMinutes;
            state.settings.bufferPercentage = parseInt(document.getElementById('buffer-percentage').value) || DEFAULT_SETTINGS.bufferPercentage;
            state.settings.maxOverdueToShow = parseInt(document.getElementById('max-overdue').value) || DEFAULT_SETTINGS.maxOverdueToShow;
            state.settings.planningHorizonDays = parseInt(document.getElementById('planning-horizon').value) || DEFAULT_SETTINGS.planningHorizonDays;

            // Refresh recommendation panel with new settings
            if (state.currentPage === 'app' && state.currentTab === 'home') {
                renderRecommendationPanel();
            }

            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));

            alert('Planning settings saved successfully!');
        }

        function loadPlanningSettings() {
            document.getElementById('workday-minutes').value = state.settings.workdayMinutes;
            document.getElementById('buffer-percentage').value = state.settings.bufferPercentage;
            document.getElementById('max-overdue').value = state.settings.maxOverdueToShow;
            document.getElementById('planning-horizon').value = state.settings.planningHorizonDays;
        }

        function renderPlanningSettings() {
            loadPlanningSettings();
        }

        // ========================================
        // STORAGE SECTION FUNCTIONS
        // ========================================

        async function renderStorageSection() {
            const stats = await getStorageStats();
            document.getElementById('storage-size').textContent = formatBytes(stats.estimatedSize);
            document.getElementById('storage-todos').textContent = stats.todoCount;
            document.getElementById('storage-engagements').textContent = stats.engagementCount;
        }

        function openClearStateModal() {
            document.getElementById('clear-state-modal').classList.remove('hidden');
        }

        function closeClearStateModal() {
            document.getElementById('clear-state-modal').classList.add('hidden');
        }

        function exportThenClear() {
            // Export data first
            exportData();
            // Then clear after a short delay to allow download to start
            setTimeout(() => {
                confirmClearState();
            }, 500);
        }

        async function confirmClearState() {
            try {
                // Clear IndexedDB
                await clearIndexedDB();

                // Reset in-memory state
                state.todos = [];
                state.engagements = [];
                state.people = [];
                state.roles = [];
                state.tags = [];
                state.settings = { ...DEFAULT_SETTINGS };

                // Close modal and navigate to landing page
                closeClearStateModal();
                navigateTo('landing');
            } catch (error) {
                console.error('Failed to clear state:', error);
                alert('Failed to clear browser state. Please try again.');
            }
        }

        // ========================================
        // DATETIME HELPERS
        // ========================================

        function getDefaultDeadline() {
            const now = new Date();
            now.setHours(17, 0, 0, 0); // Default to 5 PM today
            return formatDateTimeLocal(now);
        }

        function formatDateTimeLocal(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        // Show IndexedDB warning modal
        function showIndexedDBWarning() {
            document.getElementById('indexeddb-warning-modal').classList.remove('hidden');
        }

        // Initialize application with IndexedDB
        async function initializeApp() {
            try {
                // Initialize IndexedDB
                await initDB();

                // Try to load saved state
                const savedState = await loadStateFromIndexedDB();

                if (savedState) {
                    // Restore state from IndexedDB
                    state.todos = Array.isArray(savedState.todos) ? savedState.todos : [];
                    state.engagements = Array.isArray(savedState.engagements) ? savedState.engagements : [];
                    state.people = Array.isArray(savedState.people) ? savedState.people : [];
                    state.roles = Array.isArray(savedState.roles) ? savedState.roles : [];
                    state.tags = Array.isArray(savedState.tags) ? savedState.tags : [];

                    // Restore settings (merge with defaults)
                    if (savedState.settings && typeof savedState.settings === 'object') {
                        state.settings = { ...DEFAULT_SETTINGS, ...savedState.settings };
                    }

                    // Ensure all todos have required fields with defaults
                    state.todos = state.todos.map(todo => ({
                        ...todo,
                        title: todo.title || todo.description || 'Untitled',
                        description: todo.description || null,
                        deadline: todo.deadline || (todo.dueDate ? new Date(todo.dueDate).toISOString() : null),
                        effort: todo.effort || DEFAULT_EFFORT,
                        priority: PRIORITY_TAGS[todo.priority] ? todo.priority : DEFAULT_PRIORITY,
                        completedAt: todo.completedAt || null,
                        createdAt: todo.createdAt || new Date().toISOString(),
                        updatedAt: todo.updatedAt || new Date().toISOString()
                    }));

                    // Run migration for backwards compatibility
                    migrateContactsToPeople();

                    // Navigate directly to app with home tab
                    state.currentTab = 'home';
                    navigateTo('app');
                } else {
                    // No saved state, show landing page
                    migrateContactsToPeople();
                    navigateTo('landing');
                }
            } catch (error) {
                console.error('Failed to initialize IndexedDB:', error);
                // Show warning modal if IndexedDB is unavailable
                showIndexedDBWarning();
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize inline forms with disabled tab navigation (they start closed)
            setFormTabIndex(inlineEngForm, false);
            setFormTabIndex(inlineEngPersonForm, false);
            if (inlinePersonForm) setFormTabIndex(inlinePersonForm, false);

            // Initialize app with IndexedDB (handles migration and navigation)
            initializeApp();
        });
    </script>
</body>
</html>
