<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TodoManager - Manage Your Tasks Efficiently</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #F5F5F5 0%, #E8E8E8 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
            overflow-x: hidden;
        }

        .container {
            max-width: 600px;
            width: 100%;
            text-align: center;
            animation: fadeIn 0.6s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .logo-container {
            margin-bottom: 48px;
            animation: slideDown 0.8s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .logo {
            width: 120px;
            height: 120px;
            margin: 0 auto 24px;
            filter: drop-shadow(0 4px 12px rgba(255, 184, 0, 0.3));
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        .logo:hover {
            animation: float 3s ease-in-out infinite, pulse 0.6s ease;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        h1 {
            font-size: 48px;
            font-weight: 700;
            color: #1F1F1F;
            margin-bottom: 16px;
            letter-spacing: -1px;
        }

        .tagline {
            font-size: 18px;
            color: #6C757D;
            margin-bottom: 64px;
            font-weight: 400;
        }

        .options-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-bottom: 32px;
        }

        .option-card {
            background: white;
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid transparent;
            animation: slideUp 0.6s ease;
            animation-fill-mode: both;
        }

        .option-card:nth-child(1) {
            animation-delay: 0.2s;
        }

        .option-card:nth-child(2) {
            animation-delay: 0.3s;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .option-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            border-color: #FFB800;
        }

        .option-card:active {
            transform: translateY(-2px) scale(1.01);
        }

        .option-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            background: linear-gradient(135deg, #FFB800 0%, #FFA000 100%);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .option-card:hover .option-icon {
            transform: rotate(5deg) scale(1.1);
            box-shadow: 0 4px 16px rgba(255, 184, 0, 0.4);
        }

        .option-icon svg {
            width: 36px;
            height: 36px;
            color: #1F1F1F;
        }

        .option-title {
            font-size: 24px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 8px;
        }

        .option-description {
            font-size: 14px;
            color: #6C757D;
            line-height: 1.5;
        }

        .footer {
            margin-top: 48px;
            font-size: 14px;
            color: #ADB5BD;
            animation: fadeIn 0.8s ease 0.5s both;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 36px;
            }

            .tagline {
                font-size: 16px;
                margin-bottom: 48px;
            }

            .logo {
                width: 100px;
                height: 100px;
            }

            .option-card {
                padding: 24px;
            }

            .option-title {
                font-size: 20px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Page visibility */
        .hidden {
            display: none !important;
        }

        .page {
            min-height: 100vh;
            width: 100%;
        }

        /* Header styles */
        .header {
            height: 60px;
            background: #FFFFFF;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 24px;
        }

        .header-title {
            font-size: 16px;
            font-weight: 500;
            color: #1F1F1F;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: 4px;
        }

        .tab-btn {
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            color: #6C757D;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tab-btn:hover {
            color: #1F1F1F;
            background: #F8F9FA;
        }

        .tab-btn.active {
            color: #1F1F1F;
            background: #FFB800;
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .icon-button {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }

        .icon-button:hover {
            background: #F8F9FA;
        }

        .icon-button:active {
            transform: scale(0.95);
        }

        .icon-button svg {
            width: 24px;
            height: 24px;
            color: #6C757D;
            transition: color 0.2s ease, transform 0.3s ease;
        }

        .icon-button:hover svg {
            color: #1F1F1F;
        }

        /* Settings icon rotation on hover */
        .icon-button[title="Settings"]:hover svg {
            transform: rotate(90deg);
        }

        /* Main content area */
        .main-content {
            padding-top: 84px;
            padding-left: 24px;
            padding-right: 24px;
            padding-bottom: 24px;
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Todo list styles */
        .todo-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .todo-item {
            background: #FFFFFF;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s ease;
        }

        .todo-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translateY(-2px);
        }

        .todo-checkbox {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #E0E0E0;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.2s ease;
        }

        .todo-checkbox.checked {
            background: #00A86B;
            border-color: #00A86B;
        }

        .todo-content {
            flex: 1;
            display: flex;
            gap: 16px;
            align-items: flex-start;
        }

        .todo-info {
            flex: 0 0 auto;
            min-width: 180px;
            max-width: 50%;
        }

        .todo-description {
            flex: 1;
            font-size: 13px;
            color: #6C757D;
            line-height: 1.4;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }

        .todo-item.completed .todo-description {
            color: #ADB5BD;
        }

        .todo-item.dropped .todo-description {
            color: #E57373;
        }

        .todo-title {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
        }

        /* Empty state styles */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 64px 24px;
            animation: fadeIn 0.5s ease;
        }

        .empty-icon {
            width: 64px;
            height: 64px;
            color: #ADB5BD;
            margin-bottom: 16px;
        }

        .empty-text {
            font-size: 16px;
            font-weight: 500;
            color: #ADB5BD;
        }

        /* Keyboard shortcut hint text */
        .shortcut-hint {
            font-size: 13px;
            font-style: italic;
            color: #ADB5BD;
            margin-top: 12px;
        }

        .shortcut-hint-floating {
            font-size: 12px;
            font-style: italic;
            color: #ADB5BD;
            text-align: center;
            padding: 8px 0;
            margin-bottom: 8px;
        }

        /* Home page body override */
        #home-page {
            background: #F5F5F5;
        }

        /* Responsive styles for home page */
        @media (max-width: 768px) {
            .header {
                padding: 0 16px;
            }

            .main-content {
                padding-left: 16px;
                padding-right: 16px;
            }
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            position: relative;
            background: #FFFFFF;
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 480px;
            max-height: calc(100vh - 48px);
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            animation: modalSlideIn 0.3s ease;
            transform-origin: center center;
            transition: max-width 300ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Expanded state for horizontal inline creation */
        .modal-content.expanded {
            max-width: 900px;
            overflow-y: visible;
        }

        /* Two-column layout container */
        .todo-form-columns {
            display: flex;
            gap: 0;
        }

        .todo-form-columns.expanded {
            gap: 24px;
        }

        /* Left column - main todo form */
        .todo-form-left {
            flex: 1;
            min-width: 0;
        }

        /* Vertical separator between columns */
        .column-separator {
            width: 0;
            background-color: #E5E7EB;
            align-self: stretch;
            opacity: 0;
            transition: width 200ms ease-in-out 100ms, opacity 200ms ease-in-out 100ms;
        }

        .todo-form-columns.expanded .column-separator {
            width: 1px;
            opacity: 1;
        }

        /* Right column - inline engagement panel */
        .todo-form-right {
            flex: 0 0 0;
            min-width: 0;
            overflow: hidden;
            opacity: 0;
            transition: flex-basis 300ms cubic-bezier(0.4, 0, 0.2, 1),
                        opacity 200ms ease-in-out;
        }

        .todo-form-columns.expanded .todo-form-right {
            flex: 0 0 380px;
            opacity: 1;
        }

        /* Disabled state for main form when inline is active */
        .todo-form-left.disabled .form-input,
        .todo-form-left.disabled .form-textarea,
        .todo-form-left.disabled .effort-select,
        .todo-form-left.disabled .priority-input,
        .todo-form-left.disabled .autocomplete-input,
        .todo-form-left.disabled .tag-input {
            background-color: #F9FAFB;
            color: #9CA3AF;
            pointer-events: none;
        }

        .todo-form-left.disabled .form-label {
            color: #9CA3AF;
        }

        /* Right panel engagement inline form - visible by default when in right column */
        .inline-eng-panel {
            padding: 0;
        }

        .inline-eng-panel .inline-eng-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid #E5E7EB;
        }

        .inline-eng-panel .inline-eng-panel-title {
            font-size: 16px;
            font-weight: 600;
            color: #374151;
        }

        .inline-eng-panel .inline-eng-panel-actions {
            display: flex;
            gap: 8px;
        }

        .inline-eng-panel .form-group {
            margin-bottom: 16px;
        }

        .inline-eng-panel .form-group:last-of-type {
            margin-bottom: 20px;
        }

        /* Contact inline form within right panel */
        .inline-contact-form {
            background: #F9FAFB;
            border: 1px solid transparent;
            border-radius: 8px;
            padding: 0;
            margin-top: 12px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 250ms cubic-bezier(0.4, 0, 0.2, 1),
                        padding 250ms cubic-bezier(0.4, 0, 0.2, 1),
                        border-color 150ms ease-in-out;
        }

        .inline-contact-form.open {
            max-height: 250px;
            padding: 16px;
            border-color: #E5E7EB;
        }

        .inline-contact-form .inline-contact-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .inline-contact-form .inline-contact-title {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
        }

        .inline-contact-form .inline-contact-actions {
            display: flex;
            gap: 8px;
        }

        .inline-contact-form .inline-contact-actions .btn {
            padding: 6px 12px;
            font-size: 12px;
        }

        .inline-contact-form .form-group {
            margin-bottom: 12px;
        }

        .inline-contact-form .form-group:last-of-type {
            margin-bottom: 0;
        }

        .inline-contact-form .form-label {
            font-size: 12px;
            margin-bottom: 4px;
        }

        .inline-contact-form .form-input {
            height: 40px;
            padding: 8px 12px;
            font-size: 13px;
        }

        /* Inline engagement textarea styling */
        .inline-eng-textarea {
            min-height: 60px;
            max-height: 100px;
            resize: vertical;
        }

        /* Panel actions at bottom of right column */
        .inline-eng-panel-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #E5E7EB;
        }

        /* Animation for right panel slide-in */
        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .todo-form-right.animate-in {
            animation: slideInRight 300ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Reduced motion preference */
        @media (prefers-reduced-motion: reduce) {
            .modal-content {
                transition: none;
            }
            .todo-form-right,
            .column-separator,
            .inline-contact-form {
                transition: none;
            }
            .todo-form-right.animate-in {
                animation: none;
            }
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 24px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 8px;
        }

        .form-label .required {
            color: #DC3545;
        }

        .form-input {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .form-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .form-input::placeholder {
            color: #ADB5BD;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 24px;
        }

        .btn {
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .btn-primary {
            background: #FFB800;
            color: #1F1F1F;
        }

        .btn-primary:hover {
            background: #E5A600;
            transform: scale(1.02);
        }

        .btn-secondary {
            background: #F8F9FA;
            color: #6C757D;
        }

        .btn-secondary:hover {
            background: #E9ECEF;
        }

        /* Disabled button state */
        .btn:disabled,
        .btn.btn-disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        .btn-primary:disabled,
        .btn-primary.btn-disabled {
            background: #FFB800;
        }

        /* Tooltip wrapper for disabled button */
        .btn-tooltip-wrapper {
            position: relative;
            display: inline-block;
        }

        .btn-tooltip-wrapper[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            margin-bottom: 8px;
            z-index: 1000;
        }

        .btn-tooltip-wrapper[data-tooltip]:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #333;
            margin-bottom: -4px;
            z-index: 1000;
        }

        /* Todo item with due date */
        .todo-due-date {
            font-size: 12px;
            color: #6C757D;
            margin-top: 4px;
        }

        .todo-due-date.overdue {
            color: #DC3545;
        }

        .todo-item.completed .todo-title {
            text-decoration: line-through;
            color: #ADB5BD;
        }

        .todo-item.dropped {
            opacity: 0.6;
        }

        .todo-item.dropped .todo-title {
            text-decoration: line-through;
            color: #E57373;
        }

        .todo-item.dropped .todo-checkbox {
            background: #FFCDD2;
            border-color: #E57373;
        }

        .todo-item.dropped .todo-checkbox::after {
            content: 'âœ•';
            display: block;
            color: #C62828;
            font-size: 10px;
            line-height: 16px;
            text-align: center;
            border: none;
            transform: none;
            width: auto;
            height: auto;
            margin: 0;
        }

        /* Checkmark icon inside checkbox */
        .todo-checkbox.checked::after {
            content: '';
            display: block;
            width: 8px;
            height: 5px;
            border-left: 2px solid #FFFFFF;
            border-bottom: 2px solid #FFFFFF;
            transform: rotate(-45deg);
            margin: 6px auto;
        }

        /* Todo actions (edit button) */
        .todo-actions {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: auto;
        }

        .todo-edit-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
            flex-shrink: 0;
        }

        .todo-edit-btn:hover {
            background: #F0F0F0;
        }

        .todo-edit-btn svg {
            width: 18px;
            height: 18px;
            color: #6C757D;
            transition: color 0.2s ease;
        }

        .todo-edit-btn:hover svg {
            color: #1F1F1F;
        }

        /* Modal responsive */
        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                padding: 20px;
            }

            .modal-actions {
                flex-direction: column-reverse;
            }

            .btn {
                width: 100%;
            }
        }

        /* Responsive fallback for horizontal expansion on narrow screens */
        @media (max-width: 950px) {
            .modal-content.expanded {
                max-width: 95%;
            }

            .todo-form-columns.expanded {
                flex-direction: column;
                gap: 16px;
            }

            .todo-form-columns.expanded .column-separator {
                width: 100%;
                height: 1px;
                margin: 8px 0;
            }

            .todo-form-columns.expanded .todo-form-right {
                flex: 1 1 auto;
            }
        }

        /* Engagement list styles */
        .engagement-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .engagement-item {
            background: #FFFFFF;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            align-items: center;
            gap: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .engagement-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translateY(-2px);
        }

        .engagement-content {
            flex: 1;
            min-width: 0;
        }

        .engagement-name {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 4px;
        }

        .engagement-contact {
            font-size: 12px;
            color: #6C757D;
        }

        /* Expanded engagement styles (Issue-57) */
        .engagement-item.expanded {
            flex-direction: column;
            align-items: stretch;
            cursor: default;
            transform: none;
        }

        .engagement-item.expanded:hover {
            transform: none;
        }

        .engagement-header {
            display: flex;
            align-items: center;
            gap: 16px;
            cursor: pointer;
            width: 100%;
        }

        .engagement-expanded-content {
            display: none;
            overflow: hidden;
            max-height: 0;
            opacity: 0;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, padding 0.3s ease-out;
            border-top: 1px solid #E5E7EB;
            margin-top: 12px;
            padding-top: 0;
        }

        .engagement-item.expanded .engagement-expanded-content {
            display: flex;
            max-height: 400px;
            opacity: 1;
            padding-top: 16px;
        }

        .engagement-expanded-panes {
            display: flex;
            gap: 24px;
            width: 100%;
        }

        .engagement-left-pane {
            flex: 1;
            min-width: 0;
        }

        .engagement-right-pane {
            flex: 1;
            min-width: 0;
            max-height: 280px;
            overflow-y: auto;
            border-left: 1px solid #E5E7EB;
            padding-left: 24px;
        }

        /* Left pane content */
        .engagement-detail-row {
            display: flex;
            gap: 32px;
            margin-bottom: 16px;
        }

        .engagement-detail-group {
            flex: 1;
        }

        .engagement-detail-label {
            font-size: 12px;
            color: #6C757D;
            margin-bottom: 4px;
        }

        .engagement-detail-value {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
        }

        .engagement-detail-subtitle {
            font-size: 12px;
            color: #9CA3AF;
        }

        .engagement-description-section {
            margin-bottom: 16px;
        }

        .engagement-description-label {
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        .engagement-description-text {
            font-size: 13px;
            color: #4B5563;
            line-height: 1.5;
        }

        .engagement-action-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 16px;
        }

        .engagement-promote-btn {
            color: #2563EB;
            font-size: 13px;
            font-weight: 500;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
        }

        .engagement-promote-btn:hover {
            text-decoration: underline;
        }

        .engagement-comments-btn {
            display: flex;
            align-items: center;
            gap: 4px;
            color: #6C757D;
            font-size: 13px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .engagement-comments-btn:hover {
            background: #F3F4F6;
            color: #374151;
        }

        .engagement-comments-btn svg {
            width: 18px;
            height: 18px;
        }

        .engagement-comments-count {
            font-weight: 500;
        }

        /* Right pane - Todo list */
        .engagement-todo-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .engagement-todo-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 0;
        }

        .engagement-todo-status {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .engagement-todo-status.open {
            color: #9CA3AF;
        }

        .engagement-todo-status.done {
            color: #22C55E;
        }

        .engagement-todo-status.dropped {
            color: #EF4444;
        }

        .engagement-todo-status svg {
            width: 18px;
            height: 18px;
        }

        .engagement-todo-title {
            flex: 1;
            font-size: 13px;
            color: #1F1F1F;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .engagement-todo-item.completed .engagement-todo-title,
        .engagement-todo-item.dropped .engagement-todo-title {
            text-decoration: line-through;
            color: #9CA3AF;
        }

        .engagement-todo-priority {
            padding: 2px 8px;
            font-size: 10px;
            font-weight: 600;
            border-radius: 4px;
            text-transform: uppercase;
            white-space: nowrap;
        }

        .engagement-todo-priority.urgent {
            background: #FEE2E2;
            color: #DC2626;
        }

        .engagement-todo-priority.high {
            background: #FFEDD5;
            color: #EA580C;
        }

        .engagement-todo-priority.normal {
            background: #FEF3C7;
            color: #D97706;
        }

        .engagement-todo-priority.low {
            background: #E5E7EB;
            color: #6B7280;
        }

        .engagement-todo-priority.someday {
            background: #F3F4F6;
            color: #9CA3AF;
        }

        .engagement-todo-effort {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            color: #6B7280;
            white-space: nowrap;
        }

        .engagement-todo-effort svg {
            width: 14px;
            height: 14px;
            color: #22C55E;
        }

        .engagement-todos-empty {
            text-align: center;
            color: #9CA3AF;
            font-size: 13px;
            padding: 24px;
        }

        /* Status badges */
        .status-badge {
            padding: 4px 12px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 16px;
            white-space: nowrap;
        }

        .status-requested {
            background: #E3F2FD;
            color: #1976D2;
        }

        .status-open {
            background: #E8F5E9;
            color: #388E3C;
        }

        .status-paused {
            background: #FFF3E0;
            color: #F57C00;
        }

        .status-cancelled {
            background: #FFEBEE;
            color: #D32F2F;
        }

        .status-closed {
            background: #F3E5F5;
            color: #7B1FA2;
        }

        /* Side Panel */
        .side-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 400px;
            max-width: 100%;
            height: 100vh;
            background: #FFFFFF;
            box-shadow: -4px 0 24px rgba(0, 0, 0, 0.15);
            z-index: 200;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .side-panel.open {
            transform: translateX(0);
        }

        .side-panel-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 199;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .side-panel-backdrop.open {
            opacity: 1;
            visibility: visible;
        }

        .side-panel-header {
            padding: 20px 24px;
            border-bottom: 1px solid #E0E0E0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .side-panel-title-wrapper {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .side-panel-title {
            font-size: 18px;
            font-weight: 600;
            color: #1F1F1F;
            margin: 0;
        }

        .side-panel-engagement-name {
            font-size: 13px;
            color: #6C757D;
            font-weight: 400;
        }

        .side-panel-close {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }

        .side-panel-close:hover {
            background: #F8F9FA;
        }

        .side-panel-close svg {
            width: 20px;
            height: 20px;
            color: #6C757D;
        }

        .side-panel-body {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .detail-group {
            margin-bottom: 20px;
        }

        .detail-label {
            font-size: 12px;
            font-weight: 500;
            color: #6C757D;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .detail-value {
            font-size: 14px;
            color: #1F1F1F;
        }

        .detail-value.editable {
            cursor: pointer;
            padding: 4px 8px;
            margin: -4px -8px;
            border-radius: 4px;
            border: 1px solid transparent;
            transition: all 0.2s ease;
        }

        .detail-value.editable:hover {
            background: #F8F9FA;
            border-color: #E0E0E0;
        }

        .detail-input {
            width: 100%;
            font-size: 14px;
            color: #1F1F1F;
            padding: 4px 8px;
            margin: -4px -8px;
            border: 1px solid #FFB800;
            border-radius: 4px;
            outline: none;
            background: #FFFEF5;
            font-family: inherit;
        }

        .detail-input:focus {
            box-shadow: 0 0 0 2px rgba(255, 184, 0, 0.2);
        }

        .detail-textarea {
            width: calc(100% + 16px);
            min-height: 60px;
            font-size: 14px;
            color: #1F1F1F;
            padding: 4px 8px;
            margin: -4px -8px;
            border: 1px solid #FFB800;
            border-radius: 4px;
            outline: none;
            background: #FFFEF5;
            font-family: inherit;
            resize: vertical;
        }

        .detail-textarea:focus {
            box-shadow: 0 0 0 2px rgba(255, 184, 0, 0.2);
        }

        .panel-contact-wrapper {
            position: relative;
        }

        .panel-contact-dropdown {
            position: absolute;
            top: 100%;
            left: -8px;
            right: -8px;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 4px;
            display: none;
        }

        .panel-contact-dropdown.open {
            display: block;
        }

        .panel-contact-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            color: #1F1F1F;
        }

        .panel-contact-item:hover,
        .panel-contact-item.highlighted {
            background: #FFF8E1;
        }

        .detail-select {
            width: 100%;
            height: 40px;
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            cursor: pointer;
            transition: border-color 0.2s ease;
        }

        .detail-select:focus {
            outline: none;
            border-color: #FFB800;
        }

        /* Responsive side panel */
        @media (max-width: 768px) {
            .side-panel {
                width: 100%;
            }
        }

        /* Autocomplete styles */
        .autocomplete-wrapper {
            position: relative;
        }

        .autocomplete-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .autocomplete-input {
            width: 100%;
            height: 48px;
            padding: 12px 40px 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .autocomplete-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .autocomplete-input::placeholder {
            color: #ADB5BD;
        }

        .autocomplete-clear {
            position: absolute;
            right: 12px;
            width: 20px;
            height: 20px;
            border: none;
            background: #E0E0E0;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease, background-color 0.2s ease;
        }

        .autocomplete-clear.visible {
            opacity: 1;
        }

        .autocomplete-clear:hover {
            background: #D0D0D0;
        }

        .autocomplete-clear svg {
            width: 12px;
            height: 12px;
            color: #6C757D;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 4px;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-height: 200px;
            overflow-y: auto;
            z-index: 10;
            display: none;
        }

        .autocomplete-dropdown.open {
            display: block;
        }

        .autocomplete-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.15s ease;
            font-size: 14px;
            color: #1F1F1F;
        }

        .autocomplete-item:hover,
        .autocomplete-item.highlighted {
            background: #F8F9FA;
        }

        .autocomplete-item-name {
            font-weight: 500;
        }

        .autocomplete-item-contact {
            font-size: 12px;
            color: #6C757D;
            margin-top: 2px;
        }

        .autocomplete-empty {
            padding: 12px 16px;
            font-size: 14px;
            color: #6C757D;
            font-style: italic;
        }

        .autocomplete-create-hint {
            padding: 8px 16px;
            font-size: 12px;
            color: #6C757D;
            background: #F8F9FA;
            border-top: 1px solid #E0E0E0;
        }

        /* Inline engagement creation form */
        .inline-eng-form {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
            background: #F8F9FA;
            border-radius: 8px;
            margin-top: 0;
            padding: 0 16px;
        }

        .inline-eng-form.open {
            max-height: 300px;
            padding: 16px;
            margin-top: 12px;
        }

        .inline-eng-form .form-group {
            margin-bottom: 12px;
        }

        .inline-eng-form .form-group:last-child {
            margin-bottom: 0;
        }

        .inline-eng-form .form-label {
            font-size: 12px;
            margin-bottom: 4px;
        }

        .inline-eng-form .form-input {
            height: 40px;
            padding: 8px 12px;
            font-size: 13px;
        }

        .inline-eng-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .inline-eng-title {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .inline-eng-actions {
            display: flex;
            gap: 8px;
        }

        .inline-eng-actions .btn {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Todo engagement badge */
        .todo-engagement {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 500;
            color: #1976D2;
            background: #E3F2FD;
            border-radius: 12px;
            margin-top: 4px;
        }

        .todo-engagement svg {
            width: 12px;
            height: 12px;
        }

        /* Engagement action buttons */
        .engagement-actions {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: 8px;
        }

        .opp-action-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease, opacity 0.2s ease;
            flex-shrink: 0;
        }

        .opp-action-btn:hover:not(:disabled) {
            background: #F0F0F0;
        }

        .opp-action-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .opp-action-btn svg {
            width: 18px;
            height: 18px;
            color: #6C757D;
            transition: color 0.2s ease;
        }

        .opp-action-btn:hover:not(:disabled) svg {
            color: #1F1F1F;
        }

        .opp-action-btn.close-btn:hover:not(:disabled) svg {
            color: #7B1FA2;
        }

        .opp-action-btn.delete-btn:hover:not(:disabled) svg {
            color: #D32F2F;
        }

        .opp-action-btn.cancel-btn:hover:not(:disabled) svg {
            color: #F57C00;
        }

        .opp-action-btn.archive-btn:hover:not(:disabled) svg {
            color: #5C6BC0;
        }

        .opp-action-btn.edit-btn:hover:not(:disabled) svg {
            color: #1976D2;
        }

        .opp-action-btn.complete-btn:hover:not(:disabled) svg {
            color: #388E3C;
        }

        .opp-action-btn.reactivate-btn:hover:not(:disabled) svg {
            color: #0288D1;
        }

        .opp-action-btn.uncancel-btn:hover:not(:disabled) svg {
            color: #0288D1;
        }

        /* Archived engagement styling */
        .engagement-item.archived {
            opacity: 0.6;
        }

        .engagement-item.archived .engagement-name {
            text-decoration: line-through;
        }

        /* Show Archived Toggle */
        .archive-toggle-container {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            margin-bottom: 16px;
            padding-right: 8px;
        }

        .archive-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 13px;
            color: #6C757D;
            user-select: none;
        }

        .archive-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #FFB800;
            cursor: pointer;
        }

        .archive-toggle:hover {
            color: #1F1F1F;
        }

        /* Confirmation modal */
        .confirm-modal-content {
            text-align: center;
        }

        .confirm-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            color: #D32F2F;
        }

        .confirm-title {
            font-size: 20px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 12px;
        }

        .confirm-message {
            font-size: 14px;
            color: #6C757D;
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .confirm-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .btn-danger {
            background: #D32F2F;
            color: #FFFFFF;
        }

        .btn-danger:hover {
            background: #B71C1C;
        }

        /* Comments section in side panel */
        .comments-section {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid #E0E0E0;
        }

        /* Comments-only mode (side panel) */
        .comments-section.comments-only {
            margin-top: 0;
            padding-top: 0;
            border-top: none;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .comments-section.comments-only .comments-list {
            flex: 1;
            overflow-y: auto;
            max-height: none;
        }

        .comments-section.comments-only .comment-input-area {
            margin-top: auto;
            padding-top: 16px;
            border-top: 1px solid #E0E0E0;
        }

        .comments-header {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 16px;
        }

        .comments-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .comment-item {
            padding: 12px;
            background: #F8F9FA;
            border-radius: 8px;
            border-left: 3px solid #E0E0E0;
            position: relative;
        }

        .comment-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .comment-delete-btn {
            background: none;
            border: none;
            color: #ADB5BD;
            cursor: pointer;
            padding: 0;
            font-size: 16px;
            line-height: 1;
            opacity: 0;
            transition: opacity 0.2s ease, color 0.2s ease;
        }

        .comment-item:hover .comment-delete-btn {
            opacity: 1;
        }

        .comment-delete-btn:hover {
            color: #D32F2F;
        }

        .comment-item.cancellation {
            background: #FFF5F5;
            border-left-color: #D32F2F;
        }

        .comment-timestamp {
            font-size: 11px;
            color: #6C757D;
            margin-bottom: 4px;
        }

        .comment-item.cancellation .comment-timestamp {
            color: #D32F2F;
        }

        .comment-text {
            font-size: 13px;
            color: #1F1F1F;
            line-height: 1.5;
        }

        .comment-item.cancellation .comment-text {
            color: #B71C1C;
        }

        .comment-badge {
            display: inline-block;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
        }

        .comment-badge.cancellation {
            background: #FFEBEE;
            color: #D32F2F;
        }

        .no-comments {
            font-size: 13px;
            color: #ADB5BD;
            font-style: italic;
        }

        /* Comment input area */
        .comment-input-area {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #E0E0E0;
        }

        .comment-textarea {
            width: 100%;
            min-height: 80px;
            padding: 10px 12px;
            font-size: 13px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            resize: vertical;
        }

        .comment-textarea:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .comment-textarea::placeholder {
            color: #ADB5BD;
        }

        .comment-submit-btn {
            margin-top: 8px;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 500;
            background: #FFB800;
            color: #1F1F1F;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .comment-submit-btn:hover {
            background: #E5A600;
        }

        .comment-submit-btn:disabled {
            background: #E0E0E0;
            color: #ADB5BD;
            cursor: not-allowed;
        }

        /* Cancel modal with textarea */
        .cancel-modal-content {
            text-align: left;
        }

        .cancel-modal-content .modal-title {
            text-align: center;
        }

        .cancel-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 16px;
            color: #F57C00;
            display: block;
        }

        .cancel-modal-content .form-group {
            margin-bottom: 20px;
        }

        .form-textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            resize: vertical;
        }

        .form-textarea:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .form-textarea::placeholder {
            color: #ADB5BD;
        }

        .btn-warning {
            background: #F57C00;
            color: #FFFFFF;
        }

        .btn-warning:hover {
            background: #E65100;
        }

        .btn-success {
            background: #388E3C;
            color: #FFFFFF;
        }

        .btn-success:hover {
            background: #2E7D32;
        }

        /* Todo Action Modal */
        .todo-action-modal-content {
            max-width: 400px;
        }

        .todo-action-buttons {
            display: flex;
            flex-direction: column;
        }

        .todo-action-buttons .btn {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* People page styles */
        .people-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .person-item {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .person-item:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
        }

        .person-info {
            flex: 1;
            min-width: 0;
        }

        .person-name {
            font-size: 15px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 4px;
        }

        .person-role {
            font-size: 13px;
            color: #6C757D;
        }

        .person-role-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 500;
            color: #6C757D;
            background: #F5F5F5;
            border-radius: 12px;
        }

        .person-actions {
            display: flex;
            gap: 4px;
        }

        /* Roles section */
        .roles-section {
            margin-top: 32px;
            padding-top: 24px;
            border-top: 1px solid #E0E0E0;
        }

        .roles-title {
            font-size: 14px;
            font-weight: 600;
            color: #6C757D;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .roles-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .role-tag {
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            font-size: 13px;
            color: #1F1F1F;
            background: #F5F5F5;
            border-radius: 16px;
        }

        /* Tags styles */
        .tags-section {
            margin-top: 32px;
            padding-top: 24px;
            border-top: 1px solid #E0E0E0;
        }

        .tags-title {
            font-size: 14px;
            font-weight: 600;
            color: #666;
            margin-bottom: 12px;
        }

        .tags-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .tag-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 12px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }

        .tag-item:hover {
            border-color: #BDBDBD;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .tag-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .tag-color-preview {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid rgba(0, 0, 0, 0.1);
        }

        .tag-name {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
        }

        .tag-actions {
            display: flex;
            gap: 4px;
        }

        /* Tag pill/chip for display in lists */
        .tag-pill {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            font-size: 11px;
            font-weight: 500;
            border-radius: 12px;
            margin-right: 4px;
            margin-bottom: 4px;
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            margin-top: 4px;
        }

        /* Color picker styles */
        .color-picker-wrapper {
            position: relative;
        }

        .color-picker-input {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #F5F5F5;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .color-picker-input:hover {
            border-color: #BDBDBD;
        }

        .color-picker-preview {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 2px solid rgba(0, 0, 0, 0.1);
        }

        .color-picker-value {
            font-size: 14px;
            color: #666;
            font-family: monospace;
        }

        .color-picker-native {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        /* Tag selector in modals */
        .tag-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px 0;
        }

        .tag-selector-item {
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            opacity: 0.6;
        }

        .tag-selector-item:hover {
            opacity: 0.8;
        }

        .tag-selector-item.selected {
            opacity: 1;
            border-color: rgba(0, 0, 0, 0.2);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .tag-selector-empty {
            font-size: 13px;
            color: #999;
            font-style: italic;
        }

        /* Tag input control for forms */
        .tag-input-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .selected-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .selected-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 12px;
            color: #fff;
        }

        .selected-tag .remove-tag {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            border: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            padding: 0;
            font-size: 10px;
            color: inherit;
            line-height: 1;
        }

        .selected-tag .remove-tag:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .tag-input-wrapper {
            position: relative;
        }

        .tag-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            font-size: 14px;
            background: #F5F5F5;
            transition: all 0.2s ease;
        }

        .tag-input:focus {
            outline: none;
            border-color: #F59E0B;
            background: #fff;
        }

        .tag-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #fff;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .tag-dropdown.open {
            display: block;
        }

        .tag-dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .tag-dropdown-item:hover,
        .tag-dropdown-item.highlighted {
            background: #F5F5F5;
        }

        .tag-dropdown-item .tag-color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .tag-dropdown-item.create-new {
            border-top: 1px solid #E0E0E0;
            color: #F59E0B;
            font-weight: 500;
        }

        .tag-dropdown-item.create-new .tag-color-dot {
            background: #F59E0B;
        }

        /* Inline person creation form */
        .inline-person-form {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
            background: #F8F9FA;
            border-radius: 8px;
            margin-top: 0;
            padding: 0 16px;
        }

        .inline-person-form.open {
            max-height: 200px;
            padding: 16px;
            margin-top: 12px;
        }

        .inline-person-form .form-group {
            margin-bottom: 12px;
        }

        .inline-person-form .form-group:last-child {
            margin-bottom: 0;
        }

        .inline-person-form .form-label {
            font-size: 12px;
            margin-bottom: 4px;
        }

        .inline-person-form .form-input {
            height: 40px;
            padding: 8px 12px;
            font-size: 13px;
        }

        .inline-person-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .inline-person-title {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .inline-person-actions {
            display: flex;
            gap: 8px;
        }

        .inline-person-actions .btn {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Contact badge in engagement list */
        .eng-contact-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            font-size: 11px;
            font-weight: 500;
            color: #1976D2;
            background: #E3F2FD;
            border-radius: 12px;
        }

        /* Settings page layout */
        #settings-page {
            background: #F5F5F5;
        }

        .settings-container {
            display: flex;
            min-height: calc(100vh - 60px);
            margin-top: 60px;
        }

        .settings-menu {
            width: 20%;
            background: #FFFFFF;
            border-right: 1px solid #E0E0E0;
            padding: 24px 0;
        }

        .settings-menu-title {
            font-size: 14px;
            font-weight: 600;
            color: #6C757D;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 0 24px;
            margin-bottom: 16px;
        }

        .settings-menu-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .settings-menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 24px;
            font-size: 15px;
            font-weight: 500;
            color: #1F1F1F;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .settings-menu-item:hover {
            background: #F8F9FA;
        }

        .settings-menu-item.active {
            background: #FFF8E1;
            border-left-color: #FFB800;
            color: #1F1F1F;
        }

        .settings-menu-item svg {
            width: 24px;
            height: 24px;
            color: #6C757D;
            flex-shrink: 0;
        }

        .settings-menu-item.active svg {
            color: #FFB800;
        }

        .settings-content {
            width: 80%;
            position: relative;
            padding: 24px;
            overflow-y: auto;
        }

        .settings-close-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: #FFFFFF;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .settings-close-btn:hover {
            background: #F8F9FA;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .settings-close-btn svg {
            width: 24px;
            height: 24px;
            color: #6C757D;
        }

        .settings-close-btn:hover svg {
            color: #1F1F1F;
        }

        .settings-section-title {
            font-size: 24px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 24px;
        }

        /* Responsive settings */
        @media (max-width: 768px) {
            .settings-container {
                flex-direction: column;
            }

            .settings-menu {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #E0E0E0;
                padding: 16px 0;
            }

            .settings-content {
                width: 100%;
            }
        }

        /* ========================================
           RECOMMENDATION ENGINE STYLES
           ======================================== */

        /* Split-panel layout for Todos page */
        .home-split-container {
            display: flex;
            gap: 24px;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Recommendation Panel (Left) */
        .recommendation-panel {
            width: 450px;
            min-width: 450px;
            background: #FFFFFF;
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        /* Todo Panel (Right) */
        .todo-panel {
            flex: 1;
            min-width: 0;
        }

        /* Recommendation Header */
        .recommendation-header {
            position: relative;
            padding: 20px;
            border-bottom: 1px solid #E0E0E0;
            background: linear-gradient(135deg, #FFF8E1 0%, #FFFFFF 100%);
        }

        .recommendation-date {
            font-size: 18px;
            font-weight: 600;
            color: #1F1F1F;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .recommendation-date-icon {
            font-size: 20px;
        }

        .recommendation-summary {
            font-size: 13px;
            color: #6C757D;
        }

        /* Recommendation Content */
        .recommendation-content {
            padding: 16px;
        }

        /* Recommendation Section */
        .recommendation-section {
            margin-bottom: 20px;
        }

        .recommendation-section:last-child {
            margin-bottom: 0;
        }

        .recommendation-section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #6C757D;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #F0F0F0;
        }

        .recommendation-section-icon {
            font-size: 14px;
        }

        .recommendation-section-count {
            background: #E9ECEF;
            color: #6C757D;
            font-size: 11px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: auto;
        }

        /* Section-specific colors */
        .recommendation-section.overdue .recommendation-section-header {
            color: #DC3545;
        }

        .recommendation-section.overdue .recommendation-section-count {
            background: #FFEBEE;
            color: #DC3545;
        }

        .recommendation-section.must-do .recommendation-section-header {
            color: #F57C00;
        }

        .recommendation-section.must-do .recommendation-section-count {
            background: #FFF3E0;
            color: #F57C00;
        }

        .recommendation-section.recommended .recommendation-section-header {
            color: #1976D2;
        }

        .recommendation-section.recommended .recommendation-section-count {
            background: #E3F2FD;
            color: #1976D2;
        }

        .recommendation-section.if-time .recommendation-section-header {
            color: #6C757D;
        }

        /* Recommendation Item */
        .recommendation-item {
            background: #F8F9FA;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .recommendation-item:last-child {
            margin-bottom: 0;
        }

        .recommendation-item:hover {
            background: #FFFFFF;
            border-color: #E0E0E0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .recommendation-item-header {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 8px;
        }

        .recommendation-item-checkbox {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #D0D0D0;
            flex-shrink: 0;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 2px;
        }

        .recommendation-item-checkbox:hover {
            border-color: #FFB800;
        }

        .recommendation-item-checkbox.checked {
            background: #00A86B;
            border-color: #00A86B;
        }

        .recommendation-item-title {
            flex: 1;
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            line-height: 1.4;
        }

        .recommendation-item.completed .recommendation-item-title {
            text-decoration: line-through;
            color: #ADB5BD;
        }

        .recommendation-item-meta {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 12px;
            color: #6C757D;
            margin-bottom: 8px;
            margin-left: 30px;
        }

        .recommendation-item-effort,
        .recommendation-item-deadline {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Tag pills in recommendation */
        .recommendation-item-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-left: 30px;
            margin-bottom: 8px;
        }

        /* Priority pill styling (distinct from user tags) */
        .priority-pill {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 10px;
            font-size: 11px;
            font-weight: 600;
            border-radius: 12px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .priority-pill.priority-urgent {
            background: #FFEBEE;
            color: #C62828;
        }

        .priority-pill.priority-high {
            background: #FFF3E0;
            color: #E65100;
        }

        .priority-pill.priority-normal {
            background: #E3F2FD;
            color: #1565C0;
        }

        .priority-pill.priority-low {
            background: #F5F5F5;
            color: #616161;
        }

        .priority-pill.priority-someday {
            background: #FAFAFA;
            color: #9E9E9E;
        }

        /* Reasoning text */
        .recommendation-item-reasoning {
            font-size: 12px;
            color: #6C757D;
            font-style: italic;
            margin-left: 30px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .recommendation-item-reasoning::before {
            content: '\2192';
            color: #ADB5BD;
        }

        /* Score display */
        .recommendation-item-score {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            margin-left: 30px;
            margin-top: 8px;
        }

        .score-badge {
            font-size: 11px;
            font-weight: 600;
            color: #6C757D;
            background: #E9ECEF;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .score-badge.critical {
            background: #FFEBEE;
            color: #C62828;
        }

        .score-badge.high {
            background: #FFF3E0;
            color: #E65100;
        }

        .score-badge.medium {
            background: #E3F2FD;
            color: #1565C0;
        }

        /* Warning Card */
        .warning-card {
            background: #FFF3E0;
            border: 1px solid #FFE0B2;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 12px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .warning-card.critical {
            background: #FFEBEE;
            border-color: #FFCDD2;
        }

        .warning-icon {
            font-size: 16px;
            flex-shrink: 0;
        }

        .warning-message {
            font-size: 13px;
            color: #5D4037;
            line-height: 1.4;
        }

        .warning-card.critical .warning-message {
            color: #B71C1C;
        }

        /* Insight Card */
        .insight-card {
            background: #E8F5E9;
            border: 1px solid #C8E6C9;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 12px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .insight-icon {
            font-size: 16px;
            flex-shrink: 0;
        }

        .insight-message {
            font-size: 13px;
            color: #2E7D32;
            line-height: 1.4;
        }

        /* Warnings section */
        .warnings-section {
            margin-bottom: 16px;
        }

        /* Insights section */
        .insights-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #E0E0E0;
        }

        .insights-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #2E7D32;
            margin-bottom: 12px;
        }

        /* Empty recommendation state */
        .recommendation-empty {
            text-align: center;
            padding: 40px 20px;
            color: #6C757D;
        }

        .recommendation-empty-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .recommendation-empty-text {
            font-size: 14px;
        }

        /* Effort dropdown styles */
        .effort-select {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            cursor: pointer;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236C757D' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 16px center;
        }

        .effort-select:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        /* Priority autocomplete styles */
        .priority-autocomplete-wrapper {
            position: relative;
        }

        .priority-input {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .priority-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .priority-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .priority-dropdown.open {
            display: block;
        }

        .priority-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }

        .priority-option:hover,
        .priority-option.highlighted {
            background: #F8F9FA;
        }

        .priority-option.selected {
            background: #FFF8E1;
        }

        .priority-option-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .priority-option-label {
            font-size: 14px;
            color: #1F1F1F;
        }

        .priority-option-desc {
            font-size: 12px;
            color: #6C757D;
            margin-left: auto;
        }

        /* Datetime input styles */
        .datetime-input {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .datetime-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        /* Description textarea */
        .form-textarea {
            width: 100%;
            min-height: 80px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
            resize: vertical;
        }

        .form-textarea:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .form-textarea::placeholder {
            color: #ADB5BD;
        }

        /* Effort display in todo list */
        .todo-effort {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            color: #6C757D;
            background: #F5F5F5;
            padding: 2px 8px;
            border-radius: 10px;
            margin-right: 8px;
        }

        .todo-effort-icon {
            font-size: 10px;
        }

        /* Priority display in todo list */
        .todo-priority {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 10px;
            margin-right: 8px;
        }

        /* Planning settings section */
        .planning-settings-form {
            max-width: 500px;
        }

        .planning-settings-form .form-group {
            margin-bottom: 20px;
        }

        .planning-settings-form .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 6px;
        }

        .planning-settings-form .form-hint {
            font-size: 12px;
            color: #6C757D;
            margin-top: 4px;
        }

        .planning-settings-form .form-input {
            max-width: 200px;
        }

        .planning-settings-form .btn-save-settings {
            margin-top: 24px;
        }

        /* Responsive split-panel */
        @media (max-width: 1024px) {
            .home-split-container {
                flex-direction: column;
            }

            .recommendation-panel {
                width: 100%;
                min-width: 100%;
                margin-bottom: 24px;
            }

            .todo-panel {
                width: 100%;
            }
        }

        /* Engagement Lifecycle Styles */
        .engagement-type-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .type-engagement {
            background: #FFF7ED;
            color: #EA580C;
        }

        .type-pre-project {
            background: #FEF3C7;
            color: #B45309;
        }

        .type-project {
            background: #DCFCE7;
            color: #16A34A;
        }

        /* Lifecycle section in side panel */
        .lifecycle-section {
            margin-top: 16px;
            padding: 16px;
            background: #F8F9FA;
            border-radius: 8px;
            border: 1px solid #E0E0E0;
        }

        .lifecycle-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .lifecycle-title {
            font-size: 14px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .lifecycle-actions {
            display: flex;
            gap: 8px;
        }

        .lifecycle-action-btn {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.15s ease;
        }

        .lifecycle-action-btn.promote {
            background: #FFB800;
            color: #1F1F1F;
        }

        .lifecycle-action-btn.promote:hover {
            background: #E5A600;
        }

        .lifecycle-action-btn.secondary {
            background: #FFFFFF;
            color: #6C757D;
            border-color: #DEE2E6;
        }

        .lifecycle-action-btn.secondary:hover {
            background: #F8F9FA;
        }

        .lifecycle-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Pre-Project Section */
        .pre-project-section {
            margin-top: 16px;
        }

        .pre-project-dates {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }

        .pre-project-date-field {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .pre-project-date-label {
            font-size: 11px;
            font-weight: 500;
            color: #6C757D;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .pre-project-date-input {
            padding: 8px 10px;
            border: 1px solid #DEE2E6;
            border-radius: 6px;
            font-size: 13px;
            color: #1F1F1F;
        }

        .pre-project-date-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 2px rgba(255, 184, 0, 0.15);
        }

        /* Allocations Table */
        .allocations-section {
            margin-top: 16px;
        }

        .allocations-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .allocations-title {
            font-size: 13px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .add-allocation-btn {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            background: #FFB800;
            color: #1F1F1F;
            border: none;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .add-allocation-btn:hover {
            background: #E5A600;
        }

        .allocations-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .allocations-table th {
            text-align: left;
            padding: 8px 6px;
            background: #E9ECEF;
            color: #495057;
            font-weight: 600;
            border-bottom: 1px solid #DEE2E6;
        }

        .allocations-table td {
            padding: 8px 6px;
            border-bottom: 1px solid #E9ECEF;
            vertical-align: middle;
        }

        .allocations-table input,
        .allocations-table select {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #DEE2E6;
            border-radius: 4px;
            font-size: 12px;
        }

        .allocations-table input:focus,
        .allocations-table select:focus {
            outline: none;
            border-color: #FFB800;
        }

        .allocation-delete-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: transparent;
            color: #DC3545;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .allocation-delete-btn:hover {
            background: #FEE2E2;
        }

        .allocation-charged-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            background: #D1FAE5;
            color: #065F46;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
        }

        .allocation-pending-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            background: #FEF3C7;
            color: #92400E;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
        }

        /* Allocation Summary */
        .allocation-summary {
            margin-top: 12px;
            padding: 12px;
            background: #FFFFFF;
            border-radius: 6px;
            border: 1px solid #E0E0E0;
        }

        .allocation-summary-row {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            padding: 4px 0;
        }

        .allocation-summary-label {
            color: #6C757D;
        }

        .allocation-summary-value {
            font-weight: 600;
            color: #1F1F1F;
        }

        /* Project Section */
        .project-section {
            margin-top: 16px;
        }

        .project-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }

        .project-field {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .project-field.full-width {
            grid-column: 1 / -1;
        }

        .project-field-label {
            font-size: 11px;
            font-weight: 500;
            color: #6C757D;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .project-field-input {
            padding: 8px 10px;
            border: 1px solid #DEE2E6;
            border-radius: 6px;
            font-size: 13px;
            color: #1F1F1F;
        }

        .project-field-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 2px rgba(255, 184, 0, 0.15);
        }

        /* Timeline Section */
        .timeline-section {
            margin-top: 16px;
            padding: 12px;
            background: #FFFFFF;
            border-radius: 6px;
            border: 1px solid #E0E0E0;
        }

        .timeline-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .timeline-title {
            font-size: 13px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .timeline-dates {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        /* Charge-Back Section */
        .chargeback-section {
            margin-top: 16px;
            padding: 12px;
            background: #FEF3C7;
            border-radius: 6px;
            border: 1px solid #F59E0B;
        }

        .chargeback-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .chargeback-title {
            font-size: 13px;
            font-weight: 600;
            color: #92400E;
        }

        .chargeback-summary {
            font-size: 12px;
            color: #78350F;
        }

        .chargeback-list {
            margin-top: 8px;
        }

        .chargeback-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid rgba(245, 158, 11, 0.3);
            font-size: 12px;
        }

        .chargeback-item:last-child {
            border-bottom: none;
        }

        /* Promote to Pre-Project Modal */
        .promote-modal-content {
            max-width: 500px;
            overflow: visible;
            max-height: none;
        }

        .promote-form-group {
            margin-bottom: 16px;
        }

        .promote-form-label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: #1F1F1F;
            margin-bottom: 6px;
        }

        .promote-form-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #DEE2E6;
            border-radius: 6px;
            font-size: 14px;
            color: #1F1F1F;
        }

        .promote-form-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 2px rgba(255, 184, 0, 0.15);
        }

        /* Charge-Back Mode Selection */
        .chargeback-mode-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }

        .chargeback-mode-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border: 1px solid #DEE2E6;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .chargeback-mode-option:hover {
            border-color: #FFB800;
        }

        .chargeback-mode-option.selected {
            border-color: #FFB800;
            background: #FFFBEB;
        }

        .chargeback-mode-option input[type="radio"] {
            margin: 0;
        }

        .chargeback-mode-label {
            flex: 1;
        }

        .chargeback-mode-title {
            font-size: 13px;
            font-weight: 500;
            color: #1F1F1F;
        }

        .chargeback-mode-desc {
            font-size: 11px;
            color: #6C757D;
            margin-top: 2px;
        }

        /* Unified Promotion Modal (Issue-57) */
        .unified-promote-modal {
            max-width: 700px;
            overflow: visible;
            max-height: 90vh;
            overflow-y: auto;
        }

        .unified-promote-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .unified-promote-title {
            font-size: 18px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .unified-promote-close {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            color: #6C757D;
        }

        .unified-promote-close:hover {
            color: #1F1F1F;
        }

        .allocation-section {
            margin-bottom: 20px;
        }

        .allocation-section-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 0;
            cursor: pointer;
        }

        .allocation-section-toggle {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #D1D5DB;
            background: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .allocation-section-toggle.enabled {
            border-color: #22C55E;
            background: #22C55E;
        }

        .allocation-section-toggle.enabled::after {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #fff;
        }

        .allocation-section-title {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            flex: 1;
        }

        .allocation-section-link {
            color: #6C757D;
            text-decoration: none;
        }

        .allocation-section-link:hover {
            color: #1F1F1F;
        }

        .allocation-section-content {
            display: none;
            padding: 16px;
            border: 1px solid #E5E7EB;
            border-radius: 8px;
            margin-top: 8px;
            overflow: hidden;
            max-height: 0;
            opacity: 0;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, padding 0.3s ease-out;
        }

        .allocation-section.expanded .allocation-section-content {
            display: block;
            max-height: 300px;
            opacity: 1;
            padding: 16px;
        }

        .allocation-input-row {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 16px;
        }

        .allocation-input-label {
            font-size: 13px;
            color: #374151;
            min-width: 150px;
        }

        .allocation-input {
            width: 80px;
            padding: 8px 12px;
            border: 1px solid #E5E7EB;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
        }

        .allocation-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 2px rgba(255, 184, 0, 0.15);
        }

        .allocation-months-label {
            font-size: 13px;
            color: #374151;
            margin-bottom: 12px;
        }

        /* Month Timeline */
        .month-timeline-container {
            position: relative;
            overflow: hidden;
        }

        .month-timeline-nav {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .month-timeline-arrow {
            width: 28px;
            height: 28px;
            border: 1px solid #E5E7EB;
            border-radius: 4px;
            background: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6C757D;
            flex-shrink: 0;
        }

        .month-timeline-arrow:hover {
            border-color: #D1D5DB;
            color: #374151;
        }

        .month-timeline-arrow:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .month-timeline-scroll {
            flex: 1;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .month-timeline-scroll::-webkit-scrollbar {
            display: none;
        }

        .month-timeline-years {
            display: flex;
            margin-bottom: 4px;
        }

        .month-timeline-year {
            font-size: 12px;
            color: #9CA3AF;
            text-align: center;
            flex-shrink: 0;
        }

        .month-timeline-months {
            display: flex;
            gap: 4px;
        }

        .month-timeline-month {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.15s ease;
            border: 1px solid transparent;
            background: #F9FAFB;
            color: #374151;
            flex-shrink: 0;
        }

        .month-timeline-month:hover:not(.disabled):not(.selected) {
            background: #F3F4F6;
            border-color: #D1D5DB;
        }

        .month-timeline-month.selected.preproject {
            background: #3B82F6;
            color: #fff;
            border-color: #3B82F6;
        }

        .month-timeline-month.selected.project {
            background: #22C55E;
            color: #fff;
            border-color: #22C55E;
        }

        .month-timeline-month.disabled {
            background: #F3F4F6;
            color: #D1D5DB;
            cursor: not-allowed;
        }

        /* Modal Footer */
        .unified-promote-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 24px;
            padding-top: 16px;
            border-top: 1px solid #E5E7EB;
        }

        .unified-promote-footer .btn-save {
            background: #EAB308;
            color: #1F1F1F;
            border: none;
            padding: 10px 24px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
        }

        .unified-promote-footer .btn-save:hover {
            background: #CA8A04;
        }

        .unified-promote-footer .btn-save:disabled {
            background: #FEF3C7;
            color: #A3A3A3;
            cursor: not-allowed;
        }

        /* Allocations Report View */
        .allocations-report {
            padding: 20px;
        }

        .allocations-report-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .allocations-report-title {
            font-size: 18px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .month-selector {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .month-nav-btn {
            width: 32px;
            height: 32px;
            border: 1px solid #DEE2E6;
            border-radius: 6px;
            background: #FFFFFF;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #495057;
        }

        .month-nav-btn:hover {
            background: #F8F9FA;
        }

        .month-display {
            font-size: 14px;
            font-weight: 500;
            color: #1F1F1F;
            min-width: 120px;
            text-align: center;
        }

        .allocations-report-table {
            width: 100%;
            border-collapse: collapse;
            background: #FFFFFF;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .allocations-report-table th {
            text-align: left;
            padding: 12px 16px;
            background: #F8F9FA;
            color: #495057;
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #DEE2E6;
        }

        .allocations-report-table td {
            padding: 12px 16px;
            border-bottom: 1px solid #E9ECEF;
            font-size: 13px;
        }

        .allocations-report-table tr:last-child td {
            border-bottom: none;
        }

        .allocation-total-row {
            background: #F8F9FA;
            font-weight: 600;
        }

        .allocation-warning {
            color: #DC3545;
        }

        /* Engagement Timeline View */
        .engagement-timeline {
            margin-top: 16px;
        }

        .timeline-phase {
            position: relative;
            padding-left: 24px;
            margin-bottom: 16px;
        }

        .timeline-phase::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 24px;
            bottom: 0;
            width: 2px;
            background: #DEE2E6;
        }

        .timeline-phase:last-child::before {
            display: none;
        }

        .timeline-phase-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .timeline-phase-dot {
            position: absolute;
            left: 4px;
            top: 4px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #FFB800;
        }

        .timeline-phase-dot.pre-project {
            background: #F59E0B;
        }

        .timeline-phase-dot.project {
            background: #10B981;
        }

        .timeline-phase-title {
            font-size: 13px;
            font-weight: 600;
            color: #1F1F1F;
        }

        .timeline-phase-period {
            font-size: 11px;
            color: #6C757D;
        }

        .timeline-month {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
            font-size: 12px;
        }

        .timeline-month-label {
            width: 70px;
            color: #495057;
        }

        .timeline-month-percent {
            font-weight: 600;
            color: #1F1F1F;
        }

        .timeline-month-status {
            font-size: 10px;
        }

        /* Type selector in modal */
        .type-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .type-option {
            flex: 1;
            padding: 12px;
            border: 2px solid #DEE2E6;
            border-radius: 8px;
            background: #FFFFFF;
            cursor: pointer;
            text-align: center;
            transition: all 0.15s ease;
        }

        .type-option:hover {
            border-color: #FFB800;
        }

        .type-option.selected {
            border-color: #FFB800;
            background: #FFFBEB;
        }

        .type-option-icon {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .type-option-label {
            font-size: 12px;
            font-weight: 500;
            color: #1F1F1F;
        }

        /* Status badges for new lifecycle */
        .status-badge.status-active {
            background: #D1FAE5;
            color: #065F46;
        }

        .status-badge.status-completed {
            background: #DBEAFE;
            color: #1E40AF;
        }

        .status-badge.status-dropped {
            background: #FEE2E2;
            color: #991B1B;
        }

        .status-badge.status-closed {
            background: #E5E7EB;
            color: #374151;
        }

        .status-badge.status-paused {
            background: #FEF3C7;
            color: #92400E;
        }

        /* Status tooltip container */
        .status-tooltip-container {
            position: relative;
            display: inline-block;
        }

        /* Side panel tooltip aligns left to fit within panel */
        .side-panel-body .status-tooltip {
            left: 0;
            transform: none;
        }

        .side-panel-body .status-tooltip::after {
            left: 24px;
            transform: none;
        }

        .status-tooltip {
            position: absolute;
            top: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: #1F2937;
            color: #F9FAFB;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.5;
            width: 280px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 1000;
            pointer-events: none;
        }

        .status-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-bottom-color: #1F2937;
        }

        .status-tooltip-container:hover .status-tooltip,
        .status-tooltip-container .status-tooltip.expanded {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .status-tooltip-header {
            font-weight: 600;
            margin-bottom: 8px;
            color: #F9FAFB;
        }

        .status-tooltip-brief {
            color: #D1D5DB;
            margin-bottom: 8px;
        }

        .status-tooltip-link {
            color: #60A5FA;
            cursor: pointer;
            font-size: 12px;
            display: inline-block;
        }

        .status-tooltip-link:hover {
            text-decoration: underline;
        }

        .status-tooltip-expanded {
            display: none;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #374151;
        }

        .status-tooltip.expanded .status-tooltip-expanded {
            display: block;
        }

        .status-tooltip.expanded .status-tooltip-link {
            display: none;
        }

        .status-item {
            margin-bottom: 10px;
        }

        .status-item:last-child {
            margin-bottom: 0;
        }

        .status-item-name {
            font-weight: 600;
            color: #F9FAFB;
            margin-bottom: 2px;
        }

        .status-item-desc {
            font-size: 12px;
            color: #9CA3AF;
        }

        /* Engagement item type indicator */
        .engagement-type-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }

        .engagement-type-icon {
            width: 16px;
            height: 16px;
        }

        .engagement-type-icon.engagement-type {
            color: #0369A1;
        }

        .engagement-type-icon.pre-project-type {
            color: #92400E;
        }

        .engagement-type-icon.project-type {
            color: #065F46;
        }

        /* =============================================
           DateTimePicker Component Styles
           ============================================= */

        /* Input wrapper */
        .dtp-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .dtp-display-input {
            width: 100%;
            height: 48px;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            background: #FFFFFF;
            color: #1F1F1F;
            cursor: pointer;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: inherit;
        }

        .dtp-display-input:hover {
            border-color: #FFB800;
        }

        .dtp-display-input:focus {
            outline: none;
            border-color: #FFB800;
            box-shadow: 0 0 0 3px rgba(255, 184, 0, 0.2);
        }

        .dtp-display-input::placeholder {
            color: #ADB5BD;
        }

        .dtp-calendar-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 16px;
            cursor: pointer;
            color: #666666;
            transition: color 0.2s ease;
        }

        .dtp-calendar-icon:hover {
            color: #FFB800;
        }

        /* Picker container */
        .dtp-picker {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            z-index: 1000;
            width: 420px;
            background: #FFFFFF;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px) scale(0.98);
            transition: opacity 150ms ease-out, transform 150ms ease-out, visibility 150ms;
        }

        .dtp-picker.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }

        /* Position picker above input when insufficient space below */
        .dtp-picker.above {
            top: auto;
            bottom: calc(100% + 4px);
            transform: translateY(8px) scale(0.98);
        }

        .dtp-picker.above.open {
            transform: translateY(0) scale(1);
        }

        /* Picker header */
        .dtp-header {
            padding: 12px 16px;
            border-bottom: 1px solid #E0E0E0;
            font-size: 14px;
            font-weight: 600;
            color: #333333;
        }

        /* Picker body - side by side layout */
        .dtp-body {
            display: flex;
            padding: 16px;
            gap: 16px;
        }

        /* Date-only mode - calendar only, narrower picker */
        .dtp-body.dtp-date-only {
            justify-content: center;
        }

        .dtp-body.dtp-date-only .dtp-calendar-panel {
            width: 100%;
        }

        .dtp-body.dtp-date-only + .dtp-footer {
            justify-content: center;
        }

        /* Date-only picker is narrower */
        .dtp-picker:has(.dtp-date-only) {
            width: 280px;
        }

        /* Time panel (left side) */
        .dtp-time-panel {
            display: flex;
            flex-direction: column;
            width: 120px;
            flex-shrink: 0;
            align-items: center;
            justify-content: center;
            border-right: 1px solid #E8E8E8;
            padding-right: 16px;
        }

        .dtp-date-display {
            font-size: 12px;
            color: #888888;
            margin-bottom: 8px;
            text-align: center;
        }

        /* Time spinners container - horizontal layout */
        .dtp-time-spinners {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0;
        }

        /* Individual spinner - vertical layout (â–², value, â–¼) */
        .dtp-spinner {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        /* Spinner buttons - subtle, borderless arrows */
        .dtp-spinner-btn {
            width: 40px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            cursor: pointer;
            color: #999999;
            font-size: 10px;
            transition: color 80ms ease;
        }

        .dtp-spinner-btn:hover {
            color: #F5A623;
        }

        .dtp-spinner-btn:active {
            color: #D4920F;
        }

        /* Time input - large, clean, borderless */
        .dtp-time-input {
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 36px;
            font-weight: 300;
            color: #333333;
            width: 52px;
            text-align: center;
            padding: 4px 0;
            border: none;
            border-radius: 4px;
            background: transparent;
            cursor: pointer;
            transition: background 80ms ease;
        }

        .dtp-time-input:hover {
            background: #FEF7E6;
        }

        .dtp-time-input:focus {
            outline: none;
            background: #FEF7E6;
            color: #F5A623;
        }

        /* Time separator colon */
        .dtp-time-separator {
            font-size: 36px;
            font-weight: 300;
            color: #333333;
            padding: 0 2px;
            align-self: center;
        }

        /* Calendar panel (right side) */
        .dtp-calendar-panel {
            flex: 1;
            min-width: 0;
        }

        /* Calendar header with month/year navigation */
        .dtp-calendar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .dtp-nav-btn {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: 1px solid #E0E0E0;
            border-radius: 4px;
            cursor: pointer;
            color: #666666;
            transition: all 80ms ease;
        }

        .dtp-nav-btn:hover {
            background: #FEF7E6;
            border-color: #F5A623;
            color: #F5A623;
        }

        .dtp-month-year {
            display: flex;
            gap: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #333333;
        }

        .dtp-month-label,
        .dtp-year-label {
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 80ms ease;
        }

        .dtp-month-label:hover,
        .dtp-year-label:hover {
            background: #FEF7E6;
        }

        /* Day headers container - grid aligned with calendar */
        .dtp-day-headers {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            margin-bottom: 4px;
        }

        /* Individual day header */
        .dtp-day-header {
            font-size: 11px;
            font-weight: 600;
            color: #888888;
            text-align: center;
            padding: 4px 0;
            width: 32px;
            justify-self: center;
        }

        /* Calendar grid */
        .dtp-calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            outline: none;
            border: none;
        }

        .dtp-calendar-grid:focus {
            outline: none;
        }

        .dtp-day {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            color: #333333;
            border-radius: 50%;
            cursor: pointer;
            transition: all 80ms ease;
            border: 2px solid transparent;
        }

        .dtp-day:hover {
            background: #FEF7E6;
            transform: scale(1.05);
        }

        .dtp-day.other-month {
            color: #999999;
        }

        .dtp-day.today {
            background: #FFF3CD;
            border-color: #F5A623;
        }

        .dtp-day.selected {
            background: #F5A623;
            color: #FFFFFF;
            border-color: #F5A623;
        }

        .dtp-day.focused {
            box-shadow: 0 0 0 2px #F5A623;
        }

        .dtp-day.disabled {
            color: #CCCCCC;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Month picker overlay */
        .dtp-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #FFFFFF;
            border-radius: 8px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-4px);
            transition: all 100ms ease-out;
            z-index: 10;
        }

        .dtp-overlay.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .dtp-overlay-header {
            padding: 12px 16px;
            border-bottom: 1px solid #E0E0E0;
            font-size: 14px;
            font-weight: 600;
            color: #333333;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .dtp-overlay-close {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            cursor: pointer;
            color: #666666;
            border-radius: 4px;
        }

        .dtp-overlay-close:hover {
            background: #FEF7E6;
            color: #F5A623;
        }

        .dtp-overlay-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            padding: 16px;
        }

        .dtp-overlay-item {
            padding: 12px 8px;
            text-align: center;
            font-size: 13px;
            color: #333333;
            border-radius: 4px;
            cursor: pointer;
            transition: all 80ms ease;
            border: 2px solid transparent;
        }

        .dtp-overlay-item:hover {
            background: #FEF7E6;
            transform: scale(1.05);
        }

        .dtp-overlay-item.current {
            border-color: #F5A623;
        }

        .dtp-overlay-item.selected {
            background: #F5A623;
            color: #FFFFFF;
        }

        .dtp-overlay-item.focused {
            box-shadow: 0 0 0 2px #F5A623;
        }

        /* Footer with Select button */
        .dtp-footer {
            padding: 12px 16px;
            border-top: 1px solid #E0E0E0;
            display: flex;
            justify-content: flex-start;
        }

        .dtp-select-btn {
            width: 100px;
            height: 36px;
            background: #F5A623;
            color: #FFFFFF;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 80ms ease;
        }

        .dtp-select-btn:hover {
            background: #D4920F;
        }

        .dtp-select-btn:active {
            background: #B87D0A;
        }

        .dtp-select-btn:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(245, 166, 35, 0.3);
        }

        /* Screen reader only */
        .dtp-sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Responsive - stacked layout for mobile */
        @media (max-width: 767px) {
            .dtp-picker {
                width: 100%;
                max-width: 320px;
            }

            .dtp-body {
                flex-direction: column;
            }

            .dtp-time-panel {
                width: 100%;
                flex-direction: row;
                align-items: center;
                justify-content: space-between;
            }

            .dtp-date-display {
                margin-bottom: 0;
            }

            .dtp-day {
                width: 40px;
                height: 40px;
            }
        }
    </style>
</head>
<body>
    <!-- Landing Page -->
    <div id="landing-page" class="container">
        <div class="logo-container">
            <svg class="logo" viewBox="0 0 120 120" fill="none" xmlns="http://www.w3.org/2000/svg">
                <!-- Clipboard background -->
                <rect x="20" y="15" width="80" height="95" rx="8" fill="#FFB800"/>
                <rect x="25" y="20" width="70" height="85" rx="6" fill="#FFFFFF"/>

                <!-- Clipboard clip -->
                <path d="M45 10 H75 C78 10 80 12 80 15 V20 H40 V15 C40 12 42 10 45 10 Z" fill="#FFB800"/>
                <rect x="48" y="5" width="24" height="12" rx="3" fill="#1F1F1F"/>

                <!-- Checkmark items -->
                <g opacity="0.9">
                    <!-- First item - checked -->
                    <circle cx="35" cy="38" r="5" fill="#00A86B"/>
                    <path d="M33 38 L34.5 39.5 L37.5 36.5" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <rect x="45" y="36" width="45" height="4" rx="2" fill="#E0E0E0"/>

                    <!-- Second item - checked -->
                    <circle cx="35" cy="55" r="5" fill="#00A86B"/>
                    <path d="M33 55 L34.5 56.5 L37.5 53.5" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <rect x="45" y="53" width="35" height="4" rx="2" fill="#E0E0E0"/>

                    <!-- Third item - unchecked -->
                    <circle cx="35" cy="72" r="5" fill="#E0E0E0"/>
                    <rect x="45" y="70" width="40" height="4" rx="2" fill="#E0E0E0"/>

                    <!-- Fourth item - unchecked -->
                    <circle cx="35" cy="89" r="5" fill="#E0E0E0"/>
                    <rect x="45" y="87" width="30" height="4" rx="2" fill="#E0E0E0"/>
                </g>
            </svg>
            <h1>TodoManager</h1>
            <p class="tagline">Organize your tasks, achieve your goals</p>
        </div>

        <div class="options-container">
            <div class="option-card" onclick="startFromScratch()">
                <div class="option-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </div>
                <h2 class="option-title">Start from Scratch</h2>
                <p class="option-description">Begin fresh with a clean workspace and create your first task list</p>
            </div>

            <div class="option-card" onclick="continueWorking()">
                <div class="option-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 11l3 3L22 4"></path>
                        <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"></path>
                    </svg>
                </div>
                <h2 class="option-title">Continue Working</h2>
                <p class="option-description">Pick up where you left off and manage your existing tasks</p>
            </div>
        </div>

        <div class="footer">
            <p>&copy; 2025 TodoManager. Built with care.</p>
        </div>
    </div>

    <!-- Hidden file input for importing state -->
    <input type="file" id="import-file-input" accept=".json" style="display: none;" onchange="importData(event)">

    <!-- App Header (shared across pages) -->
    <header id="app-header" class="header hidden">
        <div class="header-left">
            <nav class="tab-nav">
                <button id="tab-home" class="tab-btn active" onclick="switchTab('home')">Todo's</button>
                <button id="tab-engagements" class="tab-btn" onclick="switchTab('engagements')">Engagements</button>
            </nav>
        </div>
        <div class="header-actions">
            <button class="icon-button" onclick="openSettings()" title="Settings">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="3"></circle>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                </svg>
            </button>
            <button class="icon-button" onclick="exportData()" title="Export">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
            </button>
        </div>
    </header>

    <!-- Home Page -->
    <div id="home-page" class="page hidden">

        <!-- Main Content -->
        <main class="main-content">
            <!-- Split Container -->
            <div class="home-split-container">
                <!-- Recommendation Panel (Left) -->
                <div id="recommendation-panel" class="recommendation-panel">
                    <!-- Panel Header -->
                    <div class="recommendation-header">
                        <div class="recommendation-date">
                            <span class="recommendation-date-icon">ðŸ“…</span>
                            <span id="recommendation-date-text">Daily Plan</span>
                        </div>
                        <div id="recommendation-summary" class="recommendation-summary"></div>
                    </div>

                    <!-- Panel Content -->
                    <div class="recommendation-content">
                        <!-- Warnings Section -->
                        <div id="warnings-section" class="warnings-section hidden"></div>

                        <!-- Overdue Section -->
                        <div id="overdue-section" class="recommendation-section overdue hidden">
                            <div class="recommendation-section-header">
                                <span class="recommendation-section-icon">ðŸ”´</span>
                                <span>Overdue</span>
                                <span id="overdue-count" class="recommendation-section-count">0</span>
                            </div>
                            <div id="overdue-items" class="recommendation-items"></div>
                        </div>

                        <!-- Must Complete Today Section -->
                        <div id="must-do-section" class="recommendation-section must-do hidden">
                            <div class="recommendation-section-header">
                                <span class="recommendation-section-icon">âš¡</span>
                                <span>Must Complete Today</span>
                                <span id="must-do-count" class="recommendation-section-count">0</span>
                            </div>
                            <div id="must-do-items" class="recommendation-items"></div>
                        </div>

                        <!-- Recommended Section -->
                        <div id="recommended-section" class="recommendation-section recommended hidden">
                            <div class="recommendation-section-header">
                                <span class="recommendation-section-icon">ðŸ“‹</span>
                                <span>Recommended</span>
                                <span id="recommended-count" class="recommendation-section-count">0</span>
                            </div>
                            <div id="recommended-items" class="recommendation-items"></div>
                        </div>

                        <!-- If Time Permits Section -->
                        <div id="if-time-section" class="recommendation-section if-time hidden">
                            <div class="recommendation-section-header">
                                <span class="recommendation-section-icon">ðŸ’¡</span>
                                <span>If Time Permits</span>
                                <span id="if-time-count" class="recommendation-section-count">0</span>
                            </div>
                            <div id="if-time-items" class="recommendation-items"></div>
                        </div>

                        <!-- Insights Section -->
                        <div id="insights-section" class="insights-section hidden">
                            <div class="insights-header">
                                <span>ðŸ’¬</span>
                                <span>Insights</span>
                            </div>
                            <div id="insights-items"></div>
                        </div>

                        <!-- Empty State -->
                        <div id="recommendation-empty" class="recommendation-empty">
                            <div class="recommendation-empty-icon">ðŸŽ‰</div>
                            <p class="recommendation-empty-text">No tasks to recommend.<br>Add some todos to get started!</p>
                        </div>
                    </div>
                </div>

                <!-- Todo Panel (Right) -->
                <div class="todo-panel">
                    <!-- Floating shortcut hint (shown when items exist) -->
                    <p id="todo-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

                    <!-- Todo List Container -->
                    <div id="todo-list" class="todo-list">
                        <!-- Todos will be rendered here -->
                    </div>

                    <!-- Empty State -->
                    <div id="empty-state" class="empty-state">
                        <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"></path>
                            <rect x="9" y="3" width="6" height="4" rx="1"></rect>
                            <line x1="9" y1="12" x2="15" y2="12"></line>
                            <line x1="9" y1="16" x2="13" y2="16"></line>
                        </svg>
                        <p class="empty-text">No Todos</p>
                        <p class="shortcut-hint">Press Shift + N to create new items</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Engagements Page -->
    <div id="engagements-page" class="page hidden">
        <!-- Main Content -->
        <main class="main-content">
            <!-- Archive Toggle -->
            <div class="archive-toggle-container">
                <label class="archive-toggle">
                    <input type="checkbox" id="show-archived-toggle" onchange="toggleShowArchived()">
                    <span>Show Archived</span>
                </label>
            </div>
            <!-- Floating shortcut hint (shown when items exist) -->
            <p id="opp-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

            <!-- Engagement List Container -->
            <div id="engagement-list" class="engagement-list">
                <!-- Engagements will be rendered here -->
            </div>

            <!-- Empty State -->
            <div id="engagement-empty-state" class="empty-state">
                <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                </svg>
                <p class="empty-text">No Engagements</p>
                <p class="shortcut-hint">Press Shift + N to create new items</p>
            </div>
        </main>
    </div>

    <!-- Settings Page -->
    <div id="settings-page" class="page hidden">
        <div class="settings-container">
            <!-- Left Menu -->
            <nav class="settings-menu">
                <h2 class="settings-menu-title">Settings</h2>
                <ul class="settings-menu-list">
                    <li class="settings-menu-item active" data-section="people" onclick="switchSettingsSection('people')">
                        <!-- Multi-user icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                        <span>People</span>
                    </li>
                    <li class="settings-menu-item" data-section="tags" onclick="switchSettingsSection('tags')">
                        <!-- Tag icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                            <line x1="7" y1="7" x2="7.01" y2="7"></line>
                        </svg>
                        <span>Tags</span>
                    </li>
                    <li class="settings-menu-item" data-section="planning" onclick="switchSettingsSection('planning')">
                        <!-- Calendar/Clock icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                            <line x1="16" y1="2" x2="16" y2="6"></line>
                            <line x1="8" y1="2" x2="8" y2="6"></line>
                            <line x1="3" y1="10" x2="21" y2="10"></line>
                            <circle cx="12" cy="15" r="2"></circle>
                        </svg>
                        <span>Planning</span>
                    </li>
                    <li class="settings-menu-item" data-section="storage" onclick="switchSettingsSection('storage')">
                        <!-- Database/Storage icon -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <ellipse cx="12" cy="5" rx="9" ry="3"></ellipse>
                            <path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path>
                            <path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>
                        </svg>
                        <span>Storage</span>
                    </li>
                </ul>
            </nav>

            <!-- Content Area -->
            <div class="settings-content">
                <!-- Close Button -->
                <button class="settings-close-btn" onclick="closeSettings()" title="Close Settings">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>

                <!-- People Section -->
                <div id="settings-section-people" class="settings-section">
                    <h2 class="settings-section-title">People</h2>

                    <!-- Floating shortcut hint (shown when items exist) -->
                    <p id="people-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

                    <!-- People List Container -->
                    <div id="people-list" class="people-list">
                        <!-- People will be rendered here -->
                    </div>

                    <!-- Empty State -->
                    <div id="people-empty-state" class="empty-state">
                        <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                        <p class="empty-text">No People</p>
                        <p class="shortcut-hint">Press Shift + N to create new items</p>
                    </div>

                    <!-- Roles Section -->
                    <div id="roles-section" class="roles-section hidden">
                        <h3 class="roles-title">Roles</h3>
                        <div id="roles-list" class="roles-list">
                            <!-- Roles will be rendered here -->
                        </div>
                    </div>
                </div>

                <!-- Tags Section -->
                <div id="settings-section-tags" class="settings-section hidden">
                    <h2 class="settings-section-title">Tags</h2>

                    <!-- Floating shortcut hint (shown when items exist) -->
                    <p id="tags-shortcut-hint-floating" class="shortcut-hint-floating hidden">Press Shift + N to create new items</p>

                    <!-- Tags List Container -->
                    <div id="tags-list" class="tags-list-container">
                        <!-- Tags will be rendered here -->
                    </div>

                    <!-- Empty State -->
                    <div id="tags-empty-state" class="empty-state">
                        <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                            <line x1="7" y1="7" x2="7.01" y2="7"></line>
                        </svg>
                        <p class="empty-text">No Tags</p>
                        <p class="shortcut-hint">Press Shift + N to create new items</p>
                    </div>
                </div>

                <!-- Planning Section -->
                <div id="settings-section-planning" class="settings-section hidden">
                    <h2 class="settings-section-title">Planning</h2>
                    <p style="color: #6C757D; margin-bottom: 24px;">Configure how the daily recommendation engine calculates and displays your task priorities.</p>

                    <form class="planning-settings-form" onsubmit="savePlanningSettings(event)">
                        <div class="form-group">
                            <label for="workday-minutes" class="form-label">Workday Length (minutes)</label>
                            <input type="number" id="workday-minutes" class="form-input" min="60" max="1440" value="480">
                            <p class="form-hint">How many minutes you plan to work each day (default: 480 = 8 hours)</p>
                        </div>

                        <div class="form-group">
                            <label for="buffer-percentage" class="form-label">Buffer Percentage (%)</label>
                            <input type="number" id="buffer-percentage" class="form-input" min="0" max="50" value="15">
                            <p class="form-hint">Reserve time for interruptions and context switching (default: 15%)</p>
                        </div>

                        <div class="form-group">
                            <label for="max-overdue" class="form-label">Max Overdue Items to Show</label>
                            <input type="number" id="max-overdue" class="form-input" min="1" max="20" value="5">
                            <p class="form-hint">Limit how many overdue items appear in recommendations (default: 5)</p>
                        </div>

                        <div class="form-group">
                            <label for="planning-horizon" class="form-label">Planning Horizon (days)</label>
                            <input type="number" id="planning-horizon" class="form-input" min="1" max="30" value="14">
                            <p class="form-hint">How far ahead to look when recommending tasks (default: 14 days)</p>
                        </div>

                        <button type="submit" class="btn btn-primary btn-save-settings">Save Settings</button>
                    </form>
                </div>

                <!-- Storage Section -->
                <div id="settings-section-storage" class="settings-section hidden">
                    <h2 class="settings-section-title">Storage</h2>
                    <p style="color: #6C757D; margin-bottom: 24px;">View storage statistics and manage browser-stored data.</p>

                    <div class="storage-stats" style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin-bottom: 24px;">
                        <h3 style="font-size: 16px; font-weight: 600; color: #1F1F1F; margin-bottom: 16px;">Storage Statistics</h3>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;">
                            <div style="text-align: center; padding: 16px; background: white; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                <div id="storage-size" style="font-size: 24px; font-weight: 700; color: #3B82F6;">--</div>
                                <div style="font-size: 12px; color: #6C757D; margin-top: 4px;">Estimated Size</div>
                            </div>
                            <div style="text-align: center; padding: 16px; background: white; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                <div id="storage-todos" style="font-size: 24px; font-weight: 700; color: #10B981;">--</div>
                                <div style="font-size: 12px; color: #6C757D; margin-top: 4px;">Todos</div>
                            </div>
                            <div style="text-align: center; padding: 16px; background: white; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                <div id="storage-engagements" style="font-size: 24px; font-weight: 700; color: #F59E0B;">--</div>
                                <div style="font-size: 12px; color: #6C757D; margin-top: 4px;">Engagements</div>
                            </div>
                        </div>
                    </div>

                    <div style="border-top: 1px solid #e5e7eb; padding-top: 24px;">
                        <h3 style="font-size: 16px; font-weight: 600; color: #1F1F1F; margin-bottom: 12px;">Clear Browser State</h3>
                        <p style="color: #6C757D; margin-bottom: 16px; font-size: 14px;">
                            Remove all data stored in your browser. This will delete all todos, engagements, people, tags, and settings.
                        </p>
                        <button type="button" class="btn btn-danger" onclick="openClearStateModal()">
                            Clear Browser State
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tag Modal -->
    <div id="tag-modal" class="modal hidden">
        <div class="modal-content">
            <h2 id="tag-modal-title">New Tag</h2>
            <form id="tag-form" onsubmit="saveTag(event)">
                <div class="form-group">
                    <label for="tag-name" class="form-label">Name *</label>
                    <input type="text" id="tag-name" class="form-input" placeholder="Tag name" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Color *</label>
                    <div class="color-picker-wrapper">
                        <div class="color-picker-input">
                            <div id="tag-color-preview" class="color-picker-preview" style="background-color: #F59E0B;"></div>
                            <span id="tag-color-value" class="color-picker-value">#F59E0B</span>
                        </div>
                        <input type="color" id="tag-color" class="color-picker-native" value="#F59E0B" onchange="updateColorPreview(this.value)">
                    </div>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeTagModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Side Panel for Comments Only -->
    <div id="side-panel-backdrop" class="side-panel-backdrop" onclick="closeSidePanel()"></div>
    <div id="side-panel" class="side-panel">
        <div class="side-panel-header">
            <div class="side-panel-title-wrapper">
                <h2 class="side-panel-title">Comments</h2>
                <span id="side-panel-engagement-name" class="side-panel-engagement-name"></span>
            </div>
            <button class="side-panel-close" onclick="closeSidePanel()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="side-panel-body">
            <!-- Comments Section -->
            <div class="comments-section comments-only">
                <div id="panel-comments" class="comments-list">
                    <!-- Comments will be rendered here -->
                </div>
                <!-- Comment Input Area -->
                <div class="comment-input-area">
                    <textarea id="comment-input" class="comment-textarea" placeholder="Add a comment..."></textarea>
                    <button type="button" class="comment-submit-btn" onclick="addComment()">Add Comment</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Create Todo Modal -->
    <div id="todo-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeModal()"></div>
        <div class="modal-content" id="todo-modal-content">
            <h2 id="modal-title" class="modal-title">New Todo</h2>
            <form id="todo-form" onsubmit="saveTodo(event)">
                <div id="todo-form-columns" class="todo-form-columns">
                    <!-- Left Column - Main Todo Form -->
                    <div id="todo-form-left" class="todo-form-left">
                        <div class="form-group">
                            <label for="todo-title" class="form-label">Title <span class="required">*</span></label>
                            <input type="text" id="todo-title" class="form-input" placeholder="What needs to be done?" required autofocus>
                        </div>
                        <div class="form-group">
                            <label for="todo-description" class="form-label">Description</label>
                            <textarea id="todo-description" class="form-textarea" placeholder="Additional details (optional)"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="todo-deadline" class="form-label">Deadline <span class="required">*</span></label>
                            <input type="datetime-local" id="todo-deadline" class="datetime-input" data-datetimepicker required>
                        </div>
                        <div class="form-group">
                            <label for="todo-effort" class="form-label">Effort Level <span class="required">*</span></label>
                            <select id="todo-effort" class="effort-select" required>
                                <option value="very_low">Very Low (30 min)</option>
                                <option value="low">Low (2 hours)</option>
                                <option value="average" selected>Average (4 hours)</option>
                                <option value="high">High (6 hours)</option>
                                <option value="very_high">Very High (8 hours)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="todo-priority" class="form-label">Priority <span class="required">*</span></label>
                            <div class="priority-autocomplete-wrapper">
                                <input type="text" id="todo-priority" class="priority-input" placeholder="Type to select priority..." autocomplete="off" required>
                                <div id="priority-dropdown" class="priority-dropdown">
                                    <!-- Priority options will be rendered here -->
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="todo-engagement" class="form-label">Linked Engagement</label>
                            <div class="autocomplete-wrapper">
                                <div class="autocomplete-input-wrapper">
                                    <input type="text" id="todo-engagement" class="autocomplete-input" placeholder="Type to search or create..." autocomplete="off">
                                    <button type="button" id="todo-engagement-clear" class="autocomplete-clear" onclick="clearEngagementSelection()">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <line x1="18" y1="6" x2="6" y2="18"></line>
                                            <line x1="6" y1="6" x2="18" y2="18"></line>
                                        </svg>
                                    </button>
                                </div>
                                <div id="engagement-dropdown" class="autocomplete-dropdown">
                                    <!-- Dropdown items will be rendered here -->
                                </div>
                            </div>
                        </div>
                        <!-- Tags Section -->
                        <div class="form-group">
                            <label class="form-label">Tags</label>
                            <div class="tag-input-container" id="todo-tag-container">
                                <div class="selected-tags" id="todo-selected-tags">
                                    <!-- Selected tags will be rendered here -->
                                </div>
                                <div class="tag-input-wrapper">
                                    <input type="text" id="todo-tag-input" class="tag-input" placeholder="Type to add tags..." autocomplete="off">
                                    <div id="todo-tag-dropdown" class="tag-dropdown">
                                        <!-- Tag suggestions will be rendered here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-actions" id="modal-actions">
                            <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                            <span id="todo-save-wrapper" class="btn-tooltip-wrapper">
                                <button type="submit" id="todo-save-btn" class="btn btn-primary">Save</button>
                            </span>
                        </div>
                    </div>

                    <!-- Column Separator -->
                    <div id="column-separator" class="column-separator"></div>

                    <!-- Right Column - Inline Engagement Panel -->
                    <div id="todo-form-right" class="todo-form-right">
                        <div class="inline-eng-panel">
                            <div class="inline-eng-panel-header">
                                <span class="inline-eng-panel-title">New Engagement</span>
                            </div>
                            <div class="form-group">
                                <label for="inline-eng-name" class="form-label">Name</label>
                                <input type="text" id="inline-eng-name" class="form-input" placeholder="Engagement name" readonly>
                            </div>
                            <div class="form-group">
                                <label for="inline-eng-description" class="form-label">Description</label>
                                <textarea id="inline-eng-description" class="form-textarea inline-eng-textarea" placeholder="Additional details (optional)"></textarea>
                            </div>
                            <div class="form-group">
                                <label for="inline-eng-start-date" class="form-label">Start Date</label>
                                <input type="date" id="inline-eng-start-date" class="form-input" data-datetimepicker>
                            </div>
                            <div class="form-group">
                                <label for="inline-eng-contact" class="form-label">Contact</label>
                                <div class="autocomplete-wrapper">
                                    <div class="autocomplete-input-wrapper">
                                        <input type="text" id="inline-eng-contact" class="form-input" placeholder="Type to search or create person..." autocomplete="off">
                                        <button type="button" id="inline-eng-contact-clear" class="autocomplete-clear" onclick="clearInlineOppContact()">
                                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                                <line x1="6" y1="6" x2="18" y2="18"></line>
                                            </svg>
                                        </button>
                                    </div>
                                    <div id="inline-eng-contact-dropdown" class="autocomplete-dropdown">
                                        <!-- Contact dropdown items will be rendered here -->
                                    </div>
                                </div>
                                <!-- Inline Person Creation Form (within inline engagement) -->
                                <div id="inline-eng-person-form" class="inline-contact-form">
                                    <div class="inline-contact-header">
                                        <span class="inline-contact-title">Create New Person</span>
                                        <div class="inline-contact-actions">
                                            <button type="button" class="btn btn-secondary" onclick="cancelInlineOppPerson()">Cancel</button>
                                            <button type="button" class="btn btn-primary" id="inline-eng-person-add-btn" onclick="confirmInlineOppPerson()">Add</button>
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label for="inline-eng-person-name" class="form-label">Name</label>
                                        <input type="text" id="inline-eng-person-name" class="form-input" placeholder="Person's name" readonly>
                                    </div>
                                    <div class="form-group">
                                        <label for="inline-eng-person-role" class="form-label">Role</label>
                                        <input type="text" id="inline-eng-person-role" class="form-input" placeholder="Person's role">
                                    </div>
                                </div>
                            </div>
                            <div class="inline-eng-panel-footer">
                                <button type="button" class="btn btn-secondary" id="inline-eng-cancel-btn" onclick="cancelInlineEngagement()">Cancel</button>
                                <button type="button" class="btn btn-primary" id="inline-eng-add-btn" onclick="confirmInlineEngagement()">Add</button>
                            </div>
                        </div>
                    </div>
                </div>
            </form>
        </div>
    </div>

    <!-- Create Engagement Modal -->
    <div id="engagement-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeEngagementModal()"></div>
        <div class="modal-content">
            <h2 class="modal-title">New Engagement</h2>
            <form id="engagement-form" onsubmit="saveEngagement(event)">
                <div class="form-group">
                    <label for="eng-name" class="form-label">Name <span class="required">*</span></label>
                    <input type="text" id="eng-name" class="form-input" placeholder="Engagement name" required autofocus>
                </div>
                <div class="form-group">
                    <label for="eng-description" class="form-label">Description</label>
                    <input type="text" id="eng-description" class="form-input" placeholder="Brief description">
                </div>
                <div class="form-group">
                    <label for="eng-start-date" class="form-label">Start Date</label>
                    <input type="date" id="eng-start-date" class="form-input" data-datetimepicker>
                </div>
                <div class="form-group">
                    <label for="eng-contact" class="form-label">Contact</label>
                    <div class="autocomplete-wrapper">
                        <input type="text" id="eng-contact" class="form-input" placeholder="Type to search or create person..." autocomplete="off">
                        <button type="button" id="eng-contact-clear" class="autocomplete-clear" onclick="clearOppContact()">Ã—</button>
                        <div id="contact-dropdown" class="autocomplete-dropdown">
                            <!-- Contact dropdown items will be rendered here -->
                        </div>
                    </div>
                    <!-- Inline Person Creation Form -->
                    <div id="inline-person-form" class="inline-person-form">
                        <div class="inline-person-header">
                            <span class="inline-person-title">Create New Person</span>
                            <div class="inline-person-actions">
                                <button type="button" class="btn btn-secondary" onclick="cancelInlinePerson()">Cancel</button>
                                <button type="button" class="btn btn-primary" onclick="confirmInlinePerson()">Add</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="inline-person-name" class="form-label">Name</label>
                            <input type="text" id="inline-person-name" class="form-input" placeholder="Person's name">
                        </div>
                        <div class="form-group">
                            <label for="inline-person-role" class="form-label">Role</label>
                            <input type="text" id="inline-person-role" class="form-input" placeholder="Person's role">
                        </div>
                    </div>
                </div>
                <!-- Tags Section -->
                <div class="form-group">
                    <label class="form-label">Tags</label>
                    <div class="tag-input-container" id="opp-tag-container">
                        <div class="selected-tags" id="opp-selected-tags">
                            <!-- Selected tags will be rendered here -->
                        </div>
                        <div class="tag-input-wrapper">
                            <input type="text" id="opp-tag-input" class="tag-input" placeholder="Type to add tags..." autocomplete="off">
                            <div id="opp-tag-dropdown" class="tag-dropdown">
                                <!-- Tag suggestions will be rendered here -->
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeEngagementModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="confirm-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeConfirmModal()"></div>
        <div class="modal-content confirm-modal-content">
            <svg class="confirm-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
            <h2 class="confirm-title">Delete Engagement?</h2>
            <p id="confirm-message" class="confirm-message">Are you sure you want to delete this engagement? This action cannot be undone.</p>
            <div class="confirm-actions">
                <button type="button" class="btn btn-secondary" onclick="closeConfirmModal()">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="confirmDeleteEngagement()">Delete</button>
            </div>
        </div>
    </div>

    <!-- Cancel Engagement Modal -->
    <div id="cancel-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeCancelModal()"></div>
        <div class="modal-content cancel-modal-content">
            <svg class="cancel-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="15" y1="9" x2="9" y2="15"></line>
                <line x1="9" y1="9" x2="15" y2="15"></line>
            </svg>
            <h2 class="modal-title">Cancel Engagement</h2>
            <p id="cancel-eng-name" style="text-align: center; color: #6C757D; margin-bottom: 20px;"></p>
            <div class="form-group">
                <label for="cancel-reason" class="form-label">Reason for Cancellation <span class="required">*</span></label>
                <textarea id="cancel-reason" class="form-textarea" placeholder="Please provide a reason for cancelling this engagement..." required></textarea>
            </div>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeCancelModal()">Back</button>
                <button type="button" class="btn btn-warning" onclick="confirmCancelEngagement()">Cancel Engagement</button>
            </div>
        </div>
    </div>

    <!-- Todo Action Modal (for Close/Cancel engagement with linked todos) -->
    <div id="todo-action-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeTodoActionModal()"></div>
        <div class="modal-content todo-action-modal-content">
            <svg class="cancel-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
            </svg>
            <h2 class="modal-title" id="todo-action-modal-title">Handle Linked Todos</h2>
            <p id="todo-action-eng-name" style="text-align: center; color: #6C757D; margin-bottom: 10px;"></p>
            <p id="todo-action-count" style="text-align: center; color: #495057; margin-bottom: 20px; font-size: 14px;"></p>
            <p style="font-size: 13px; color: #495057; margin-bottom: 16px; text-align: center;">
                What would you like to do with the linked todos?
            </p>
            <div class="todo-action-buttons">
                <button type="button" class="btn btn-success" onclick="todoActionComplete()" style="width: 100%; margin-bottom: 8px;">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px; margin-right: 6px;">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                    Complete All Todos
                </button>
                <button type="button" class="btn btn-warning" onclick="todoActionDrop()" style="width: 100%; margin-bottom: 8px;">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px; margin-right: 6px;">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="15" y1="9" x2="9" y2="15"></line>
                        <line x1="9" y1="9" x2="15" y2="15"></line>
                    </svg>
                    Drop All Todos
                </button>
                <button type="button" class="btn btn-danger" onclick="todoActionDelete()" style="width: 100%; margin-bottom: 16px;">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px; margin-right: 6px;">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    </svg>
                    Delete All Todos
                </button>
            </div>
            <div class="modal-actions" style="border-top: 1px solid #E9ECEF; padding-top: 16px;">
                <button type="button" class="btn btn-secondary" onclick="closeTodoActionModal()" style="width: 100%;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Promote to Pre-Project Modal -->
    <div id="promote-preproject-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closePromotePreProjectModal()"></div>
        <div class="modal-content promote-modal-content">
            <h2 class="modal-title">Promote to Pre-Project</h2>
            <p id="promote-preproject-name" style="text-align: center; color: #6C757D; margin-bottom: 20px;"></p>
            <p style="font-size: 13px; color: #495057; margin-bottom: 16px;">
                Pre-project phase tracks informal work with expectation of future project formalization.
                You can track monthly allocations during this phase.
            </p>
            <div class="promote-form-group">
                <label for="preproject-started" class="promote-form-label">Pre-Project Started</label>
                <input type="date" id="preproject-started" class="promote-form-input" data-datetimepicker>
            </div>
            <div class="promote-form-group">
                <label for="preproject-expected" class="promote-form-label">Expected Formalization Date (Optional)</label>
                <input type="date" id="preproject-expected" class="promote-form-input" data-datetimepicker>
            </div>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closePromotePreProjectModal()">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="confirmPromoteToPreProject()">Promote</button>
            </div>
        </div>
    </div>

    <!-- Promote to Project Modal -->
    <div id="promote-project-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closePromoteProjectModal()"></div>
        <div class="modal-content promote-modal-content" style="max-width: 600px;">
            <h2 class="modal-title">Promote to Project</h2>
            <p id="promote-project-name" style="text-align: center; color: #6C757D; margin-bottom: 20px;"></p>
            <p style="font-size: 13px; color: #495057; margin-bottom: 16px;">
                Converting to a formal project with funding and governance.
                Pre-project time can be charged back to the project.
            </p>
            <div class="promote-form-group">
                <label for="project-formalized" class="promote-form-label">Formalization Date</label>
                <input type="date" id="project-formalized" class="promote-form-input" data-datetimepicker>
            </div>
            <div class="promote-form-group">
                <label for="project-code" class="promote-form-label">Project Code (Optional)</label>
                <input type="text" id="project-code" class="promote-form-input" placeholder="e.g., PRJ-2025-042">
            </div>
            <div class="promote-form-group">
                <label for="project-funding" class="promote-form-label">Funding Source (Optional)</label>
                <input type="text" id="project-funding" class="promote-form-input" placeholder="e.g., IT Capital Budget 2025">
            </div>
            <div class="promote-form-group">
                <label class="promote-form-label">Project Timeline</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <div>
                        <label for="project-start" style="font-size: 11px; color: #6C757D;">Start Date</label>
                        <input type="date" id="project-start" class="promote-form-input" data-datetimepicker>
                    </div>
                    <div>
                        <label for="project-end" style="font-size: 11px; color: #6C757D;">End Date</label>
                        <input type="date" id="project-end" class="promote-form-input" data-datetimepicker>
                    </div>
                </div>
            </div>
            <div class="promote-form-group">
                <label for="project-allocation" class="promote-form-label">Allocation Percentage</label>
                <input type="number" id="project-allocation" class="promote-form-input" placeholder="25" min="0" max="100">
            </div>
            <div id="chargeback-options" class="promote-form-group" style="display: none;">
                <label class="promote-form-label">Charge-Back Mode</label>
                <p style="font-size: 12px; color: #6C757D; margin-bottom: 8px;">
                    How should pre-project time be charged to the project?
                </p>
                <div class="chargeback-mode-options">
                    <label class="chargeback-mode-option selected" onclick="selectChargeBackMode('original')">
                        <input type="radio" name="chargeback-mode" value="original" checked>
                        <div class="chargeback-mode-label">
                            <div class="chargeback-mode-title">Original Rate</div>
                            <div class="chargeback-mode-desc">Charge the actual percentage worked during pre-project</div>
                        </div>
                    </label>
                    <label class="chargeback-mode-option" onclick="selectChargeBackMode('project_rate')">
                        <input type="radio" name="chargeback-mode" value="project_rate">
                        <div class="chargeback-mode-label">
                            <div class="chargeback-mode-title">Project Rate</div>
                            <div class="chargeback-mode-desc">Charge at the formal project allocation rate</div>
                        </div>
                    </label>
                    <label class="chargeback-mode-option" onclick="selectChargeBackMode('none')">
                        <input type="radio" name="chargeback-mode" value="none">
                        <div class="chargeback-mode-label">
                            <div class="chargeback-mode-title">No Charge-Back</div>
                            <div class="chargeback-mode-desc">Don't charge pre-project time to the project</div>
                        </div>
                    </label>
                </div>
            </div>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closePromoteProjectModal()">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="confirmPromoteToProject()">Promote to Project</button>
            </div>
        </div>
    </div>

    <!-- Unified Promotion Modal (Issue-57) -->
    <div id="unified-promote-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeUnifiedPromoteModal()"></div>
        <div class="modal-content unified-promote-modal">
            <div class="unified-promote-header">
                <h2 id="unified-promote-title" class="unified-promote-title">Promote Engagement</h2>
                <button class="unified-promote-close" onclick="closeUnifiedPromoteModal()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>

            <!-- Pre-Project Section -->
            <div id="preproject-allocation-section" class="allocation-section">
                <div class="allocation-section-header" onclick="togglePreProjectSection()">
                    <div id="preproject-toggle" class="allocation-section-toggle"></div>
                    <span class="allocation-section-title">Pre-Project Time Reporting</span>
                    <a href="#" class="allocation-section-link" onclick="event.stopPropagation();">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                            <polyline points="15 3 21 3 21 9"></polyline>
                            <line x1="10" y1="14" x2="21" y2="3"></line>
                        </svg>
                    </a>
                </div>
                <div id="preproject-section-content" class="allocation-section-content">
                    <div class="allocation-input-row">
                        <span class="allocation-input-label">Pre-Project Allocation</span>
                        <input type="text" id="preproject-allocation-input" class="allocation-input" value="25%" oninput="updatePreProjectAllocationValue(this.value)">
                    </div>
                    <div class="allocation-months-label">Pre-Project Allocation Months</div>
                    <div id="preproject-timeline" class="month-timeline-container">
                        <!-- Timeline will be rendered dynamically -->
                    </div>
                </div>
            </div>

            <!-- Project Section -->
            <div id="project-allocation-section" class="allocation-section">
                <div class="allocation-section-header" onclick="toggleProjectSection()">
                    <div id="project-toggle" class="allocation-section-toggle"></div>
                    <span class="allocation-section-title">Project Allocation Time Reporting</span>
                    <a href="#" class="allocation-section-link" onclick="event.stopPropagation();">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                            <polyline points="15 3 21 3 21 9"></polyline>
                            <line x1="10" y1="14" x2="21" y2="3"></line>
                        </svg>
                    </a>
                </div>
                <div id="project-section-content" class="allocation-section-content">
                    <div class="allocation-input-row">
                        <span class="allocation-input-label">Project Allocation</span>
                        <input type="text" id="project-allocation-input" class="allocation-input" value="50%" oninput="updateProjectAllocationValue(this.value)">
                    </div>
                    <div class="allocation-months-label">Project Allocation Months</div>
                    <div id="project-timeline" class="month-timeline-container">
                        <!-- Timeline will be rendered dynamically -->
                    </div>
                </div>
            </div>

            <div class="unified-promote-footer">
                <button type="button" class="btn btn-secondary" onclick="closeUnifiedPromoteModal()">Cancel</button>
                <button type="button" id="unified-promote-save-btn" class="btn-save" onclick="saveUnifiedPromotion()" disabled>Save</button>
            </div>
        </div>
    </div>

    <!-- Person Modal -->
    <div id="person-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closePersonModal()"></div>
        <div class="modal-content">
            <h2 id="person-modal-title" class="modal-title">New Person</h2>
            <form id="person-form" onsubmit="savePerson(event)">
                <div class="form-group">
                    <label for="person-name" class="form-label">Name <span class="required">*</span></label>
                    <input type="text" id="person-name" class="form-input" placeholder="Person's name" required>
                </div>
                <div class="form-group">
                    <label for="person-role" class="form-label">Role</label>
                    <div class="autocomplete-wrapper">
                        <input type="text" id="person-role" class="form-input" placeholder="Type to search or create role..." autocomplete="off">
                        <button type="button" id="person-role-clear" class="autocomplete-clear" onclick="clearPersonRole()">Ã—</button>
                        <div id="role-dropdown" class="autocomplete-dropdown">
                            <!-- Role dropdown items will be rendered here -->
                        </div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closePersonModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- IndexedDB Unavailable Warning Modal -->
    <div id="indexeddb-warning-modal" class="modal hidden">
        <div class="modal-backdrop"></div>
        <div class="modal-content confirm-modal-content">
            <svg class="confirm-icon" style="stroke: #EF4444;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
            <h2 class="modal-title">Browser Storage Unavailable</h2>
            <p style="text-align: center; color: #6C757D; margin-bottom: 20px;">
                IndexedDB is not available in your browser. This usually happens when using private/incognito browsing mode.
            </p>
            <p style="text-align: center; color: #6C757D; margin-bottom: 20px;">
                Please switch to a regular browser window to use TodoManager, as your data cannot be saved in private browsing mode.
            </p>
        </div>
    </div>

    <!-- Clear State Confirmation Modal -->
    <div id="clear-state-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeClearStateModal()"></div>
        <div class="modal-content confirm-modal-content">
            <svg class="confirm-icon" style="stroke: #EF4444;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
            <h2 class="modal-title">Clear Browser State</h2>
            <p style="text-align: center; color: #6C757D; margin-bottom: 20px;">
                This will permanently delete all your data stored in the browser, including todos, engagements, people, and settings.
            </p>
            <p style="text-align: center; color: #6C757D; margin-bottom: 20px;">
                Would you like to export your data before clearing?
            </p>
            <div class="modal-actions" style="flex-direction: column; gap: 12px;">
                <button type="button" class="btn btn-primary" onclick="exportThenClear()" style="width: 100%;">Export Data & Clear</button>
                <button type="button" class="btn btn-danger" onclick="confirmClearState()" style="width: 100%;">Clear Without Export</button>
                <button type="button" class="btn btn-secondary" onclick="closeClearStateModal()" style="width: 100%;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Delete Person Confirmation Modal -->
    <div id="delete-person-modal" class="modal hidden">
        <div class="modal-backdrop" onclick="closeDeletePersonModal()"></div>
        <div class="modal-content confirm-modal-content">
            <svg class="confirm-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
            <h2 class="modal-title">Delete Person</h2>
            <p id="delete-person-name" style="text-align: center; color: #6C757D; margin-bottom: 20px;"></p>
            <p style="text-align: center; margin-bottom: 20px;">Are you sure you want to delete this person? This will remove them from any linked engagements.</p>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="closeDeletePersonModal()">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="confirmDeletePerson()">Delete</button>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // PRIORITY TAGS - System-defined constants
        // ========================================
        const PRIORITY_TAGS = Object.freeze({
            urgent: {
                id: "priority-urgent",
                name: "urgent",
                label: "Urgent",
                color: "#ef4444",
                weight: 100,
                description: "Must be addressed immediately"
            },
            high: {
                id: "priority-high",
                name: "high",
                label: "High Priority",
                color: "#f97316",
                weight: 75,
                description: "Important, should be done soon"
            },
            normal: {
                id: "priority-normal",
                name: "normal",
                label: "Normal",
                color: "#3b82f6",
                weight: 50,
                description: "Standard priority"
            },
            low: {
                id: "priority-low",
                name: "low",
                label: "Low Priority",
                color: "#6b7280",
                weight: 25,
                description: "Can wait, do when time permits"
            },
            someday: {
                id: "priority-someday",
                name: "someday",
                label: "Someday",
                color: "#9ca3af",
                weight: 10,
                description: "No urgency, backlog item"
            }
        });

        const DEFAULT_PRIORITY = "normal";

        // ========================================
        // EFFORT LEVELS - Configuration
        // ========================================
        const EFFORT_CONFIG = Object.freeze({
            very_low:  { label: "Very Low",  minutes: 30,  icon: "âš¡" },
            low:       { label: "Low",       minutes: 120, icon: "ðŸŸ¢" },
            average:   { label: "Average",   minutes: 240, icon: "ðŸŸ¡" },
            high:      { label: "High",      minutes: 360, icon: "ðŸŸ " },
            very_high: { label: "Very High", minutes: 480, icon: "ðŸ”´" }
        });

        const DEFAULT_EFFORT = "average";

        // ========================================
        // PLANNING SETTINGS - Defaults
        // ========================================
        const DEFAULT_SETTINGS = Object.freeze({
            workdayMinutes: 480,        // 8-hour workday
            bufferPercentage: 15,       // 15% buffer for interruptions
            maxOverdueToShow: 5,        // Limit overdue display
            planningHorizonDays: 14     // Look-ahead window
        });

        // ========================================
        // INDEXEDDB - State Persistence
        // ========================================
        const DB_NAME = 'TodoManagerDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'appState';
        let db = null;

        // Check if IndexedDB is available
        function isIndexedDBAvailable() {
            try {
                if (!window.indexedDB) {
                    return false;
                }
                // Test if we can actually open a database (fails in private mode on some browsers)
                return true;
            } catch (e) {
                return false;
            }
        }

        // Initialize IndexedDB
        function initDB() {
            return new Promise((resolve, reject) => {
                if (!isIndexedDBAvailable()) {
                    reject(new Error('IndexedDB is not available. Please ensure you are not in private browsing mode.'));
                    return;
                }

                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = (event) => {
                    reject(new Error('Failed to open database: ' + event.target.error));
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    const database = event.target.result;
                    if (!database.objectStoreNames.contains(STORE_NAME)) {
                        database.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    }
                };
            });
        }

        // Save state to IndexedDB
        function saveStateToIndexedDB() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const persistableState = {
                    id: 'state',
                    todos: state.todos,
                    engagements: state.engagements,
                    people: state.people,
                    roles: state.roles,
                    tags: state.tags,
                    settings: state.settings,
                    allocations: state.allocations,
                    lastModified: new Date().toISOString()
                };

                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(persistableState);

                request.onsuccess = () => resolve();
                request.onerror = () => reject(new Error('Failed to save state'));
            });
        }

        // Load state from IndexedDB
        function loadStateFromIndexedDB() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get('state');

                request.onsuccess = (event) => {
                    const savedState = event.target.result;
                    if (savedState) {
                        resolve(savedState);
                    } else {
                        resolve(null);
                    }
                };

                request.onerror = () => reject(new Error('Failed to load state'));
            });
        }

        // Clear all data from IndexedDB
        function clearIndexedDB() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }

                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.clear();

                request.onsuccess = () => resolve();
                request.onerror = () => reject(new Error('Failed to clear database'));
            });
        }

        // Get storage statistics
        async function getStorageStats() {
            const stats = {
                todoCount: state.todos.length,
                engagementCount: state.engagements.length,
                estimatedSize: 0
            };

            // Calculate estimated size
            const dataToMeasure = {
                todos: state.todos,
                engagements: state.engagements,
                people: state.people,
                roles: state.roles,
                tags: state.tags,
                settings: state.settings
            };

            const jsonString = JSON.stringify(dataToMeasure);
            stats.estimatedSize = new Blob([jsonString]).size;

            return stats;
        }

        // Format bytes to human-readable string
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Application state
        const state = {
            todos: [],
            engagements: [],
            people: [],
            roles: [],
            tags: [],
            currentPage: 'landing',
            currentTab: 'home',  // 'home', 'engagements', or 'settings'
            previousTab: 'home',  // Track previous tab for settings return navigation
            settingsSection: 'people',  // Current settings section
            modalOpen: false,
            engagementModalOpen: false,
            personModalOpen: false,
            confirmModalOpen: false,
            cancelModalOpen: false,
            sidePanelOpen: false,
            editingTodoIndex: null,  // Track which todo is being edited (null = create mode)
            editingPersonIndex: null,  // Track which person is being edited (null = create mode)
            editingTagIndex: null,  // Track which tag is being edited (null = create mode)
            tagModalOpen: false,
            selectedEngagementIndex: null,  // Track which engagement is open in side panel (comments)
            editingEngagementIndex: null,  // Track which engagement is being edited (null = create mode)
            deleteEngagementIndex: null,  // Track which engagement is pending deletion
            deletePersonIndex: null,  // Track which person is pending deletion
            cancelEngagementIndex: null,  // Track which engagement is pending cancellation
            todoActionModalOpen: false,  // Track if todo action modal is open
            todoActionEngagementIndex: null,  // Track which engagement's todos are being handled
            todoActionType: null,  // 'close' or 'cancel' - to continue after handling todos
            // Autocomplete state
            selectedEngagementId: null,  // ID of selected engagement for todo linking
            selectedPersonId: null,  // ID of selected person for engagement contact
            pendingEngagement: null,  // New engagement to create when saving todo
            pendingPerson: null,  // New person to create when saving engagement
            autocompleteOpen: false,
            autocompleteHighlightIndex: -1,
            roleAutocompleteOpen: false,
            roleAutocompleteHighlightIndex: -1,
            contactAutocompleteOpen: false,
            contactAutocompleteHighlightIndex: -1,
            inlineEngFormOpen: false,
            inlinePersonFormOpen: false,
            // Inline person form within inline engagement (in Todo modal)
            inlineEngContactAutocompleteOpen: false,
            inlineEngContactAutocompleteHighlightIndex: -1,
            inlineEngPersonFormOpen: false,
            selectedInlineOppPersonId: null,
            pendingInlineOppPerson: null,
            showArchived: false,
            // Tag assignment state
            selectedTodoTagIds: [],  // Tag IDs selected for current todo
            selectedOppTagIds: [],   // Tag IDs selected for current engagement
            todoTagDropdownOpen: false,
            todoTagHighlightIndex: -1,
            engTagDropdownOpen: false,
            oppTagHighlightIndex: -1,
            // Planning settings
            settings: { ...DEFAULT_SETTINGS },
            // Priority autocomplete state
            selectedPriority: DEFAULT_PRIORITY,
            priorityDropdownOpen: false,
            priorityHighlightIndex: -1,
            // Lifecycle modal state
            promotePreProjectModalOpen: false,
            promoteProjectModalOpen: false,
            promoteEngagementIndex: null,
            selectedChargeBackMode: 'original',
            // Engagement allocations (Issue-57)
            allocations: [],
            // Inline expansion state (Issue-57)
            expandedEngagementId: null,
            // Unified promote modal state (Issue-57)
            unifiedPromoteModalOpen: false,
            unifiedPromoteEngagementId: null,
            preProjectSectionEnabled: false,
            projectSectionEnabled: false,
            preProjectAllocationPercent: 25,
            projectAllocationPercent: 25,
            preProjectSelectedMonths: [],
            projectStartMonth: null,
            projectEndMonth: null,
            monthTimelineOffset: 0
        };

        // DOM Elements - Landing and Home
        const landingPage = document.getElementById('landing-page');
        const homePage = document.getElementById('home-page');
        const todoList = document.getElementById('todo-list');
        const emptyState = document.getElementById('empty-state');
        const todoShortcutHintFloating = document.getElementById('todo-shortcut-hint-floating');
        const todoModal = document.getElementById('todo-modal');
        const todoForm = document.getElementById('todo-form');
        const todoTitleInput = document.getElementById('todo-title');
        const todoDescriptionInput = document.getElementById('todo-description');
        const todoDeadlineInput = document.getElementById('todo-deadline');
        const todoEffortSelect = document.getElementById('todo-effort');
        const todoPriorityInput = document.getElementById('todo-priority');
        const priorityDropdown = document.getElementById('priority-dropdown');
        const modalTitle = document.getElementById('modal-title');
        const todoSaveBtn = document.getElementById('todo-save-btn');
        const todoSaveWrapper = document.getElementById('todo-save-wrapper');

        // DOM Elements - Recommendation Panel
        const recommendationPanel = document.getElementById('recommendation-panel');
        const recommendationDateText = document.getElementById('recommendation-date-text');
        const recommendationSummary = document.getElementById('recommendation-summary');
        const warningsSection = document.getElementById('warnings-section');
        const overdueSection = document.getElementById('overdue-section');
        const overdueItems = document.getElementById('overdue-items');
        const overdueCount = document.getElementById('overdue-count');
        const mustDoSection = document.getElementById('must-do-section');
        const mustDoItems = document.getElementById('must-do-items');
        const mustDoCount = document.getElementById('must-do-count');
        const recommendedSection = document.getElementById('recommended-section');
        const recommendedItems = document.getElementById('recommended-items');
        const recommendedCount = document.getElementById('recommended-count');
        const ifTimeSection = document.getElementById('if-time-section');
        const ifTimeItems = document.getElementById('if-time-items');
        const ifTimeCount = document.getElementById('if-time-count');
        const insightsSection = document.getElementById('insights-section');
        const insightsItems = document.getElementById('insights-items');
        const recommendationEmpty = document.getElementById('recommendation-empty');

        // DOM Elements - Autocomplete
        const todoEngagementInput = document.getElementById('todo-engagement');
        const todoEngagementClear = document.getElementById('todo-engagement-clear');
        const engagementDropdown = document.getElementById('engagement-dropdown');
        const inlineEngForm = document.getElementById('inline-eng-form');
        const inlineEngName = document.getElementById('inline-eng-name');
        const inlineEngDescription = document.getElementById('inline-eng-description');
        const inlineEngStartDate = document.getElementById('inline-eng-start-date');
        const inlineEngContact = document.getElementById('inline-eng-contact');
        const inlineEngContactClear = document.getElementById('inline-eng-contact-clear');
        const inlineEngContactDropdown = document.getElementById('inline-eng-contact-dropdown');
        const inlineEngPersonForm = document.getElementById('inline-eng-person-form');
        const inlineEngPersonName = document.getElementById('inline-eng-person-name');
        const inlineEngPersonRole = document.getElementById('inline-eng-person-role');

        // DOM Elements - Horizontal Expansion
        const todoModalContent = document.getElementById('todo-modal-content');
        const todoFormColumns = document.getElementById('todo-form-columns');
        const todoFormLeft = document.getElementById('todo-form-left');
        const todoFormRight = document.getElementById('todo-form-right');
        const columnSeparator = document.getElementById('column-separator');
        const inlineEngAddBtn = document.getElementById('inline-eng-add-btn');
        const inlineEngCancelBtn = document.getElementById('inline-eng-cancel-btn');
        const inlineEngPersonAddBtn = document.getElementById('inline-eng-person-add-btn');

        // DOM Elements - Engagements
        const engagementsPage = document.getElementById('engagements-page');
        const engagementList = document.getElementById('engagement-list');
        const engagementEmptyState = document.getElementById('engagement-empty-state');
        const oppShortcutHintFloating = document.getElementById('opp-shortcut-hint-floating');
        const engagementModal = document.getElementById('engagement-modal');
        const engagementForm = document.getElementById('engagement-form');
        const engNameInput = document.getElementById('eng-name');
        const engDescriptionInput = document.getElementById('eng-description');
        const engStartDateInput = document.getElementById('eng-start-date');
        const engContactInput = document.getElementById('eng-contact');
        const engContactClear = document.getElementById('eng-contact-clear');
        const contactDropdown = document.getElementById('contact-dropdown');
        const inlinePersonForm = document.getElementById('inline-person-form');
        const inlinePersonName = document.getElementById('inline-person-name');
        const inlinePersonRole = document.getElementById('inline-person-role');

        // DOM Elements - Side Panel (Comments Only)
        const sidePanel = document.getElementById('side-panel');
        const sidePanelBackdrop = document.getElementById('side-panel-backdrop');

        // DOM Elements - Promote Modals
        const promotePreProjectModal = document.getElementById('promote-preproject-modal');
        const promotePreProjectName = document.getElementById('promote-preproject-name');
        const preProjectStartedInput = document.getElementById('preproject-started');
        const preProjectExpectedInput = document.getElementById('preproject-expected');
        const promoteProjectModal = document.getElementById('promote-project-modal');
        const promoteProjectName = document.getElementById('promote-project-name');
        const projectFormalizedInput = document.getElementById('project-formalized');
        const projectCodeInput = document.getElementById('project-code');
        const projectFundingInput = document.getElementById('project-funding');
        const projectStartInput = document.getElementById('project-start');
        const projectEndInput = document.getElementById('project-end');
        const projectAllocationInput = document.getElementById('project-allocation');
        const chargeBackOptions = document.getElementById('chargeback-options');

        // DOM Elements - Unified Promotion Modal (Issue-57)
        const unifiedPromoteModal = document.getElementById('unified-promote-modal');
        const unifiedPromoteTitle = document.getElementById('unified-promote-title');
        const preprojectAllocationSection = document.getElementById('preproject-allocation-section');
        const preprojectToggle = document.getElementById('preproject-toggle');
        const preprojectSectionContent = document.getElementById('preproject-section-content');
        const preprojectAllocationInputEl = document.getElementById('preproject-allocation-input');
        const preprojectTimeline = document.getElementById('preproject-timeline');
        const projectAllocationSection = document.getElementById('project-allocation-section');
        const projectToggle = document.getElementById('project-toggle');
        const projectSectionContent = document.getElementById('project-section-content');
        const projectAllocationInputEl = document.getElementById('project-allocation-input');
        const projectTimeline = document.getElementById('project-timeline');
        const unifiedPromoteSaveBtn = document.getElementById('unified-promote-save-btn');

        // DOM Elements - Header and Tabs
        const appHeader = document.getElementById('app-header');
        const tabHome = document.getElementById('tab-home');
        const tabEngagements = document.getElementById('tab-engagements');

        // DOM Elements - Confirmation Modal
        const confirmModal = document.getElementById('confirm-modal');
        const confirmMessage = document.getElementById('confirm-message');

        // DOM Elements - Cancel Modal
        const cancelModal = document.getElementById('cancel-modal');
        const cancelOppName = document.getElementById('cancel-eng-name');
        const cancelReason = document.getElementById('cancel-reason');

        // DOM Elements - Todo Action Modal
        const todoActionModal = document.getElementById('todo-action-modal');
        const todoActionModalTitle = document.getElementById('todo-action-modal-title');
        const todoActionEngName = document.getElementById('todo-action-eng-name');
        const todoActionCount = document.getElementById('todo-action-count');

        // DOM Elements - Comments
        const panelComments = document.getElementById('panel-comments');
        const commentInput = document.getElementById('comment-input');

        // DOM Elements - Archive Toggle
        const showArchivedToggle = document.getElementById('show-archived-toggle');

        // DOM Elements - Settings
        const settingsPage = document.getElementById('settings-page');
        const peopleList = document.getElementById('people-list');
        const peopleEmptyState = document.getElementById('people-empty-state');
        const peopleShortcutHintFloating = document.getElementById('people-shortcut-hint-floating');
        const rolesSection = document.getElementById('roles-section');
        const rolesList = document.getElementById('roles-list');

        // DOM Elements - Tags
        const tagsList = document.getElementById('tags-list');
        const tagsEmptyState = document.getElementById('tags-empty-state');
        const tagsShortcutHintFloating = document.getElementById('tags-shortcut-hint-floating');
        const settingsSectionPeople = document.getElementById('settings-section-people');
        const settingsSectionTags = document.getElementById('settings-section-tags');

        // DOM Elements - Tag Modal
        const tagModal = document.getElementById('tag-modal');
        const tagModalTitle = document.getElementById('tag-modal-title');
        const tagForm = document.getElementById('tag-form');
        const tagNameInput = document.getElementById('tag-name');
        const tagColorInput = document.getElementById('tag-color');
        const tagColorPreview = document.getElementById('tag-color-preview');
        const tagColorValue = document.getElementById('tag-color-value');

        // DOM Elements - Tag Input (Todo form)
        const todoTagInput = document.getElementById('todo-tag-input');
        const todoTagDropdown = document.getElementById('todo-tag-dropdown');
        const todoSelectedTags = document.getElementById('todo-selected-tags');

        // DOM Elements - Tag Input (Engagement form)
        const engTagInput = document.getElementById('opp-tag-input');
        const engTagDropdown = document.getElementById('opp-tag-dropdown');
        const engSelectedTags = document.getElementById('opp-selected-tags');

        // DOM Elements - Person Modal
        const personModal = document.getElementById('person-modal');
        const personModalTitle = document.getElementById('person-modal-title');
        const personForm = document.getElementById('person-form');
        const personNameInput = document.getElementById('person-name');
        const personRoleInput = document.getElementById('person-role');
        const personRoleClear = document.getElementById('person-role-clear');
        const roleDropdown = document.getElementById('role-dropdown');

        // DOM Elements - Delete Person Modal
        const deletePersonModal = document.getElementById('delete-person-modal');
        const deletePersonName = document.getElementById('delete-person-name');

        // Navigation functions
        function navigateTo(page) {
            // Hide all pages
            landingPage.classList.add('hidden');
            landingPage.classList.remove('container');
            homePage.classList.add('hidden');
            engagementsPage.classList.add('hidden');
            settingsPage.classList.add('hidden');
            appHeader.classList.add('hidden');

            // Show requested page
            if (page === 'landing') {
                landingPage.classList.remove('hidden');
                landingPage.classList.add('container');
                document.body.style.display = 'flex';
                document.body.style.alignItems = 'center';
                document.body.style.justifyContent = 'center';
            } else if (page === 'app') {
                // Show app with header and current tab
                appHeader.classList.remove('hidden');
                document.body.style.display = 'block';
                document.body.style.alignItems = '';
                document.body.style.justifyContent = '';
                // Set currentPage before switchTab so render functions pass their guards
                state.currentPage = page;
                switchTab(state.currentTab);
            }

            state.currentPage = page;
        }

        // Tab switching function
        function switchTab(tab) {
            state.currentTab = tab;

            // Update tab buttons (settings doesn't have a tab button)
            tabHome.classList.toggle('active', tab === 'home');
            tabEngagements.classList.toggle('active', tab === 'engagements');

            // Show/hide pages
            homePage.classList.toggle('hidden', tab !== 'home');
            engagementsPage.classList.toggle('hidden', tab !== 'engagements');
            settingsPage.classList.toggle('hidden', tab !== 'settings');

            // Render content
            if (tab === 'home') {
                renderTodos();
            } else if (tab === 'engagements') {
                renderEngagements();
            } else if (tab === 'settings') {
                renderPeople();
            }
        }

        // Open Settings page
        function openSettings() {
            // Save current tab before navigating to settings
            if (state.currentTab !== 'settings') {
                state.previousTab = state.currentTab;
            }
            switchTab('settings');
        }

        // Close Settings and return to previous page
        function closeSettings() {
            switchTab(state.previousTab);
        }

        // Switch settings section
        function switchSettingsSection(section) {
            state.settingsSection = section;

            // Update menu item active state
            const menuItems = document.querySelectorAll('.settings-menu-item');
            menuItems.forEach(item => {
                item.classList.toggle('active', item.dataset.section === section);
            });

            // Toggle section visibility
            const peopleSection = document.getElementById('settings-section-people');
            const tagsSection = document.getElementById('settings-section-tags');
            const planningSection = document.getElementById('settings-section-planning');
            const storageSection = document.getElementById('settings-section-storage');

            // Hide all sections
            peopleSection.classList.add('hidden');
            tagsSection.classList.add('hidden');
            planningSection.classList.add('hidden');
            storageSection.classList.add('hidden');

            if (section === 'people') {
                peopleSection.classList.remove('hidden');
                renderPeople();
            } else if (section === 'tags') {
                tagsSection.classList.remove('hidden');
                renderTags();
            } else if (section === 'planning') {
                planningSection.classList.remove('hidden');
                renderPlanningSettings();
            } else if (section === 'storage') {
                storageSection.classList.remove('hidden');
                renderStorageSection();
            }
        }

        function startFromScratch() {
            // Clear data and navigate to app
            state.todos = [];
            state.engagements = [];
            state.people = [];
            state.roles = [];
            state.tags = [];
            state.settings = { ...DEFAULT_SETTINGS };
            state.currentTab = 'home';
            navigateTo('app');
            // Save initial empty state to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save initial state:', err));
        }

        function continueWorking() {
            // Trigger file input to load previous state (for importing from file)
            document.getElementById('import-file-input').click();
        }

        // Export app state to JSON file
        function exportData() {
            // Collect all data entities from state
            const exportableData = {
                version: '1.0',
                lastModified: new Date().toISOString(),
                settings: state.settings,
                userTags: state.tags,  // Renamed for spec compliance
                todos: state.todos,
                engagements: state.engagements,
                people: state.people,
                roles: state.roles,
                tags: state.tags,  // Keep for backward compatibility
                exportedAt: new Date().toISOString()
            };

            // Create JSON blob
            const jsonString = JSON.stringify(exportableData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });

            // Generate filename with timestamp
            const now = new Date();
            const timestamp = now.toISOString()
                .replace(/T/, '_')
                .replace(/:/g, '-')
                .replace(/\..+/, '');
            const filename = `todoApp_${timestamp}.json`;

            // Create download link and trigger download
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Import app state from JSON file
        function importData(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);

                    // Validate required data structure
                    if (!importedData || typeof importedData !== 'object') {
                        throw new Error('Invalid file format');
                    }

                    // Restore state data entities (with fallbacks for missing fields)
                    state.todos = Array.isArray(importedData.todos) ? importedData.todos : [];
                    state.engagements = Array.isArray(importedData.engagements) ? importedData.engagements : [];
                    state.people = Array.isArray(importedData.people) ? importedData.people : [];
                    state.roles = Array.isArray(importedData.roles) ? importedData.roles : [];
                    // Support both old 'tags' and new 'userTags' format
                    state.tags = Array.isArray(importedData.userTags) ? importedData.userTags :
                                 Array.isArray(importedData.tags) ? importedData.tags : [];

                    // Restore planning settings (merge with defaults)
                    if (importedData.settings && typeof importedData.settings === 'object') {
                        state.settings = { ...DEFAULT_SETTINGS, ...importedData.settings };
                    } else {
                        state.settings = { ...DEFAULT_SETTINGS };
                    }

                    // Ensure all todos have required new fields with defaults
                    state.todos = state.todos.map(todo => ({
                        ...todo,
                        title: todo.title || todo.description || 'Untitled',
                        description: todo.description || null,
                        deadline: todo.deadline || (todo.dueDate ? new Date(todo.dueDate).toISOString() : null),
                        effort: todo.effort || DEFAULT_EFFORT,
                        priority: PRIORITY_TAGS[todo.priority] ? todo.priority : DEFAULT_PRIORITY,
                        completedAt: todo.completedAt || null,
                        createdAt: todo.createdAt || new Date().toISOString(),
                        updatedAt: todo.updatedAt || new Date().toISOString()
                    }));

                    // Navigate to app and render
                    navigateTo('app');
                    renderTodos();
                    renderEngagements();
                    renderPeople();
                    renderTags();
                    loadPlanningSettings();

                    // Save imported data to IndexedDB
                    saveStateToIndexedDB().catch(err => console.error('Failed to save imported state:', err));

                } catch (error) {
                    alert('Error importing file: ' + error.message + '\n\nPlease ensure you selected a valid TodoApp export file.');
                }

                // Reset file input for future imports
                event.target.value = '';
            };

            reader.onerror = function() {
                alert('Error reading file. Please try again.');
                event.target.value = '';
            };

            reader.readAsText(file);
        }

        // Data persistence - saves to IndexedDB
        function saveData() {
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Modal functions
        function openModal(todoIndex = null) {
            todoModal.classList.remove('hidden');
            state.modalOpen = true;
            state.editingTodoIndex = todoIndex;

            // Reset form
            todoForm.reset();

            // Reset autocomplete state
            state.selectedEngagementId = null;
            state.pendingEngagement = null;
            state.autocompleteOpen = false;
            state.autocompleteHighlightIndex = -1;
            state.inlineEngFormOpen = false;
            // Reset inline opp person state
            state.inlineEngContactAutocompleteOpen = false;
            state.inlineEngContactAutocompleteHighlightIndex = -1;
            state.inlineEngPersonFormOpen = false;
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;
            todoEngagementInput.value = '';
            todoEngagementClear.classList.remove('visible');
            engagementDropdown.classList.remove('open');
            // Reset inline opp contact fields
            inlineEngContact.value = '';
            inlineEngContactClear.classList.remove('visible');
            inlineEngContactDropdown.classList.remove('open');
            inlineEngPersonForm.classList.remove('open');

            // Reset horizontal expansion state
            todoModalContent.classList.remove('expanded');
            todoFormColumns.classList.remove('expanded');
            todoFormLeft.classList.remove('disabled');
            todoFormRight.classList.remove('animate-in');

            // Reset engagement panel button states
            if (inlineEngAddBtn) inlineEngAddBtn.disabled = false;
            if (inlineEngCancelBtn) inlineEngCancelBtn.disabled = false;

            // Ensure right panel is not tabbable, left panel is tabbable
            setFormTabIndex(todoFormLeft, true);
            setFormTabIndex(todoFormRight, false);

            // Reset tag input state
            state.selectedTodoTagIds = [];
            state.todoTagDropdownOpen = false;
            state.todoTagHighlightIndex = -1;
            todoTagInput.value = '';
            closeTodoTagDropdown();

            // Reset priority state
            state.selectedPriority = DEFAULT_PRIORITY;
            state.priorityDropdownOpen = false;
            state.priorityHighlightIndex = -1;
            closePriorityDropdown();

            // Reset Save button state
            updateTodoSaveButtonState();

            if (todoIndex !== null) {
                // Edit mode - populate with existing todo data
                const todo = state.todos[todoIndex];
                modalTitle.textContent = 'Edit Todo';
                todoTitleInput.value = todo.title || '';
                todoDescriptionInput.value = todo.description || '';

                // Handle deadline (support both new deadline and old dueDate)
                if (todo.deadline) {
                    todoDeadlineInput.value = formatDateTimeLocal(new Date(todo.deadline));
                } else if (todo.dueDate) {
                    // Convert old dueDate to deadline with default time
                    const oldDate = new Date(todo.dueDate);
                    oldDate.setHours(17, 0, 0, 0);
                    todoDeadlineInput.value = formatDateTimeLocal(oldDate);
                } else {
                    todoDeadlineInput.value = getDefaultDeadline();
                }

                // Set effort
                todoEffortSelect.value = todo.effort || DEFAULT_EFFORT;

                // Set priority
                state.selectedPriority = todo.priority || DEFAULT_PRIORITY;
                todoPriorityInput.value = PRIORITY_TAGS[state.selectedPriority].label;

                // Pre-populate linked engagement
                if (todo.engagementId) {
                    const opp = state.engagements.find(o => o.id === todo.engagementId);
                    if (opp) {
                        state.selectedEngagementId = opp.id;
                        todoEngagementInput.value = opp.name;
                        todoEngagementClear.classList.add('visible');
                    }
                }

                // Pre-populate tags
                if (todo.tagIds && Array.isArray(todo.tagIds)) {
                    state.selectedTodoTagIds = [...todo.tagIds];
                }
            } else {
                // Create mode
                modalTitle.textContent = 'New Todo';
                // Set default deadline to 5 PM today
                todoDeadlineInput.value = getDefaultDeadline();
                // Set default effort
                todoEffortSelect.value = DEFAULT_EFFORT;
                // Set default priority
                state.selectedPriority = DEFAULT_PRIORITY;
                todoPriorityInput.value = PRIORITY_TAGS[DEFAULT_PRIORITY].label;
            }

            // Render selected tags
            renderTodoSelectedTags();

            // Focus on title input
            setTimeout(() => todoTitleInput.focus(), 100);
        }

        // Edit a todo - opens modal in edit mode
        function editTodo(index) {
            openModal(index);
        }

        // Get today's date in YYYY-MM-DD format for date input
        function getTodayDate() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function closeModal() {
            todoModal.classList.add('hidden');
            state.modalOpen = false;
            state.editingTodoIndex = null;
            state.selectedEngagementId = null;
            state.pendingEngagement = null;
            state.autocompleteOpen = false;
            state.inlineEngFormOpen = false;
            state.inlineEngPersonFormOpen = false;
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;
            todoForm.reset();
            engagementDropdown.classList.remove('open');

            // Reset horizontal expansion state
            todoModalContent.classList.remove('expanded');
            todoFormColumns.classList.remove('expanded');
            todoFormLeft.classList.remove('disabled');
            todoFormRight.classList.remove('animate-in');
            inlineEngPersonForm.classList.remove('open');

            // Reset button states
            if (inlineEngAddBtn) inlineEngAddBtn.disabled = false;
            if (inlineEngCancelBtn) inlineEngCancelBtn.disabled = false;

            // Reset tab navigation
            setFormTabIndex(todoFormLeft, true);
            setFormTabIndex(todoFormRight, false);
        }

        // Generate unique ID
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
        }

        // Save todo (handles both create and update)
        function saveTodo(event) {
            event.preventDefault();

            const title = todoTitleInput.value.trim();
            const description = todoDescriptionInput.value.trim();
            const deadline = todoDeadlineInput.value;
            const effort = todoEffortSelect.value;
            const priority = state.selectedPriority;

            if (!title) return;
            if (!deadline) return;

            // Handle pending engagement creation
            let engagementId = state.selectedEngagementId;
            if (state.pendingEngagement) {
                // First, handle person creation if needed
                let contactPersonId = state.pendingEngagement.contactPersonId;

                // Check for pending person from inline eng form (may be set after engagement was confirmed)
                const pendingPersonData = state.pendingEngagement.pendingPerson || state.pendingInlineOppPerson;

                if (pendingPersonData) {
                    // Create the new person (use the combined pending person data)
                    const pendingPerson = pendingPersonData;

                    // Handle role creation if needed
                    let roleId = null;
                    if (pendingPerson.role) {
                        // Check if role exists
                        const existingRole = state.roles.find(r => r.name.toLowerCase() === pendingPerson.role.toLowerCase());
                        if (existingRole) {
                            roleId = existingRole.id;
                        } else {
                            // Create new role
                            const newRole = {
                                id: generateId(),
                                name: pendingPerson.role,
                                createdAt: new Date().toISOString()
                            };
                            state.roles.push(newRole);
                            roleId = newRole.id;
                        }
                    }

                    // Create the person
                    const newPerson = {
                        id: generateId(),
                        name: pendingPerson.name,
                        roleId: roleId,
                        createdAt: new Date().toISOString()
                    };
                    state.people.push(newPerson);
                    contactPersonId = newPerson.id;
                }

                // Create the new engagement
                const newOpp = {
                    id: generateId(),
                    name: state.pendingEngagement.name,
                    description: state.pendingEngagement.description || null,
                    startDate: state.pendingEngagement.startDate || getTodayDate(),
                    contactId: contactPersonId || null,
                    status: 'requested',
                    comments: [],
                    archived: false,
                    createdAt: new Date().toISOString()
                };
                state.engagements.push(newOpp);
                engagementId = newOpp.id;
            }

            if (state.editingTodoIndex !== null) {
                // Update existing todo
                const todo = state.todos[state.editingTodoIndex];
                todo.title = title;
                todo.description = description || null;
                todo.deadline = new Date(deadline).toISOString();
                todo.effort = effort;
                todo.priority = priority;
                todo.engagementId = engagementId;
                todo.tagIds = [...state.selectedTodoTagIds];
                todo.updatedAt = new Date().toISOString();
                // Preserve id, completed, completedAt, and createdAt
            } else {
                // Create new todo
                const now = new Date().toISOString();
                const newTodo = {
                    id: generateId(),
                    title: title,
                    description: description || null,
                    deadline: new Date(deadline).toISOString(),
                    effort: effort,
                    priority: priority,
                    engagementId: engagementId,
                    tagIds: [...state.selectedTodoTagIds],
                    completed: false,
                    completedAt: null,
                    dropped: false,
                    droppedAt: null,
                    createdAt: now,
                    updatedAt: now
                };
                state.todos.push(newTodo);
            }

            // Auto-update engagement status to Open if todo is linked and not completed
            if (engagementId) {
                updateEngagementAutoStatus(engagementId);
            }

            closeModal();
            renderTodos();
            // Also re-render engagements if on that tab
            if (state.currentTab === 'engagements') {
                renderEngagements();
            }
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Auto-update engagement status based on linked todos
        // Status Flow: Active â†” Paused (based on undone todos)
        function updateEngagementAutoStatus(engagementId) {
            const opp = state.engagements.find(o => o.id === engagementId);
            if (!opp) return;

            // Don't change completed engagements (final state)
            if (opp.status === 'completed') return;

            // Get all todos linked to this engagement (excluding dropped)
            const linkedTodos = state.todos.filter(t => t.engagementId === engagementId && !t.dropped);

            // Check if any linked todo is not completed
            const hasUndoneTodo = linkedTodos.some(t => !t.completed);

            if (hasUndoneTodo) {
                // Has non-completed todos â†’ Active
                // This also reactivates closed/dropped engagements when a todo is linked
                if (opp.status !== 'active') {
                    opp.status = 'active';
                }
            } else {
                // No undone todos (either all complete or none linked)
                // Only pause active engagements, don't change closed/dropped
                if (opp.status === 'active') {
                    opp.status = 'paused';
                }
            }
        }

        // Update all engagements' pause/resume status based on linked todos
        function updateAllEngagementStatuses() {
            state.engagements.forEach(eng => {
                // Only update active or paused engagements
                if (['completed', 'closed', 'dropped'].includes(eng.status)) return;

                const linkedTodos = state.todos.filter(t => t.engagementId === eng.id && !t.dropped);
                const hasUndoneTodo = linkedTodos.some(t => !t.completed);

                if (hasUndoneTodo) {
                    eng.status = 'active';
                } else {
                    eng.status = 'paused';
                }
            });
        }

        // Render functions
        function renderTodos() {
            if (state.currentPage !== 'app' || state.currentTab !== 'home') return;

            // Clear current list
            todoList.innerHTML = '';

            // Also render recommendation panel
            renderRecommendationPanel();

            if (state.todos.length === 0) {
                // Show empty state
                todoList.classList.add('hidden');
                emptyState.classList.remove('hidden');
                todoShortcutHintFloating.classList.add('hidden');
            } else {
                // Show todo list
                todoList.classList.remove('hidden');
                emptyState.classList.add('hidden');
                todoShortcutHintFloating.classList.remove('hidden');

                // Create sorted array with original indices preserved
                const sortedTodos = state.todos
                    .map((todo, index) => ({ todo, originalIndex: index }))
                    .sort((a, b) => {
                        // Active todos first, then completed/dropped
                        const aActive = !a.todo.completed && !a.todo.dropped;
                        const bActive = !b.todo.completed && !b.todo.dropped;

                        if (aActive !== bActive) {
                            return aActive ? -1 : 1;
                        }

                        if (!aActive) {
                            // Both completed or dropped: sort by completedAt/droppedAt (most recent first)
                            const aTime = a.todo.completedAt || a.todo.droppedAt
                                ? new Date(a.todo.completedAt || a.todo.droppedAt).getTime() : 0;
                            const bTime = b.todo.completedAt || b.todo.droppedAt
                                ? new Date(b.todo.completedAt || b.todo.droppedAt).getTime() : 0;
                            return bTime - aTime;
                        } else {
                            // Both active: sort by dueDate (earliest first)
                            const aDate = a.todo.dueDate ? new Date(a.todo.dueDate).getTime() : Infinity;
                            const bDate = b.todo.dueDate ? new Date(b.todo.dueDate).getTime() : Infinity;
                            return aDate - bDate;
                        }
                    });

                sortedTodos.forEach(({ todo, originalIndex: index }) => {
                    const todoItem = document.createElement('div');
                    const stateClass = todo.dropped ? 'dropped' : (todo.completed ? 'completed' : '');
                    todoItem.className = `todo-item ${stateClass}`;

                    // Format deadline (supports both old dueDate and new deadline)
                    let dueDateHtml = '';
                    const deadlineValue = todo.deadline || todo.dueDate;
                    if (deadlineValue) {
                        const dueDate = new Date(deadlineValue);
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);
                        const isOverdue = dueDate < today && !todo.completed && !todo.dropped;
                        dueDateHtml = `<div class="todo-due-date ${isOverdue ? 'overdue' : ''}">ðŸ“… ${formatDeadlineDisplay(deadlineValue)}</div>`;
                    }

                    // Format effort
                    let effortHtml = '';
                    const effort = todo.effort || DEFAULT_EFFORT;
                    const effortConfig = EFFORT_CONFIG[effort];
                    if (effortConfig) {
                        effortHtml = `<span class="todo-effort"><span class="todo-effort-icon">${effortConfig.icon}</span> ${formatEffortDisplay(effort)}</span>`;
                    }

                    // Format priority
                    let priorityHtml = '';
                    const priority = todo.priority || DEFAULT_PRIORITY;
                    if (priority && priority !== 'normal') {
                        const priorityTag = PRIORITY_TAGS[priority];
                        if (priorityTag) {
                            priorityHtml = `<span class="priority-pill priority-${priority}">${priorityTag.label}</span>`;
                        }
                    }

                    // Format linked engagement
                    let engagementHtml = '';
                    if (todo.engagementId) {
                        const opp = state.engagements.find(o => o.id === todo.engagementId);
                        if (opp) {
                            engagementHtml = `
                                <div class="todo-engagement">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <circle cx="12" cy="12" r="10"></circle>
                                        <polyline points="12 6 12 12 16 14"></polyline>
                                    </svg>
                                    ${escapeHtml(opp.name)}
                                </div>
                            `;
                        }
                    }

                    // Format tags (combine priority pill with user tags)
                    let tagsHtml = '';
                    const tagPills = [];

                    // Add priority pill first (if not normal)
                    if (priorityHtml) {
                        tagPills.push(priorityHtml);
                    }

                    // Add effort badge
                    if (effortHtml) {
                        tagPills.push(effortHtml);
                    }

                    // Add user tags
                    if (todo.tagIds && todo.tagIds.length > 0) {
                        todo.tagIds.forEach(tagId => {
                            const tag = getTagById(tagId);
                            if (tag) {
                                tagPills.push(`<span class="tag-pill" style="background-color: ${tag.color}; color: #fff;">${escapeHtml(tag.name)}</span>`);
                            }
                        });
                    }

                    if (tagPills.length > 0) {
                        tagsHtml = `<div class="tags-container">${tagPills.join('')}</div>`;
                    }

                    // Format description for two-column layout
                    let descriptionHtml = '';
                    if (todo.description && todo.description.trim()) {
                        descriptionHtml = `<div class="todo-description">${escapeHtml(todo.description)}</div>`;
                    }

                    // Checkbox class and click handler (dropped todos can't be toggled)
                    const checkboxClass = todo.dropped ? 'dropped' : (todo.completed ? 'checked' : '');
                    const checkboxClick = todo.dropped ? '' : `onclick="toggleTodo(${index})"`;

                    todoItem.innerHTML = `
                        <div class="todo-checkbox ${checkboxClass}" ${checkboxClick}></div>
                        <div class="todo-content">
                            <div class="todo-info">
                                <div class="todo-title">${escapeHtml(todo.title)}</div>
                                ${dueDateHtml}
                                ${engagementHtml}
                                ${tagsHtml}
                            </div>
                            ${descriptionHtml}
                        </div>
                        <div class="todo-actions">
                            <button class="todo-edit-btn" onclick="editTodo(${index})" title="Edit">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                        </div>
                    `;
                    todoList.appendChild(todoItem);
                });
            }
        }

        function toggleTodo(index) {
            const todo = state.todos[index];
            todo.completed = !todo.completed;
            todo.completedAt = todo.completed ? new Date().toISOString() : null;
            todo.updatedAt = new Date().toISOString();

            // Track completion timestamp
            if (todo.completed) {
                todo.completedAt = new Date().toISOString();
            } else {
                todo.completedAt = null;
            }

            // Check and update engagement status if linked
            if (todo.engagementId) {
                updateEngagementAutoStatus(todo.engagementId);
            }

            renderTodos();
            // Re-render engagements if on that tab to update status badges
            if (state.currentTab === 'engagements') {
                renderEngagements();
            }
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Utility function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Format date for display
        function formatDate(dateString) {
            const date = new Date(dateString);
            const options = { year: 'numeric', month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        // Engagement Modal functions
        function openEngagementModal() {
            engagementModal.classList.remove('hidden');
            state.engagementModalOpen = true;
            state.editingEngagementIndex = null;  // Create mode

            // Update modal title
            const modalTitle = engagementModal.querySelector('.modal-title');
            if (modalTitle) modalTitle.textContent = 'New Engagement';

            // Reset form
            engagementForm.reset();
            // Set default start date to today
            engStartDateInput.value = getTodayDate();

            // Reset contact autocomplete state
            state.selectedPersonId = null;
            state.pendingPerson = null;
            state.contactAutocompleteOpen = false;
            state.contactAutocompleteHighlightIndex = -1;
            state.inlinePersonFormOpen = false;
            engContactClear.classList.remove('visible');
            contactDropdown.classList.remove('open');
            inlinePersonForm.classList.remove('open');

            // Reset tag input state
            state.selectedOppTagIds = [];
            state.engTagDropdownOpen = false;
            state.oppTagHighlightIndex = -1;
            engTagInput.value = '';
            closeOppTagDropdown();
            renderOppSelectedTags();

            // Focus on name input
            setTimeout(() => engNameInput.focus(), 100);
        }

        // Open engagement modal in edit mode
        function openEditEngagement(index) {
            const eng = state.engagements[index];
            if (!eng) return;

            engagementModal.classList.remove('hidden');
            state.engagementModalOpen = true;
            state.editingEngagementIndex = index;

            // Update modal title
            const modalTitle = engagementModal.querySelector('.modal-title');
            if (modalTitle) modalTitle.textContent = 'Edit Engagement';

            // Reset form first
            engagementForm.reset();

            // Populate form with existing data
            engNameInput.value = eng.name || '';
            engDescriptionInput.value = eng.description || '';
            engStartDateInput.value = eng.startDate || '';

            // Handle contact
            if (eng.contactId) {
                const person = state.people.find(p => p.id === eng.contactId);
                if (person) {
                    state.selectedPersonId = eng.contactId;
                    engContactInput.value = person.name;
                    engContactClear.classList.add('visible');
                } else {
                    state.selectedPersonId = null;
                    engContactInput.value = eng.contact || '';
                    engContactClear.classList.remove('visible');
                }
            } else if (eng.contact) {
                state.selectedPersonId = null;
                engContactInput.value = eng.contact;
                engContactClear.classList.remove('visible');
            } else {
                state.selectedPersonId = null;
                engContactInput.value = '';
                engContactClear.classList.remove('visible');
            }

            // Reset autocomplete state
            state.pendingPerson = null;
            state.contactAutocompleteOpen = false;
            state.contactAutocompleteHighlightIndex = -1;
            state.inlinePersonFormOpen = false;
            contactDropdown.classList.remove('open');
            inlinePersonForm.classList.remove('open');

            // Handle tags
            state.selectedOppTagIds = eng.tagIds ? [...eng.tagIds] : [];
            state.engTagDropdownOpen = false;
            state.oppTagHighlightIndex = -1;
            engTagInput.value = '';
            closeOppTagDropdown();
            renderOppSelectedTags();

            // Focus on name input
            setTimeout(() => engNameInput.focus(), 100);
        }

        function closeEngagementModal() {
            engagementModal.classList.add('hidden');
            state.engagementModalOpen = false;
            state.selectedPersonId = null;
            state.pendingPerson = null;
            state.contactAutocompleteOpen = false;
            state.inlinePersonFormOpen = false;
            engagementForm.reset();
            contactDropdown.classList.remove('open');
            inlinePersonForm.classList.remove('open');
        }

        // Save engagement
        function saveEngagement(event) {
            event.preventDefault();

            const name = engNameInput.value.trim();
            const description = engDescriptionInput.value.trim();
            const startDate = engStartDateInput.value;
            const contactName = engContactInput.value.trim();

            if (!name) return;

            // Handle pending person creation
            let contactId = state.selectedPersonId;
            if (state.pendingPerson) {
                // Create the pending person
                const roleId = getOrCreateRole(state.pendingPerson.role);
                const newPerson = {
                    id: generateId(),
                    name: state.pendingPerson.name,
                    roleId: roleId
                };
                state.people.push(newPerson);
                contactId = newPerson.id;
            }

            if (state.editingEngagementIndex !== null) {
                // Edit mode - update existing engagement
                const eng = state.engagements[state.editingEngagementIndex];
                if (eng) {
                    eng.name = name;
                    eng.description = description || null;
                    eng.startDate = startDate || eng.startDate;
                    eng.contact = contactName || null;
                    eng.contactId = contactId || null;
                    eng.tagIds = [...state.selectedOppTagIds];
                    // Don't change status, comments, archived, createdAt
                }
            } else {
                // Create mode - add new engagement
                const newEngagement = {
                    id: generateId(),
                    name: name,
                    description: description || null,
                    startDate: startDate || getTodayDate(),
                    contact: contactName || null,  // Keep text for display
                    contactId: contactId || null,  // Link to person
                    tagIds: [...state.selectedOppTagIds],
                    type: 'engagement',  // Default type (engagement | pre-project | project)
                    status: 'active',  // Default status (active | completed | closed | dropped)
                    comments: [],
                    archived: false,
                    createdAt: new Date().toISOString(),
                    // Lifecycle data (null until promoted)
                    preProject: null,
                    project: null
                };
                state.engagements.push(newEngagement);
            }

            closeEngagementModal();
            renderEngagements();
            renderPeople();  // Refresh people list if new person was created

            // Update side panel if open and editing the same engagement
            if (state.sidePanelOpen && state.selectedEngagementIndex === state.editingEngagementIndex) {
                openSidePanel(state.selectedEngagementIndex);
            }

            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Toggle show archived engagements
        function toggleShowArchived() {
            state.showArchived = showArchivedToggle.checked;
            renderEngagements();
        }

        // Render engagements list
        function renderEngagements() {
            if (state.currentPage !== 'app' || state.currentTab !== 'engagements') return;

            // Clear current list
            engagementList.innerHTML = '';

            // Filter engagements based on archived state
            const filteredEngagements = state.engagements.filter(opp => {
                if (state.showArchived) return true;
                return !opp.archived;
            });

            if (filteredEngagements.length === 0) {
                // Show empty state
                engagementList.classList.add('hidden');
                engagementEmptyState.classList.remove('hidden');
                oppShortcutHintFloating.classList.add('hidden');
            } else {
                // Show engagement list
                engagementList.classList.remove('hidden');
                engagementEmptyState.classList.add('hidden');
                oppShortcutHintFloating.classList.remove('hidden');

                filteredEngagements.forEach((opp) => {
                    // Find original index in state.engagements
                    const index = state.engagements.indexOf(opp);
                    const oppItem = document.createElement('div');
                    oppItem.className = 'engagement-item' + (opp.archived ? ' archived' : '');

                    const statusClass = `status-${opp.status}`;
                    // Use dynamic type based on allocation dates (Issue-57)
                    const displayType = getEngagementDisplayType(opp);
                    const typeClass = `type-${displayType}`;
                    const typeName = getTypeDisplayName(displayType);

                    // Build action buttons based on status
                    let actionButtons = '';
                    if (!opp.archived) {
                        const isActiveOrPaused = opp.status === 'active' || opp.status === 'paused';

                        // Edit button - always shown for non-archived
                        const editBtn = `
                            <button class="opp-action-btn edit-btn" onclick="event.stopPropagation(); openEditEngagement(${index})" title="Edit Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                        `;

                        // Complete button (checkmark) - only for active/paused
                        const completeBtn = isActiveOrPaused ? `
                            <button class="opp-action-btn complete-btn" onclick="event.stopPropagation(); completeEngagement(${index})" title="Complete Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                            </button>
                        ` : '';

                        // Close button (minus) - only for active/paused
                        const closeBtn = isActiveOrPaused ? `
                            <button class="opp-action-btn close-btn" onclick="event.stopPropagation(); closeEngagementAction(${index})" title="Close Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                </svg>
                            </button>
                        ` : '';

                        // Cancel button (X in circle) - only for active/paused
                        const cancelBtn = isActiveOrPaused ? `
                            <button class="opp-action-btn cancel-btn" onclick="event.stopPropagation(); openCancelConfirmation(${index})" title="Cancel Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="15" y1="9" x2="9" y2="15"></line>
                                    <line x1="9" y1="9" x2="15" y2="15"></line>
                                </svg>
                            </button>
                        ` : '';

                        // Reactivate button - only for closed
                        const reactivateBtn = opp.status === 'closed' ? `
                            <button class="opp-action-btn reactivate-btn" onclick="event.stopPropagation(); reactivateEngagement(${index})" title="Reactivate Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M23 4v6h-6"></path>
                                    <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                                </svg>
                            </button>
                        ` : '';

                        // Uncancel button - only for dropped
                        const uncancelBtn = opp.status === 'dropped' ? `
                            <button class="opp-action-btn uncancel-btn" onclick="event.stopPropagation(); uncancelEngagement(${index})" title="Uncancel Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M23 4v6h-6"></path>
                                    <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                                </svg>
                            </button>
                        ` : '';

                        // Delete button - always shown
                        const deleteBtn = `
                            <button class="opp-action-btn delete-btn" onclick="event.stopPropagation(); openDeleteConfirmation(${index})" title="Delete Engagement">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                    <line x1="10" y1="11" x2="10" y2="17"></line>
                                    <line x1="14" y1="11" x2="14" y2="17"></line>
                                </svg>
                            </button>
                        `;

                        actionButtons = editBtn + completeBtn + closeBtn + cancelBtn + reactivateBtn + uncancelBtn + deleteBtn;
                    }
                    // No buttons for archived engagements

                    // Format tags for engagement
                    let oppTagsHtml = '';
                    if (opp.tagIds && opp.tagIds.length > 0) {
                        const tagPills = opp.tagIds.map(tagId => {
                            const tag = getTagById(tagId);
                            if (tag) {
                                return `<span class="tag-pill" style="background-color: ${tag.color}; color: #fff;">${escapeHtml(tag.name)}</span>`;
                            }
                            return '';
                        }).filter(Boolean).join('');
                        if (tagPills) {
                            oppTagsHtml = `<div class="tags-container">${tagPills}</div>`;
                        }
                    }

                    // Check if this engagement is expanded (Issue-57)
                    const isExpanded = state.expandedEngagementId === opp.id;
                    if (isExpanded) {
                        oppItem.classList.add('expanded');
                    }

                    // Build expanded content (Issue-57)
                    const expandedContent = renderEngagementExpandedContent(opp, index);

                    oppItem.innerHTML = `
                        <div class="engagement-header" onclick="toggleEngagementExpansion('${opp.id}')">
                            <div class="engagement-content">
                                <div class="engagement-type-indicator">
                                    <span class="engagement-type-badge ${typeClass}">${typeName}</span>
                                </div>
                                <div class="engagement-name">${escapeHtml(opp.name)}</div>
                                ${opp.contact ? `<div class="engagement-contact">${escapeHtml(opp.contact)}</div>` : ''}
                                ${oppTagsHtml}
                            </div>
                            ${getStatusBadgeWithTooltip(opp.status, statusClass)}
                            <div class="engagement-actions" onclick="event.stopPropagation()">
                                ${actionButtons}
                            </div>
                        </div>
                        <div class="engagement-expanded-content">
                            ${expandedContent}
                        </div>
                    `;
                    engagementList.appendChild(oppItem);
                });
            }
        }

        // ========================================
        // ENGAGEMENT EXPANSION FUNCTIONS (Issue-57)
        // ========================================

        // Toggle engagement expansion
        function toggleEngagementExpansion(engagementId) {
            // Accordion behavior: if already expanded, collapse; otherwise expand this one
            if (state.expandedEngagementId === engagementId) {
                state.expandedEngagementId = null;
            } else {
                state.expandedEngagementId = engagementId;
            }
            renderEngagements();
        }

        // Collapse engagement expansion (called when clicking outside)
        function collapseEngagementExpansion() {
            if (state.expandedEngagementId) {
                state.expandedEngagementId = null;
                renderEngagements();
            }
        }

        // Render expanded content for an engagement
        function renderEngagementExpandedContent(opp, index) {
            // Get contact info
            let contactName = '';
            let contactRole = '';
            if (opp.contactId) {
                const person = state.people.find(p => p.id === opp.contactId);
                if (person) {
                    contactName = person.name;
                    const role = state.roles.find(r => r.id === person.roleId);
                    contactRole = role ? role.name : '';
                }
            } else if (opp.contact) {
                contactName = opp.contact;
            }

            // Format start date as month/year
            const startMonth = opp.startDate ? formatMonthFull(opp.startDate.substring(0, 7)) : 'Not set';

            // Get comments count
            const commentsCount = (opp.comments || []).length;

            // Check if allocation exists
            const allocation = getAllocationForEngagement(opp.id);
            const hasAllocation = allocation && (allocation.preProject || allocation.project);
            const promoteButtonText = hasAllocation ? 'Allocation' : 'Promote to Project';

            // Render linked todos
            const todosHtml = renderEngagementTodos(opp.id);

            return `
                <div class="engagement-expanded-panes">
                    <div class="engagement-left-pane">
                        <div class="engagement-detail-row">
                            <div class="engagement-detail-group">
                                <div class="engagement-detail-label">Contact:</div>
                                <div class="engagement-detail-value">${escapeHtml(contactName) || 'Not set'}</div>
                                ${contactRole ? `<div class="engagement-detail-subtitle">${escapeHtml(contactRole)}</div>` : ''}
                            </div>
                            <div class="engagement-detail-group">
                                <div class="engagement-detail-label">Start Month:</div>
                                <div class="engagement-detail-value">${startMonth}</div>
                            </div>
                        </div>
                        <div class="engagement-description-section">
                            <div class="engagement-description-label">Description</div>
                            <div class="engagement-description-text">${opp.description ? escapeHtml(opp.description) : 'No description'}</div>
                        </div>
                        <div class="engagement-action-row">
                            <button class="engagement-promote-btn" onclick="event.stopPropagation(); openUnifiedPromoteModal('${opp.id}')">${promoteButtonText}</button>
                            <button class="engagement-comments-btn" onclick="event.stopPropagation(); openCommentsPanel('${opp.id}')">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                                </svg>
                                <span class="engagement-comments-count">${commentsCount}</span>
                            </button>
                        </div>
                    </div>
                    <div class="engagement-right-pane">
                        ${todosHtml}
                    </div>
                </div>
            `;
        }

        // Render linked todos for an engagement (Issue-57)
        function renderEngagementTodos(engagementId) {
            const linkedTodos = state.todos.filter(t => t.engagementId === engagementId);

            if (linkedTodos.length === 0) {
                return '<div class="engagement-todos-empty">No todos linked to this engagement</div>';
            }

            // Sort: open first, then by priority, then completed, then dropped
            const priorityOrder = { 'urgent': 0, 'high': 1, 'normal': 2, 'low': 3, 'someday': 4 };
            linkedTodos.sort((a, b) => {
                // Open todos first
                if (!a.completed && !a.dropped && (b.completed || b.dropped)) return -1;
                if ((a.completed || a.dropped) && !b.completed && !b.dropped) return 1;

                // Among open, sort by priority
                if (!a.completed && !a.dropped && !b.completed && !b.dropped) {
                    return (priorityOrder[a.priority] || 2) - (priorityOrder[b.priority] || 2);
                }

                return 0;
            });

            const effortLabels = {
                'very_low': '30 min',
                'low': '2 hrs',
                'average': '4 hrs',
                'high': '6 hrs',
                'very_high': '8 hrs'
            };

            const priorityLabels = {
                'urgent': 'Urgent',
                'high': 'High Priority',
                'normal': 'Normal',
                'low': 'Low',
                'someday': 'Someday'
            };

            return `
                <div class="engagement-todo-list">
                    ${linkedTodos.map(todo => {
                        const statusClass = todo.dropped ? 'dropped' : (todo.completed ? 'done' : 'open');
                        const itemClass = todo.dropped ? 'dropped' : (todo.completed ? 'completed' : '');
                        const effortText = effortLabels[todo.effort] || '4 hrs';
                        const priorityText = priorityLabels[todo.priority] || 'Normal';

                        // Status icon
                        let statusIcon = '';
                        if (todo.dropped) {
                            statusIcon = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
                        } else if (todo.completed) {
                            statusIcon = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
                        } else {
                            statusIcon = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle></svg>`;
                        }

                        return `
                            <div class="engagement-todo-item ${itemClass}">
                                <div class="engagement-todo-status ${statusClass}">${statusIcon}</div>
                                <div class="engagement-todo-title">${escapeHtml(todo.title)}</div>
                                <span class="engagement-todo-priority ${todo.priority || 'normal'}">${priorityText}</span>
                                <span class="engagement-todo-effort">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
                                    ${effortText}
                                </span>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        // ========================================
        // UNIFIED PROMOTION MODAL FUNCTIONS (Issue-57)
        // ========================================

        // Open unified promote modal
        function openUnifiedPromoteModal(engagementId) {
            const eng = state.engagements.find(e => e.id === engagementId);
            if (!eng) return;

            state.unifiedPromoteModalOpen = true;
            state.unifiedPromoteEngagementId = engagementId;

            // Load existing allocation if any
            const allocation = getAllocationForEngagement(engagementId);

            // Reset state
            state.preProjectSectionEnabled = false;
            state.projectSectionEnabled = false;
            state.preProjectAllocationPercent = 25;
            state.projectAllocationPercent = 50;
            state.preProjectSelectedMonths = [];
            state.projectStartMonth = null;
            state.projectEndMonth = null;
            state.monthTimelineOffset = 0;

            // Pre-fill from existing allocation
            if (allocation) {
                if (allocation.preProject) {
                    state.preProjectSectionEnabled = true;
                    state.preProjectAllocationPercent = allocation.preProject.allocationPercentage || 25;
                    state.preProjectSelectedMonths = [...(allocation.preProject.months || [])];
                }
                if (allocation.project) {
                    state.projectSectionEnabled = true;
                    state.projectAllocationPercent = allocation.project.allocationPercentage || 50;
                    state.projectStartMonth = allocation.project.startMonth || null;
                    state.projectEndMonth = allocation.project.endMonth || null;
                }
            }

            // Update modal title
            const hasAllocation = allocation && (allocation.preProject || allocation.project);
            unifiedPromoteTitle.textContent = hasAllocation ? 'Allocation' : 'Promote Engagement';

            // Update UI
            updateUnifiedModalUI();

            // Show modal
            unifiedPromoteModal.classList.remove('hidden');
        }

        // Close unified promote modal
        function closeUnifiedPromoteModal() {
            state.unifiedPromoteModalOpen = false;
            state.unifiedPromoteEngagementId = null;
            unifiedPromoteModal.classList.add('hidden');
        }

        // Update unified modal UI
        function updateUnifiedModalUI() {
            // Update pre-project section
            if (state.preProjectSectionEnabled) {
                preprojectToggle.classList.add('enabled');
                preprojectAllocationSection.classList.add('expanded');
            } else {
                preprojectToggle.classList.remove('enabled');
                preprojectAllocationSection.classList.remove('expanded');
            }

            // Update project section
            if (state.projectSectionEnabled) {
                projectToggle.classList.add('enabled');
                projectAllocationSection.classList.add('expanded');
            } else {
                projectToggle.classList.remove('enabled');
                projectAllocationSection.classList.remove('expanded');
            }

            // Update allocation inputs
            preprojectAllocationInputEl.value = state.preProjectAllocationPercent + '%';
            projectAllocationInputEl.value = state.projectAllocationPercent + '%';

            // Render timelines
            renderPreProjectTimeline();
            renderProjectTimeline();

            // Update save button state
            updateUnifiedSaveButtonState();
        }

        // Toggle pre-project section
        function togglePreProjectSection() {
            state.preProjectSectionEnabled = !state.preProjectSectionEnabled;
            if (!state.preProjectSectionEnabled) {
                state.preProjectSelectedMonths = [];
            }
            updateUnifiedModalUI();
        }

        // Toggle project section
        function toggleProjectSection() {
            state.projectSectionEnabled = !state.projectSectionEnabled;
            if (!state.projectSectionEnabled) {
                state.projectStartMonth = null;
                state.projectEndMonth = null;
            }
            updateUnifiedModalUI();
        }

        // Update pre-project allocation value
        function updatePreProjectAllocationValue(value) {
            const num = parseInt(value.replace('%', ''), 10);
            if (!isNaN(num) && num >= 1 && num <= 100) {
                state.preProjectAllocationPercent = num;
            }
            updateUnifiedSaveButtonState();
        }

        // Update project allocation value
        function updateProjectAllocationValue(value) {
            const num = parseInt(value.replace('%', ''), 10);
            if (!isNaN(num) && num >= 1 && num <= 100) {
                state.projectAllocationPercent = num;
            }
            updateUnifiedSaveButtonState();
        }

        // Render pre-project timeline
        function renderPreProjectTimeline() {
            preprojectTimeline.innerHTML = renderMonthTimeline('preproject');
        }

        // Render project timeline
        function renderProjectTimeline() {
            projectTimeline.innerHTML = renderMonthTimeline('project');
        }

        // Render month timeline for a section
        function renderMonthTimeline(section) {
            const currentMonth = getCurrentMonth();
            const [currentYear, currentMonthNum] = currentMonth.split('-').map(Number);

            // Generate 18 months from 6 months ago to 12 months in future
            const months = [];
            for (let offset = -6 + state.monthTimelineOffset; offset < 12 + state.monthTimelineOffset; offset++) {
                let year = currentYear;
                let month = currentMonthNum + offset;

                while (month > 12) {
                    month -= 12;
                    year++;
                }
                while (month < 1) {
                    month += 12;
                    year--;
                }

                const monthStr = `${year}-${String(month).padStart(2, '0')}`;
                months.push(monthStr);
            }

            // Group months by year for display
            const yearGroups = {};
            months.forEach(m => {
                const year = getYearFromMonth(m);
                if (!yearGroups[year]) {
                    yearGroups[year] = [];
                }
                yearGroups[year].push(m);
            });

            // Determine disabled months for project section
            const disabledMonths = new Set();
            if (section === 'project' && state.preProjectSelectedMonths.length > 0) {
                // All months up to and including the last pre-project month are disabled
                const sortedPreProject = [...state.preProjectSelectedMonths].sort();
                const lastPreProjectMonth = sortedPreProject[sortedPreProject.length - 1];
                months.forEach(m => {
                    if (m <= lastPreProjectMonth) {
                        disabledMonths.add(m);
                    }
                });
            }

            // Determine selected months
            const selectedMonths = new Set();
            if (section === 'preproject') {
                state.preProjectSelectedMonths.forEach(m => selectedMonths.add(m));
            } else if (section === 'project' && state.projectStartMonth && state.projectEndMonth) {
                const projectMonths = generateMonthRange(state.projectStartMonth, state.projectEndMonth);
                projectMonths.forEach(m => selectedMonths.add(m));
            }

            // Build years row HTML
            let yearsHtml = '';
            Object.keys(yearGroups).sort().forEach(year => {
                const monthCount = yearGroups[year].length;
                // Calculate width based on number of months (each month is ~55px including gap)
                yearsHtml += `<div class="month-timeline-year" style="width: ${monthCount * 55}px;">${year}</div>`;
            });

            // Build months row HTML
            let monthsHtml = months.map(m => {
                const isSelected = selectedMonths.has(m);
                const isDisabled = disabledMonths.has(m);
                const sectionClass = section === 'preproject' ? 'preproject' : 'project';

                let classes = 'month-timeline-month';
                if (isSelected) classes += ' selected ' + sectionClass;
                if (isDisabled) classes += ' disabled';

                const monthName = formatMonthShort(m);
                const onclick = isDisabled ? '' : `onclick="handleMonthClick('${section}', '${m}', event)"`;

                return `<div class="${classes}" data-month="${m}" ${onclick}>${monthName}</div>`;
            }).join('');

            return `
                <div class="month-timeline-nav">
                    <button class="month-timeline-arrow" onclick="scrollTimelineLeft()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="15 18 9 12 15 6"></polyline>
                        </svg>
                    </button>
                    <div class="month-timeline-scroll">
                        <div class="month-timeline-years">${yearsHtml}</div>
                        <div class="month-timeline-months">${monthsHtml}</div>
                    </div>
                    <button class="month-timeline-arrow" onclick="scrollTimelineRight()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="9 18 15 12 9 6"></polyline>
                        </svg>
                    </button>
                </div>
            `;
        }

        // Scroll timeline left
        function scrollTimelineLeft() {
            state.monthTimelineOffset -= 3;
            renderPreProjectTimeline();
            renderProjectTimeline();
        }

        // Scroll timeline right
        function scrollTimelineRight() {
            state.monthTimelineOffset += 3;
            renderPreProjectTimeline();
            renderProjectTimeline();
        }

        // Handle month click in timeline
        function handleMonthClick(section, month, event) {
            if (section === 'preproject') {
                handlePreProjectMonthClick(month, event);
            } else if (section === 'project') {
                handleProjectMonthClick(month, event);
            }
        }

        // Handle pre-project month click (allows gaps with Shift+Click)
        function handlePreProjectMonthClick(month, event) {
            const isShiftClick = event && event.shiftKey;

            if (isShiftClick && state.preProjectSelectedMonths.includes(month)) {
                // Shift+Click on selected month: deselect it
                state.preProjectSelectedMonths = state.preProjectSelectedMonths.filter(m => m !== month);
            } else if (state.preProjectSelectedMonths.includes(month)) {
                // Regular click on selected: deselect
                state.preProjectSelectedMonths = state.preProjectSelectedMonths.filter(m => m !== month);
            } else {
                // Click on unselected: select it
                if (state.preProjectSelectedMonths.length === 0) {
                    // First selection
                    state.preProjectSelectedMonths = [month];
                } else {
                    // Already have selections - fill range if needed
                    const sorted = [...state.preProjectSelectedMonths, month].sort();
                    const first = sorted[0];
                    const last = sorted[sorted.length - 1];
                    // Auto-fill range
                    state.preProjectSelectedMonths = generateMonthRange(first, last);
                }
            }

            updateUnifiedModalUI();
        }

        // Handle project month click (continuous range only)
        function handleProjectMonthClick(month, event) {
            if (!state.projectStartMonth) {
                // First click: set start
                state.projectStartMonth = month;
                state.projectEndMonth = month;
            } else if (state.projectStartMonth === state.projectEndMonth && state.projectStartMonth === month) {
                // Click on same month: deselect
                state.projectStartMonth = null;
                state.projectEndMonth = null;
            } else if (month < state.projectStartMonth) {
                // Click before start: reset with new start
                state.projectStartMonth = month;
                state.projectEndMonth = month;
            } else {
                // Click after start: extend to this month
                state.projectEndMonth = month;
            }

            updateUnifiedModalUI();
        }

        // Update save button state
        function updateUnifiedSaveButtonState() {
            let canSave = false;

            // Check if at least one section is properly configured
            if (state.preProjectSectionEnabled) {
                const validPercent = state.preProjectAllocationPercent >= 1 && state.preProjectAllocationPercent <= 100;
                const hasMonths = state.preProjectSelectedMonths.length > 0;
                if (validPercent && hasMonths) {
                    canSave = true;
                }
            }

            if (state.projectSectionEnabled) {
                const validPercent = state.projectAllocationPercent >= 1 && state.projectAllocationPercent <= 100;
                const hasRange = state.projectStartMonth && state.projectEndMonth;
                if (validPercent && hasRange) {
                    canSave = true;
                }
            }

            unifiedPromoteSaveBtn.disabled = !canSave;
        }

        // Save unified promotion
        function saveUnifiedPromotion() {
            if (!state.unifiedPromoteEngagementId) return;

            const allocation = {
                id: state.unifiedPromoteEngagementId,
                updatedAt: new Date().toISOString()
            };

            if (state.preProjectSectionEnabled && state.preProjectSelectedMonths.length > 0) {
                allocation.preProject = {
                    allocationPercentage: state.preProjectAllocationPercent,
                    months: [...state.preProjectSelectedMonths].sort()
                };
            }

            if (state.projectSectionEnabled && state.projectStartMonth && state.projectEndMonth) {
                allocation.project = {
                    allocationPercentage: state.projectAllocationPercent,
                    startMonth: state.projectStartMonth,
                    endMonth: state.projectEndMonth
                };
            }

            saveAllocation(allocation)
                .then(() => {
                    closeUnifiedPromoteModal();
                    renderEngagements();
                })
                .catch(err => console.error('Failed to save allocation:', err));
        }

        // Open comments panel for an engagement (Issue-57)
        function openCommentsPanel(engagementId) {
            const index = state.engagements.findIndex(e => e.id === engagementId);
            if (index >= 0) {
                openSidePanel(index);
            }
        }

        // Capitalize first letter
        function capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        // Generate status tooltip HTML
        function getStatusTooltipHtml(currentStatus) {
            const statusDescriptions = {
                active: {
                    brief: 'Currently being worked on',
                    detail: 'Default state for new engagements with linked Todos. Transitions to Paused (auto, when no undone Todos), Completed (Complete action), Closed (Close action), or Dropped (Cancel action).'
                },
                paused: {
                    brief: 'No active Todos linked',
                    detail: 'Auto-triggered when an Active engagement has no undone Todos linked. Auto-resumes to Active when an undone Todo is linked.'
                },
                completed: {
                    brief: 'Successfully finished',
                    detail: 'Transitioned from Active via the Complete action. Indicates all deliverables were met successfully. This is a final state.'
                },
                closed: {
                    brief: 'Ended normally',
                    detail: 'Transitioned from Active via the Close action. Ended normally but not necessarily with full delivery. Can be reactivated if needed.'
                },
                dropped: {
                    brief: 'Cancelled or abandoned',
                    detail: 'Transitioned from Active via the Cancel action. Cancelled or abandoned before completion due to changing priorities or external factors.'
                }
            };

            const currentDesc = statusDescriptions[currentStatus] || statusDescriptions.active;

            return `
                <div class="status-tooltip" onclick="event.stopPropagation();">
                    <div class="status-tooltip-header">Status: ${capitalizeFirst(currentStatus)}</div>
                    <div class="status-tooltip-brief">${currentDesc.brief}</div>
                    <span class="status-tooltip-link" onclick="event.stopPropagation(); event.preventDefault(); expandStatusTooltip(this);">Read more</span>
                    <div class="status-tooltip-expanded">
                        <div class="status-item">
                            <div class="status-item-name">Active</div>
                            <div class="status-item-desc">${statusDescriptions.active.detail}</div>
                        </div>
                        <div class="status-item">
                            <div class="status-item-name">Paused</div>
                            <div class="status-item-desc">${statusDescriptions.paused.detail}</div>
                        </div>
                        <div class="status-item">
                            <div class="status-item-name">Completed</div>
                            <div class="status-item-desc">${statusDescriptions.completed.detail}</div>
                        </div>
                        <div class="status-item">
                            <div class="status-item-name">Closed</div>
                            <div class="status-item-desc">${statusDescriptions.closed.detail}</div>
                        </div>
                        <div class="status-item">
                            <div class="status-item-name">Dropped</div>
                            <div class="status-item-desc">${statusDescriptions.dropped.detail}</div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Expand status tooltip
        function expandStatusTooltip(linkElement) {
            const tooltip = linkElement.closest('.status-tooltip');
            if (tooltip) {
                tooltip.classList.add('expanded');
            }
        }

        // Collapse all expanded status tooltips
        function collapseAllStatusTooltips() {
            document.querySelectorAll('.status-tooltip.expanded').forEach(tooltip => {
                tooltip.classList.remove('expanded');
            });
        }

        // Generate status badge with tooltip
        function getStatusBadgeWithTooltip(status, statusClass) {
            return `
                <div class="status-tooltip-container">
                    <span class="status-badge ${statusClass}">${capitalizeFirst(status)}</span>
                    ${getStatusTooltipHtml(status)}
                </div>
            `;
        }

        // Side Panel functions (Comments Only)
        function openSidePanel(index) {
            state.selectedEngagementIndex = index;
            state.sidePanelOpen = true;

            const opp = state.engagements[index];

            // Set engagement name in header
            const engNameEl = document.getElementById('side-panel-engagement-name');
            if (engNameEl) {
                engNameEl.textContent = opp.name || 'Unnamed Engagement';
            }

            // Render comments only
            renderCommentsInPanel(opp);

            // Show panel
            sidePanel.classList.add('open');
            sidePanelBackdrop.classList.add('open');
        }

        function closeSidePanel() {
            state.sidePanelOpen = false;
            state.selectedEngagementIndex = null;

            sidePanel.classList.remove('open');
            sidePanelBackdrop.classList.remove('open');
        }

        // Archive engagement (for closed/cancelled engagements)
        function archiveEngagement(index) {
            const opp = state.engagements[index];
            // Allow archiving for closed, completed, or dropped engagements
            if (opp.status !== 'closed' && opp.status !== 'completed' && opp.status !== 'dropped') return;

            opp.archived = true;

            // Close side panel if this engagement was open
            if (state.sidePanelOpen && state.selectedEngagementIndex === index) {
                closeSidePanel();
            }

            // Re-render engagements list
            renderEngagements();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Close engagement action (set status to Closed)
        function closeEngagementAction(index) {
            const opp = state.engagements[index];
            // Allow closing from active or paused status
            if (opp.status !== 'active' && opp.status !== 'paused') return;

            // Check for linked undone todos
            const undoneTodos = state.todos.filter(t =>
                t.engagementId === opp.id && !t.completed && !t.dropped
            );

            if (undoneTodos.length > 0) {
                // Show todo action modal to handle linked todos
                openTodoActionModal(index, 'close');
                return;
            }

            // No linked todos - proceed with close directly
            opp.status = 'closed';
            renderEngagements();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Complete engagement action (set status to Completed - final state)
        function completeEngagement(index) {
            const opp = state.engagements[index];
            // Allow completing from active or paused status
            if (opp.status !== 'active' && opp.status !== 'paused') return;

            opp.status = 'completed';

            // Auto-complete all linked todos that are not already completed or dropped
            const now = new Date().toISOString();
            state.todos.forEach(todo => {
                if (todo.engagementId === opp.id && !todo.completed && !todo.dropped) {
                    todo.completed = true;
                    todo.completedAt = now;
                    todo.updatedAt = now;
                }
            });

            renderEngagements();
            renderTodos();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Reactivate engagement (from Closed to Paused)
        function reactivateEngagement(index) {
            const opp = state.engagements[index];
            // Only allow reactivating from closed status
            if (opp.status !== 'closed') return;

            opp.status = 'paused';
            renderEngagements();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Uncancel engagement (from Dropped to Paused)
        function uncancelEngagement(index) {
            const opp = state.engagements[index];
            // Only allow uncancelling from dropped status
            if (opp.status !== 'dropped') return;

            opp.status = 'paused';
            renderEngagements();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // ========================================
        // ENGAGEMENT LIFECYCLE MANAGEMENT
        // ========================================

        // Get type display name
        function getTypeDisplayName(type) {
            const names = {
                'engagement': 'Engagement',
                'pre-project': 'Pre-Project',
                'project': 'Project'
            };
            return names[type] || 'Engagement';
        }

        // Get type CSS class
        function getTypeClass(type) {
            return `type-${type}`;
        }

        // Render lifecycle section in side panel
        function renderLifecycleSection(eng) {
            // Update type badge using dynamic type based on allocation dates (Issue-57)
            const displayType = getEngagementDisplayType(eng);
            panelEngTypeBadge.textContent = getTypeDisplayName(displayType);
            panelEngTypeBadge.className = `engagement-type-badge ${getTypeClass(displayType)}`;

            // Render action buttons based on type and status
            renderLifecycleActions(eng);

            // Show/hide sections based on type
            if (eng.type === 'engagement') {
                panelPreProjectSection.style.display = 'none';
                panelProjectSection.style.display = 'none';
            } else if (eng.type === 'pre-project') {
                panelPreProjectSection.style.display = 'block';
                panelProjectSection.style.display = 'none';
                renderPreProjectSection(eng);
            } else if (eng.type === 'project') {
                panelPreProjectSection.style.display = 'block';  // Show pre-project history
                panelProjectSection.style.display = 'block';
                renderPreProjectSection(eng);
                renderProjectSection(eng);
            }
        }

        // Render lifecycle action buttons
        function renderLifecycleActions(eng) {
            let buttons = '';

            if (eng.status === 'active') {
                if (eng.type === 'engagement') {
                    buttons = `
                        <button class="lifecycle-action-btn promote" onclick="openPromotePreProjectModal(${state.selectedEngagementIndex})">
                            Promote to Pre-Project
                        </button>
                    `;
                } else if (eng.type === 'pre-project') {
                    buttons = `
                        <button class="lifecycle-action-btn promote" onclick="openPromoteProjectModal(${state.selectedEngagementIndex})">
                            Promote to Project
                        </button>
                        <button class="lifecycle-action-btn secondary" onclick="revertToEngagement(${state.selectedEngagementIndex})">
                            Revert
                        </button>
                    `;
                } else if (eng.type === 'project') {
                    buttons = `
                        <button class="lifecycle-action-btn promote" onclick="completeProject(${state.selectedEngagementIndex})">
                            Complete Project
                        </button>
                    `;
                }
            }

            lifecycleActions.innerHTML = buttons;
        }

        // Render pre-project section
        function renderPreProjectSection(eng) {
            if (!eng.preProject) return;

            panelPreProjectStarted.value = eng.preProject.startedAt || '';
            panelPreProjectExpected.value = eng.preProject.expectedFormalization || '';

            // Render allocations table
            const tbody = panelPreProjectAllocations.querySelector('tbody');
            tbody.innerHTML = '';

            const allocations = eng.preProject.allocations || [];
            if (allocations.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: #6C757D;">No allocations yet</td></tr>';
            } else {
                allocations.forEach((alloc, idx) => {
                    const statusBadge = alloc.chargedToProject
                        ? '<span class="allocation-charged-badge">Charged</span>'
                        : '<span class="allocation-pending-badge">Pending</span>';

                    tbody.innerHTML += `
                        <tr>
                            <td>
                                <input type="month" value="${alloc.month}"
                                    onchange="updatePreProjectAllocation(${idx}, 'month', this.value)"
                                    ${alloc.chargedToProject ? 'disabled' : ''}>
                            </td>
                            <td>
                                <input type="number" value="${alloc.percentage}" min="0" max="100" style="width: 50px;"
                                    onchange="updatePreProjectAllocation(${idx}, 'percentage', this.value)"
                                    ${alloc.chargedToProject ? 'disabled' : ''}>
                            </td>
                            <td>
                                <input type="number" value="${alloc.hours || ''}" min="0" style="width: 50px;"
                                    onchange="updatePreProjectAllocation(${idx}, 'hours', this.value)"
                                    ${alloc.chargedToProject ? 'disabled' : ''}>
                            </td>
                            <td>${statusBadge}</td>
                            <td>
                                ${!alloc.chargedToProject ? `
                                    <button class="allocation-delete-btn" onclick="deletePreProjectAllocation(${idx})" title="Delete">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                                            <line x1="18" y1="6" x2="6" y2="18"></line>
                                            <line x1="6" y1="6" x2="18" y2="18"></line>
                                        </svg>
                                    </button>
                                ` : ''}
                            </td>
                        </tr>
                    `;
                });

                // Render summary
                renderPreProjectSummary(allocations);
            }
        }

        // Render pre-project allocation summary
        function renderPreProjectSummary(allocations) {
            if (allocations.length === 0) {
                panelPreProjectSummary.style.display = 'none';
                return;
            }

            const totalMonths = allocations.length;
            const totalPercentage = allocations.reduce((sum, a) => sum + (a.percentage || 0), 0);
            const avgPercentage = totalMonths > 0 ? Math.round(totalPercentage / totalMonths) : 0;
            const chargedMonths = allocations.filter(a => a.chargedToProject).length;
            const pendingMonths = totalMonths - chargedMonths;

            panelPreProjectSummary.innerHTML = `
                <div class="allocation-summary-row">
                    <span class="allocation-summary-label">Total Months</span>
                    <span class="allocation-summary-value">${totalMonths}</span>
                </div>
                <div class="allocation-summary-row">
                    <span class="allocation-summary-label">Average Allocation</span>
                    <span class="allocation-summary-value">${avgPercentage}%</span>
                </div>
                <div class="allocation-summary-row">
                    <span class="allocation-summary-label">Charged to Project</span>
                    <span class="allocation-summary-value">${chargedMonths}</span>
                </div>
                <div class="allocation-summary-row">
                    <span class="allocation-summary-label">Pending Charge-Back</span>
                    <span class="allocation-summary-value">${pendingMonths}</span>
                </div>
            `;
            panelPreProjectSummary.style.display = 'block';
        }

        // Render project section
        function renderProjectSection(eng) {
            if (!eng.project) return;

            panelProjectFormalized.value = eng.project.formalizedAt || '';
            panelProjectCode.value = eng.project.projectCode || '';
            panelProjectFunding.value = eng.project.fundingSource || '';

            if (eng.project.timeline) {
                panelProjectStart.value = eng.project.timeline.startDate || '';
                panelProjectEnd.value = eng.project.timeline.endDate || '';

                // Render project allocations
                const tbody = panelProjectAllocations.querySelector('tbody');
                tbody.innerHTML = '';

                const allocations = eng.project.timeline.allocations || [];
                if (allocations.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #6C757D;">No allocation periods</td></tr>';
                } else {
                    allocations.forEach((alloc, idx) => {
                        const statusOptions = ['planned', 'active', 'completed', 'cancelled']
                            .map(s => `<option value="${s}" ${alloc.status === s ? 'selected' : ''}>${capitalizeFirst(s)}</option>`)
                            .join('');

                        tbody.innerHTML += `
                            <tr>
                                <td>${formatDate(alloc.periodStart)} - ${formatDate(alloc.periodEnd)}</td>
                                <td>${alloc.percentage}%</td>
                                <td>
                                    <select onchange="updateProjectAllocationStatus(${idx}, this.value)">
                                        ${statusOptions}
                                    </select>
                                </td>
                                <td>
                                    <button class="allocation-delete-btn" onclick="deleteProjectAllocation(${idx})" title="Delete">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                                            <line x1="18" y1="6" x2="6" y2="18"></line>
                                            <line x1="6" y1="6" x2="18" y2="18"></line>
                                        </svg>
                                    </button>
                                </td>
                            </tr>
                        `;
                    });
                }
            }

            // Render charge-back section if applicable
            renderChargeBackSection(eng);
        }

        // Render charge-back section
        function renderChargeBackSection(eng) {
            if (!eng.project || !eng.project.preProjectMonthsCharged || eng.project.preProjectMonthsCharged.length === 0) {
                panelChargeBackSection.style.display = 'none';
                return;
            }

            const chargebacks = eng.project.preProjectMonthsCharged;
            const totalCharged = chargebacks.reduce((sum, cb) => sum + cb.chargedPercentage, 0);

            panelChargeBackSummary.textContent = `${chargebacks.length} months charged back (total: ${totalCharged}% allocation-months)`;

            let listHtml = '';
            chargebacks.forEach(cb => {
                listHtml += `
                    <div class="chargeback-item">
                        <span>${formatMonth(cb.originalMonth)}: ${cb.originalPercentage}% â†’ ${cb.chargedPercentage}%</span>
                        <span style="color: #6C757D; font-size: 11px;">${formatDate(cb.chargedAt)}</span>
                    </div>
                `;
            });
            panelChargeBackList.innerHTML = listHtml;

            panelChargeBackSection.style.display = 'block';
        }

        // Format month for display
        function formatMonth(monthStr) {
            if (!monthStr) return '';
            const [year, month] = monthStr.split('-');
            const date = new Date(year, parseInt(month) - 1, 1);
            return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
        }

        // Add pre-project allocation
        function addPreProjectAllocation() {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.preProject) return;

            // Default to current month
            const now = new Date();
            const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;

            eng.preProject.allocations = eng.preProject.allocations || [];
            eng.preProject.allocations.push({
                month: currentMonth,
                percentage: 0,
                hours: null,
                notes: null,
                chargedToProject: false,
                chargedAt: null
            });

            renderPreProjectSection(eng);
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Update pre-project allocation field
        function updatePreProjectAllocation(idx, field, value) {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.preProject || !eng.preProject.allocations[idx]) return;

            const alloc = eng.preProject.allocations[idx];
            if (field === 'percentage' || field === 'hours') {
                alloc[field] = value ? parseInt(value) : null;
            } else {
                alloc[field] = value;
            }

            renderPreProjectSummary(eng.preProject.allocations);
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Delete pre-project allocation
        function deletePreProjectAllocation(idx) {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.preProject || !eng.preProject.allocations[idx]) return;

            eng.preProject.allocations.splice(idx, 1);
            renderPreProjectSection(eng);
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Save pre-project field
        function savePreProjectField(field, value) {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.preProject) return;

            eng.preProject[field] = value || null;
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Save project field
        function saveProjectField(field, value) {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.project) return;

            eng.project[field] = value || null;
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Save project timeline field
        function saveProjectTimelineField(field, value) {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.project || !eng.project.timeline) return;

            eng.project.timeline[field] = value || null;
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Add project allocation period
        function addProjectAllocation() {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.project || !eng.project.timeline) return;

            // Default to project start/end dates or current month
            const startDate = eng.project.timeline.startDate || getTodayDate();
            const endDate = eng.project.timeline.endDate || getTodayDate();

            eng.project.timeline.allocations = eng.project.timeline.allocations || [];
            eng.project.timeline.allocations.push({
                periodStart: startDate,
                periodEnd: endDate,
                percentage: 25,
                status: 'planned'
            });

            renderProjectSection(eng);
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Update project allocation status
        function updateProjectAllocationStatus(idx, status) {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.project || !eng.project.timeline || !eng.project.timeline.allocations[idx]) return;

            eng.project.timeline.allocations[idx].status = status;
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Delete project allocation
        function deleteProjectAllocation(idx) {
            if (state.selectedEngagementIndex === null) return;
            const eng = state.engagements[state.selectedEngagementIndex];
            if (!eng.project || !eng.project.timeline || !eng.project.timeline.allocations[idx]) return;

            eng.project.timeline.allocations.splice(idx, 1);
            renderProjectSection(eng);
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // ========================================
        // PROMOTE TO PRE-PROJECT
        // ========================================

        function openPromotePreProjectModal(index) {
            state.promoteEngagementIndex = index;
            state.promotePreProjectModalOpen = true;

            const eng = state.engagements[index];
            promotePreProjectName.textContent = `"${eng.name}"`;

            // Default start date to engagement start date or today
            preProjectStartedInput.value = eng.startDate || getTodayDate();
            preProjectExpectedInput.value = '';

            promotePreProjectModal.classList.remove('hidden');
        }

        function closePromotePreProjectModal() {
            promotePreProjectModal.classList.add('hidden');
            state.promotePreProjectModalOpen = false;
            state.promoteEngagementIndex = null;
        }

        function confirmPromoteToPreProject() {
            if (state.promoteEngagementIndex === null) return;

            const eng = state.engagements[state.promoteEngagementIndex];
            const startedAt = preProjectStartedInput.value;
            const expectedFormalization = preProjectExpectedInput.value;

            if (!startedAt) {
                alert('Please select a start date');
                return;
            }

            // Update engagement
            eng.type = 'pre-project';
            eng.preProject = {
                startedAt: startedAt,
                expectedFormalization: expectedFormalization || null,
                allocations: []
            };

            closePromotePreProjectModal();
            renderEngagements();

            // Refresh side panel if open
            if (state.sidePanelOpen && state.selectedEngagementIndex === state.promoteEngagementIndex) {
                openSidePanel(state.promoteEngagementIndex);
            }

            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // ========================================
        // PROMOTE TO PROJECT
        // ========================================

        function openPromoteProjectModal(index) {
            state.promoteEngagementIndex = index;
            state.promoteProjectModalOpen = true;
            state.selectedChargeBackMode = 'original';

            const eng = state.engagements[index];
            promoteProjectName.textContent = `"${eng.name}"`;

            // Default formalization date to today
            projectFormalizedInput.value = getTodayDate();
            projectCodeInput.value = '';
            projectFundingInput.value = '';
            projectStartInput.value = getTodayDate();
            projectEndInput.value = '';
            projectAllocationInput.value = '25';

            // Show charge-back options if there are pre-project allocations
            if (eng.preProject && eng.preProject.allocations && eng.preProject.allocations.length > 0) {
                chargeBackOptions.style.display = 'block';
                // Reset to original mode
                selectChargeBackMode('original');
            } else {
                chargeBackOptions.style.display = 'none';
            }

            promoteProjectModal.classList.remove('hidden');
        }

        function closePromoteProjectModal() {
            promoteProjectModal.classList.add('hidden');
            state.promoteProjectModalOpen = false;
            state.promoteEngagementIndex = null;
        }

        function selectChargeBackMode(mode) {
            state.selectedChargeBackMode = mode;

            // Update UI
            document.querySelectorAll('.chargeback-mode-option').forEach(opt => {
                opt.classList.remove('selected');
                const radio = opt.querySelector('input[type="radio"]');
                if (radio && radio.value === mode) {
                    opt.classList.add('selected');
                    radio.checked = true;
                }
            });
        }

        function confirmPromoteToProject() {
            if (state.promoteEngagementIndex === null) return;

            const eng = state.engagements[state.promoteEngagementIndex];
            const formalizedAt = projectFormalizedInput.value;
            const projectCode = projectCodeInput.value.trim();
            const fundingSource = projectFundingInput.value.trim();
            const startDate = projectStartInput.value;
            const endDate = projectEndInput.value;
            const allocation = parseInt(projectAllocationInput.value) || 25;

            if (!formalizedAt || !startDate) {
                alert('Please fill in the formalization date and project start date');
                return;
            }

            // Process charge-back for pre-project allocations
            const chargeBackRecords = [];
            if (eng.preProject && eng.preProject.allocations && state.selectedChargeBackMode !== 'none') {
                eng.preProject.allocations.forEach(alloc => {
                    if (!alloc.chargedToProject && alloc.month < startDate.substring(0, 7)) {
                        const chargedPercentage = state.selectedChargeBackMode === 'project_rate'
                            ? allocation
                            : alloc.percentage;

                        chargeBackRecords.push({
                            originalMonth: alloc.month,
                            originalPercentage: alloc.percentage,
                            chargedPercentage: chargedPercentage,
                            chargedAt: new Date().toISOString(),
                            notes: `Charged via ${state.selectedChargeBackMode} mode`
                        });

                        // Mark original allocation as charged
                        alloc.chargedToProject = true;
                        alloc.chargedAt = new Date().toISOString();
                    }
                });
            }

            // Update engagement to project
            eng.type = 'project';
            eng.project = {
                formalizedAt: formalizedAt,
                projectCode: projectCode || null,
                fundingSource: fundingSource || null,
                timeline: {
                    startDate: startDate,
                    endDate: endDate || null,
                    actualEndDate: null,
                    allocations: [{
                        periodStart: startDate,
                        periodEnd: endDate || startDate,
                        percentage: allocation,
                        status: 'active'
                    }]
                },
                preProjectMonthsCharged: chargeBackRecords
            };

            closePromoteProjectModal();
            renderEngagements();

            // Refresh side panel if open
            if (state.sidePanelOpen && state.selectedEngagementIndex === state.promoteEngagementIndex) {
                openSidePanel(state.promoteEngagementIndex);
            }

            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Revert pre-project back to engagement
        function revertToEngagement(index) {
            const eng = state.engagements[index];
            if (eng.type !== 'pre-project') return;

            if (!confirm('Are you sure you want to revert this pre-project back to an engagement? All pre-project allocation data will be lost.')) {
                return;
            }

            eng.type = 'engagement';
            eng.preProject = null;

            renderEngagements();

            // Refresh side panel if open
            if (state.sidePanelOpen && state.selectedEngagementIndex === index) {
                openSidePanel(index);
            }

            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Complete project
        function completeProject(index) {
            const eng = state.engagements[index];
            if (eng.type !== 'project' || eng.status !== 'active') return;

            eng.status = 'completed';
            if (eng.project && eng.project.timeline) {
                eng.project.timeline.actualEndDate = getTodayDate();
            }

            // Mark all active allocations as completed
            if (eng.project && eng.project.timeline && eng.project.timeline.allocations) {
                eng.project.timeline.allocations.forEach(alloc => {
                    if (alloc.status === 'active' || alloc.status === 'planned') {
                        alloc.status = 'completed';
                    }
                });
            }

            renderEngagements();

            // Refresh side panel if open
            if (state.sidePanelOpen && state.selectedEngagementIndex === index) {
                openSidePanel(index);
            }

            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Open delete confirmation modal
        function openDeleteConfirmation(index) {
            state.deleteEngagementIndex = index;
            state.confirmModalOpen = true;

            const opp = state.engagements[index];
            confirmMessage.textContent = `Are you sure you want to delete "${opp.name}"? This action cannot be undone.`;

            confirmModal.classList.remove('hidden');
        }

        // Close confirmation modal
        function closeConfirmModal() {
            confirmModal.classList.add('hidden');
            state.confirmModalOpen = false;
            state.deleteEngagementIndex = null;
        }

        // Confirm and execute engagement deletion
        function confirmDeleteEngagement() {
            if (state.deleteEngagementIndex === null) return;

            const oppId = state.engagements[state.deleteEngagementIndex].id;

            // Remove engagement link from all associated todos
            state.todos.forEach(todo => {
                if (todo.engagementId === oppId) {
                    todo.engagementId = null;
                }
            });

            // Remove the engagement
            state.engagements.splice(state.deleteEngagementIndex, 1);

            // Close side panel if the deleted engagement was open
            if (state.sidePanelOpen && state.selectedEngagementIndex === state.deleteEngagementIndex) {
                closeSidePanel();
            } else if (state.sidePanelOpen && state.selectedEngagementIndex > state.deleteEngagementIndex) {
                // Adjust index if needed
                state.selectedEngagementIndex--;
            }

            // Close confirmation modal
            closeConfirmModal();

            // Re-render both lists
            renderEngagements();
            renderTodos();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // =============================================
        // Cancel Engagement Functions
        // =============================================

        // Open cancel confirmation modal
        function openCancelConfirmation(index, skipTodoCheck = false) {
            const opp = state.engagements[index];

            // Check for linked undone todos (unless we already handled them)
            if (!skipTodoCheck) {
                const undoneTodos = state.todos.filter(t =>
                    t.engagementId === opp.id && !t.completed && !t.dropped
                );

                if (undoneTodos.length > 0) {
                    // Show todo action modal to handle linked todos
                    openTodoActionModal(index, 'cancel');
                    return;
                }
            }

            // No linked todos or already handled - show cancel reason modal
            state.cancelEngagementIndex = index;
            state.cancelModalOpen = true;

            cancelOppName.textContent = `"${opp.name}"`;
            cancelReason.value = '';

            cancelModal.classList.remove('hidden');
            setTimeout(() => cancelReason.focus(), 100);
        }

        // Close cancel modal
        function closeCancelModal() {
            cancelModal.classList.add('hidden');
            state.cancelModalOpen = false;
            state.cancelEngagementIndex = null;
            cancelReason.value = '';
        }

        // Confirm and execute engagement cancellation
        function confirmCancelEngagement() {
            if (state.cancelEngagementIndex === null) return;

            const reason = cancelReason.value.trim();
            if (!reason) {
                cancelReason.focus();
                return;
            }

            const opp = state.engagements[state.cancelEngagementIndex];

            // Initialize comments array if not exists (for backwards compatibility)
            if (!opp.comments) {
                opp.comments = [];
            }

            // Add cancellation comment
            opp.comments.push({
                text: reason,
                timestamp: new Date().toISOString(),
                type: 'cancellation'
            });

            // Set status to dropped (new lifecycle model)
            opp.status = 'dropped';

            // Refresh comments in side panel if open
            if (state.sidePanelOpen && state.selectedEngagementIndex === state.cancelEngagementIndex) {
                renderCommentsInPanel(opp);
            }

            // Close cancel modal
            closeCancelModal();

            // Re-render engagements and todos list
            renderEngagements();
            renderTodos();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // ========================================
        // TODO ACTION MODAL (for Close/Cancel with linked todos)
        // ========================================

        // Get linked undone todos for an engagement
        function getLinkedUndoneTodos(engagementId) {
            return state.todos.filter(t =>
                t.engagementId === engagementId && !t.completed && !t.dropped
            );
        }

        // Open Todo Action Modal
        function openTodoActionModal(index, actionType) {
            const opp = state.engagements[index];
            const undoneTodos = getLinkedUndoneTodos(opp.id);

            state.todoActionModalOpen = true;
            state.todoActionEngagementIndex = index;
            state.todoActionType = actionType;

            todoActionModalTitle.textContent = actionType === 'close'
                ? 'Close Engagement'
                : 'Cancel Engagement';
            todoActionEngName.textContent = `"${opp.name}"`;
            todoActionCount.textContent = `${undoneTodos.length} linked todo${undoneTodos.length !== 1 ? 's' : ''} will be affected`;

            todoActionModal.classList.remove('hidden');
        }

        // Close Todo Action Modal
        function closeTodoActionModal() {
            todoActionModal.classList.add('hidden');
            state.todoActionModalOpen = false;
            state.todoActionEngagementIndex = null;
            state.todoActionType = null;
        }

        // Todo Action: Complete all linked todos
        function todoActionComplete() {
            if (state.todoActionEngagementIndex === null) return;

            const opp = state.engagements[state.todoActionEngagementIndex];
            const now = new Date().toISOString();

            // Complete all linked undone todos
            state.todos.forEach(todo => {
                if (todo.engagementId === opp.id && !todo.completed && !todo.dropped) {
                    todo.completed = true;
                    todo.completedAt = now;
                    todo.updatedAt = now;
                }
            });

            // Continue with the close/cancel action
            finishEngagementAction();
        }

        // Todo Action: Drop all linked todos
        function todoActionDrop() {
            if (state.todoActionEngagementIndex === null) return;

            const opp = state.engagements[state.todoActionEngagementIndex];
            const now = new Date().toISOString();

            // Drop all linked undone todos
            state.todos.forEach(todo => {
                if (todo.engagementId === opp.id && !todo.completed && !todo.dropped) {
                    todo.dropped = true;
                    todo.droppedAt = now;
                    todo.updatedAt = now;
                }
            });

            // Continue with the close/cancel action
            finishEngagementAction();
        }

        // Todo Action: Delete all linked todos
        function todoActionDelete() {
            if (state.todoActionEngagementIndex === null) return;

            const opp = state.engagements[state.todoActionEngagementIndex];

            // Delete all linked undone todos
            state.todos = state.todos.filter(todo =>
                !(todo.engagementId === opp.id && !todo.completed && !todo.dropped)
            );

            // Continue with the close/cancel action
            finishEngagementAction();
        }

        // Finish the engagement close/cancel action after handling todos
        function finishEngagementAction() {
            const index = state.todoActionEngagementIndex;
            const actionType = state.todoActionType;

            closeTodoActionModal();

            if (actionType === 'close') {
                // Direct close without modal
                const opp = state.engagements[index];
                opp.status = 'closed';
            } else if (actionType === 'cancel') {
                // Open cancel modal for reason (skip todo check since we just handled them)
                openCancelConfirmation(index, true);
                return; // Don't save or render yet - wait for cancel confirmation
            }

            renderEngagements();
            renderTodos();
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Format datetime for display
        function formatDateTime(isoString) {
            const date = new Date(isoString);
            const options = {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            };
            return date.toLocaleString('en-US', options);
        }

        // Render comments in side panel
        function renderCommentsInPanel(opp) {
            // Initialize comments array if not exists
            const comments = opp.comments || [];

            if (comments.length === 0) {
                panelComments.innerHTML = '<p class="no-comments">No comments yet</p>';
                return;
            }

            panelComments.innerHTML = comments.map((comment, index) => {
                const isCancellation = comment.type === 'cancellation';
                const badge = isCancellation ? '<span class="comment-badge cancellation">Cancellation</span>' : '';
                return `
                    <div class="comment-item ${isCancellation ? 'cancellation' : ''}">
                        <div class="comment-header">
                            <div class="comment-timestamp">${formatDateTime(comment.timestamp)}${badge}</div>
                            <button class="comment-delete-btn" onclick="deleteComment(${index})" title="Delete comment">&times;</button>
                        </div>
                        <div class="comment-text">${escapeHtml(comment.text)}</div>
                    </div>
                `;
            }).join('');
        }

        // Add a new comment to the current engagement
        function addComment() {
            if (state.selectedEngagementIndex === null) return;

            const text = commentInput.value.trim();
            if (!text) return;

            const opp = state.engagements[state.selectedEngagementIndex];

            // Initialize comments array if not exists
            if (!opp.comments) {
                opp.comments = [];
            }

            // Add new standard comment
            opp.comments.push({
                text: text,
                timestamp: new Date().toISOString(),
                type: 'standard'
            });

            // Clear input
            commentInput.value = '';

            // Re-render comments
            renderCommentsInPanel(opp);
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Delete a comment from the current engagement
        function deleteComment(commentIndex) {
            if (state.selectedEngagementIndex === null) return;

            const opp = state.engagements[state.selectedEngagementIndex];
            if (!opp || !opp.comments || commentIndex < 0 || commentIndex >= opp.comments.length) return;

            // Remove the comment
            opp.comments.splice(commentIndex, 1);

            // Re-render comments
            renderCommentsInPanel(opp);
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // =============================================
        // Autocomplete Functions for Todo-Engagement Linking
        // =============================================

        // Filter engagements based on search query
        function filterEngagements(query) {
            if (!query || query.trim() === '') return [];
            const lowerQuery = query.toLowerCase().trim();
            return state.engagements.filter(opp => {
                const nameMatches = opp.name.toLowerCase().includes(lowerQuery);
                if (!nameMatches) return false;

                // Filter out closed and dropped engagements unless exact match
                const isClosedOrDropped = opp.status === 'closed' || opp.status === 'dropped';
                if (isClosedOrDropped) {
                    // Only show if exact match (case insensitive)
                    return opp.name.toLowerCase() === lowerQuery;
                }
                return true;
            });
        }

        // Render autocomplete dropdown
        function renderAutocompleteDropdown(query) {
            const matches = filterEngagements(query);
            engagementDropdown.innerHTML = '';

            if (matches.length > 0) {
                matches.forEach((opp, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.setAttribute('data-index', index);
                    item.setAttribute('data-id', opp.id);
                    item.innerHTML = `
                        <div class="autocomplete-item-name">${escapeHtml(opp.name)}</div>
                        ${opp.contact ? `<div class="autocomplete-item-contact">${escapeHtml(opp.contact)}</div>` : ''}
                    `;
                    item.onclick = () => selectEngagement(opp);
                    engagementDropdown.appendChild(item);
                });
            } else if (query && query.trim() !== '') {
                // Show hint to create new
                const hint = document.createElement('div');
                hint.className = 'autocomplete-empty';
                hint.textContent = 'No matches found';
                engagementDropdown.appendChild(hint);

                const createHint = document.createElement('div');
                createHint.className = 'autocomplete-create-hint';
                createHint.textContent = 'Press Enter to create new engagement';
                engagementDropdown.appendChild(createHint);
            }

            // Update highlight
            state.autocompleteHighlightIndex = -1;
            updateAutocompleteHighlight();
        }

        // Update autocomplete item highlight
        function updateAutocompleteHighlight() {
            const items = engagementDropdown.querySelectorAll('.autocomplete-item');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.autocompleteHighlightIndex);
            });
        }

        // Select an engagement from dropdown
        function selectEngagement(opp) {
            state.selectedEngagementId = opp.id;
            state.pendingEngagement = null;
            todoEngagementInput.value = opp.name;
            todoEngagementClear.classList.add('visible');
            closeAutocompleteDropdown();
            closeInlineOppForm();
        }

        // Clear engagement selection
        function clearEngagementSelection() {
            state.selectedEngagementId = null;
            state.pendingEngagement = null;
            todoEngagementInput.value = '';
            todoEngagementClear.classList.remove('visible');
            closeAutocompleteDropdown();
            closeInlineOppForm();
        }

        // Open autocomplete dropdown
        function openAutocompleteDropdown() {
            state.autocompleteOpen = true;
            engagementDropdown.classList.add('open');
        }

        // Close autocomplete dropdown
        function closeAutocompleteDropdown() {
            state.autocompleteOpen = false;
            state.autocompleteHighlightIndex = -1;
            engagementDropdown.classList.remove('open');
        }

        // Update Todo Save button state based on inline forms
        function updateTodoSaveButtonState() {
            const isInlineFormOpen = state.inlineEngFormOpen || state.inlineEngPersonFormOpen;

            if (isInlineFormOpen) {
                todoSaveBtn.disabled = true;
                todoSaveBtn.classList.add('btn-disabled');
                todoSaveWrapper.setAttribute('data-tooltip', 'Complete or cancel the inline form first');
            } else {
                todoSaveBtn.disabled = false;
                todoSaveBtn.classList.remove('btn-disabled');
                todoSaveWrapper.removeAttribute('data-tooltip');
            }
        }

        // Toggle tabindex on focusable elements inside a form container
        // When enabled=false, sets tabindex=-1 to remove from tab order
        // When enabled=true, removes tabindex to restore default tab behavior
        function setFormTabIndex(formElement, enabled, excludeSelector = null) {
            if (!formElement) return; // Guard against null elements
            const focusables = formElement.querySelectorAll('input, button, select, textarea, [tabindex]');
            focusables.forEach(el => {
                // Skip elements that match the exclude selector
                if (excludeSelector && el.closest(excludeSelector)) return;

                if (enabled) {
                    el.removeAttribute('tabindex');
                } else {
                    el.setAttribute('tabindex', '-1');
                }
            });
        }

        // Open inline engagement form with slide animation
        function openInlineEngForm(name) {
            state.inlineEngFormOpen = true;
            updateTodoSaveButtonState();
            inlineEngName.value = name;
            inlineEngDescription.value = '';
            inlineEngStartDate.value = getTodayDate();
            inlineEngContact.value = '';
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;
            inlineEngContactClear.classList.remove('visible');
            closeAutocompleteDropdown();

            // Expand dialog horizontally
            todoModalContent.classList.add('expanded');
            todoFormColumns.classList.add('expanded');
            todoFormLeft.classList.add('disabled');
            todoFormRight.classList.add('animate-in');

            // Enable tab navigation for right panel, but exclude nested person form
            setFormTabIndex(todoFormRight, true, '#inline-eng-person-form');

            // Disable tab navigation for left form (except engagement field which shows selection)
            setFormTabIndex(todoFormLeft, false);

            // Focus on description after animation (150ms as per spec)
            setTimeout(() => inlineEngDescription.focus(), 150);
        }

        // Close inline engagement form
        function closeInlineOppForm() {
            state.inlineEngFormOpen = false;
            updateTodoSaveButtonState();

            // Also close nested person form if open
            if (state.inlineEngPersonFormOpen) {
                closeInlineOppPersonForm();
            }

            // Collapse dialog horizontally
            todoModalContent.classList.remove('expanded');
            todoFormColumns.classList.remove('expanded');
            todoFormLeft.classList.remove('disabled');
            todoFormRight.classList.remove('animate-in');

            // Disable tab navigation for all elements inside right panel
            setFormTabIndex(todoFormRight, false);

            // Re-enable tab navigation for left form
            setFormTabIndex(todoFormLeft, true);
        }

        // Cancel inline engagement creation
        function cancelInlineEngagement() {
            state.pendingEngagement = null;
            todoEngagementInput.value = '';
            todoEngagementClear.classList.remove('visible');
            closeInlineOppForm();
            // Focus back to engagement field
            setTimeout(() => todoEngagementInput.focus(), 150);
        }

        // Confirm inline engagement creation
        function confirmInlineEngagement() {
            const name = inlineEngName.value.trim();
            if (!name) return;

            // Store pending engagement data (will be created when todo is saved)
            state.pendingEngagement = {
                name: name,
                description: inlineEngDescription.value.trim(),
                startDate: inlineEngStartDate.value,
                contact: inlineEngContact.value.trim(),
                // Include person data for the contact
                contactPersonId: state.selectedInlineOppPersonId,
                pendingPerson: state.pendingInlineOppPerson
            };

            // Update UI to show it's selected
            todoEngagementInput.value = name + ' (new)';
            todoEngagementClear.classList.add('visible');
            closeInlineOppForm();
            // Focus on Tags field after collapse
            setTimeout(() => todoTagInput.focus(), 150);
        }

        // Handle autocomplete input events
        todoEngagementInput.addEventListener('input', (e) => {
            const query = e.target.value;

            // Reset selection when typing
            state.selectedEngagementId = null;
            state.pendingEngagement = null;

            // Show/hide clear button
            todoEngagementClear.classList.toggle('visible', query.length > 0);

            // Close inline form if open
            if (state.inlineEngFormOpen) {
                closeInlineOppForm();
            }

            // Render and open dropdown
            if (query.trim() !== '') {
                renderAutocompleteDropdown(query);
                openAutocompleteDropdown();
                // Auto-highlight first match when typing
                const matches = filterEngagements(query);
                if (matches.length > 0) {
                    state.autocompleteHighlightIndex = 0;
                    updateAutocompleteHighlight();
                }
            } else {
                closeAutocompleteDropdown();
            }
        });

        // Handle autocomplete keyboard navigation
        todoEngagementInput.addEventListener('keydown', (e) => {
            const items = engagementDropdown.querySelectorAll('.autocomplete-item');
            const matches = filterEngagements(todoEngagementInput.value);
            const query = todoEngagementInput.value.trim();

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.autocompleteOpen && items.length > 0) {
                    state.autocompleteHighlightIndex = Math.min(state.autocompleteHighlightIndex + 1, items.length - 1);
                    updateAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.autocompleteOpen && items.length > 0) {
                    state.autocompleteHighlightIndex = Math.max(state.autocompleteHighlightIndex - 1, 0);
                    updateAutocompleteHighlight();
                }
            } else if (e.key === 'Tab' && !e.shiftKey) {
                // Tab behavior (forward only, let Shift+Tab work naturally):
                // 1. If matches exist, select first/highlighted and move to Tags
                // 2. If no matches but text entered, open inline creation
                // 3. If no text, natural tab
                if (matches.length > 0) {
                    e.preventDefault();
                    const indexToSelect = state.autocompleteHighlightIndex >= 0 ? state.autocompleteHighlightIndex : 0;
                    selectEngagement(matches[indexToSelect]);
                    todoTagInput.focus();
                } else if (query && !state.inlineEngFormOpen) {
                    e.preventDefault();
                    openInlineEngForm(query);
                }
                // If no text entered, let Tab naturally move to next control
            } else if (e.key === 'Enter') {
                e.preventDefault();

                // Check for exact match (case-insensitive)
                const exactMatch = matches.find(opp => opp.name.toLowerCase() === query.toLowerCase());

                if (state.autocompleteHighlightIndex >= 0 && matches.length > 0) {
                    // Select highlighted item
                    selectEngagement(matches[state.autocompleteHighlightIndex]);
                } else if (exactMatch) {
                    // Exact match - select it and move to next field
                    selectEngagement(exactMatch);
                    todoTagInput.focus();
                } else if (query && !state.inlineEngFormOpen) {
                    // Partial match or no matches - open inline creation form
                    openInlineEngForm(query);
                }
            } else if (e.key === 'Escape') {
                if (state.autocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeAutocompleteDropdown();
                }
            }
        });

        // Handle inline engagement description Enter key - move to Contact field
        inlineEngDescription.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                // Move focus to Contact field and scroll
                inlineEngContact.focus();
                setTimeout(() => {
                    inlineEngContact.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        });

        // Handle inline engagement name Enter key - move to Description field
        inlineEngName.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                inlineEngDescription.focus();
            }
        });

        // Handle inline engagement start date Enter key - move to Contact field
        inlineEngStartDate.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                inlineEngContact.focus();
                setTimeout(() => {
                    inlineEngContact.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        });

        // =============================================
        // People Management Functions
        // =============================================

        // Render people list
        function renderPeople() {
            peopleList.innerHTML = '';

            if (state.people.length === 0) {
                // Show empty state
                peopleList.classList.add('hidden');
                peopleEmptyState.classList.remove('hidden');
                peopleShortcutHintFloating.classList.add('hidden');
                rolesSection.classList.add('hidden');
            } else {
                // Show people list
                peopleList.classList.remove('hidden');
                peopleEmptyState.classList.add('hidden');
                peopleShortcutHintFloating.classList.remove('hidden');

                state.people.forEach((person, index) => {
                    const personItem = document.createElement('div');
                    personItem.className = 'person-item';

                    const roleName = person.roleId ? getRoleName(person.roleId) : '';

                    personItem.innerHTML = `
                        <div class="person-info">
                            <div class="person-name">${escapeHtml(person.name)}</div>
                            ${roleName ? `<span class="person-role-badge">${escapeHtml(roleName)}</span>` : ''}
                        </div>
                        <div class="person-actions">
                            <button class="action-btn" onclick="event.stopPropagation(); openPersonModal(${index})" title="Edit">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                            <button class="action-btn action-btn-danger" onclick="event.stopPropagation(); openDeletePersonModal(${index})" title="Delete">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                            </button>
                        </div>
                    `;

                    peopleList.appendChild(personItem);
                });

                // Show roles section if there are roles
                if (state.roles.length > 0) {
                    rolesSection.classList.remove('hidden');
                    renderRoles();
                } else {
                    rolesSection.classList.add('hidden');
                }
            }

            saveData();
        }

        // Render roles list
        function renderRoles() {
            rolesList.innerHTML = '';
            state.roles.forEach(role => {
                const roleTag = document.createElement('span');
                roleTag.className = 'role-tag';
                roleTag.textContent = role.name;
                rolesList.appendChild(roleTag);
            });
        }

        // Render tags list in Settings
        function renderTags() {
            tagsList.innerHTML = '';

            if (state.tags.length === 0) {
                // Show empty state
                tagsList.classList.add('hidden');
                tagsEmptyState.classList.remove('hidden');
                tagsShortcutHintFloating.classList.add('hidden');
            } else {
                // Show tags list
                tagsList.classList.remove('hidden');
                tagsEmptyState.classList.add('hidden');
                tagsShortcutHintFloating.classList.remove('hidden');

                state.tags.forEach((tag, index) => {
                    const tagItem = document.createElement('div');
                    tagItem.className = 'tag-item';

                    tagItem.innerHTML = `
                        <div class="tag-info">
                            <div class="tag-color-preview" style="background-color: ${tag.color}"></div>
                            <div class="tag-name">${escapeHtml(tag.name)}</div>
                        </div>
                        <div class="tag-actions">
                            <button class="action-btn" onclick="event.stopPropagation(); openTagModal(${index})" title="Edit">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                            <button class="action-btn action-btn-danger" onclick="event.stopPropagation(); deleteTag(${index})" title="Delete">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                            </button>
                        </div>
                    `;

                    tagsList.appendChild(tagItem);
                });
            }

            saveData();
        }

        // Open tag modal
        function openTagModal(tagIndex = null) {
            state.tagModalOpen = true;
            state.editingTagIndex = tagIndex;

            if (tagIndex !== null) {
                // Edit mode
                const tag = state.tags[tagIndex];
                tagModalTitle.textContent = 'Edit Tag';
                tagNameInput.value = tag.name;
                tagColorInput.value = tag.color;
                updateColorPreview(tag.color);
            } else {
                // Create mode
                tagModalTitle.textContent = 'New Tag';
                tagNameInput.value = '';
                tagColorInput.value = '#F59E0B';
                updateColorPreview('#F59E0B');
            }

            tagModal.classList.remove('hidden');
            setTimeout(() => tagNameInput.focus(), 100);
        }

        // Close tag modal
        function closeTagModal() {
            state.tagModalOpen = false;
            state.editingTagIndex = null;
            tagModal.classList.add('hidden');
            tagForm.reset();
        }

        // Update color preview
        function updateColorPreview(color) {
            tagColorPreview.style.backgroundColor = color;
            tagColorValue.textContent = color.toUpperCase();
        }

        // Save tag
        function saveTag(e) {
            e.preventDefault();

            const name = tagNameInput.value.trim();
            if (!name) return;

            const color = tagColorInput.value;

            if (state.editingTagIndex !== null) {
                // Update existing tag
                state.tags[state.editingTagIndex].name = name;
                state.tags[state.editingTagIndex].color = color;
            } else {
                // Create new tag
                const newTag = {
                    id: generateId(),
                    name: name,
                    color: color,
                    createdAt: new Date().toISOString()
                };
                state.tags.push(newTag);
            }

            closeTagModal();
            renderTags();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Delete tag
        function deleteTag(index) {
            const tag = state.tags[index];

            // Remove tag from all todos and engagements
            state.todos.forEach(todo => {
                if (todo.tagIds) {
                    todo.tagIds = todo.tagIds.filter(id => id !== tag.id);
                }
            });
            state.engagements.forEach(opp => {
                if (opp.tagIds) {
                    opp.tagIds = opp.tagIds.filter(id => id !== tag.id);
                }
            });

            // Remove tag from array
            state.tags.splice(index, 1);
            renderTags();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Get tag by ID
        function getTagById(tagId) {
            return state.tags.find(t => t.id === tagId);
        }

        // Get or create tag by name (for inline creation)
        function getOrCreateTag(tagName) {
            if (!tagName || tagName.trim() === '') return null;
            const trimmedName = tagName.trim();
            const existingTag = state.tags.find(t => t.name.toLowerCase() === trimmedName.toLowerCase());
            if (existingTag) return existingTag.id;

            // Create new tag with default color
            const defaultColors = ['#F59E0B', '#10B981', '#3B82F6', '#8B5CF6', '#EC4899', '#EF4444'];
            const colorIndex = state.tags.length % defaultColors.length;
            const newTag = {
                id: generateId(),
                name: trimmedName,
                color: defaultColors[colorIndex],
                createdAt: new Date().toISOString()
            };
            state.tags.push(newTag);
            return newTag.id;
        }

        // ==================== Tag Input Functions ====================

        // Render selected tags for Todo form
        function renderTodoSelectedTags() {
            todoSelectedTags.innerHTML = '';
            state.selectedTodoTagIds.forEach(tagId => {
                const tag = getTagById(tagId);
                if (tag) {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'selected-tag';
                    tagEl.style.backgroundColor = tag.color;
                    tagEl.innerHTML = `
                        ${escapeHtml(tag.name)}
                        <button type="button" class="remove-tag" onclick="removeTodoTag('${tagId}')">Ã—</button>
                    `;
                    todoSelectedTags.appendChild(tagEl);
                }
            });
        }

        // Render selected tags for Engagement form
        function renderOppSelectedTags() {
            engSelectedTags.innerHTML = '';
            state.selectedOppTagIds.forEach(tagId => {
                const tag = getTagById(tagId);
                if (tag) {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'selected-tag';
                    tagEl.style.backgroundColor = tag.color;
                    tagEl.innerHTML = `
                        ${escapeHtml(tag.name)}
                        <button type="button" class="remove-tag" onclick="removeOppTag('${tagId}')">Ã—</button>
                    `;
                    engSelectedTags.appendChild(tagEl);
                }
            });
        }

        // Remove tag from Todo
        function removeTodoTag(tagId) {
            state.selectedTodoTagIds = state.selectedTodoTagIds.filter(id => id !== tagId);
            renderTodoSelectedTags();
        }

        // Remove tag from Engagement
        function removeOppTag(tagId) {
            state.selectedOppTagIds = state.selectedOppTagIds.filter(id => id !== tagId);
            renderOppSelectedTags();
        }

        // Render tag dropdown for Todo
        function renderTodoTagDropdown(filter = '') {
            todoTagDropdown.innerHTML = '';
            const filterLower = filter.toLowerCase();

            // Filter tags not already selected and matching the filter
            const availableTags = state.tags.filter(tag =>
                !state.selectedTodoTagIds.includes(tag.id) &&
                tag.name.toLowerCase().includes(filterLower)
            );

            availableTags.forEach((tag, index) => {
                const item = document.createElement('div');
                item.className = 'tag-dropdown-item' + (index === state.todoTagHighlightIndex ? ' highlighted' : '');
                item.innerHTML = `
                    <span class="tag-color-dot" style="background-color: ${tag.color}"></span>
                    ${escapeHtml(tag.name)}
                `;
                item.onclick = () => selectTodoTag(tag.id);
                todoTagDropdown.appendChild(item);
            });

            // Show "create new" option if filter doesn't match existing tag exactly
            if (filter.trim() && !state.tags.some(t => t.name.toLowerCase() === filterLower)) {
                const createItem = document.createElement('div');
                createItem.className = 'tag-dropdown-item create-new' + (availableTags.length === state.todoTagHighlightIndex ? ' highlighted' : '');
                createItem.innerHTML = `
                    <span class="tag-color-dot"></span>
                    Create "${escapeHtml(filter.trim())}"
                `;
                createItem.onclick = () => createAndSelectTodoTag(filter.trim());
                todoTagDropdown.appendChild(createItem);
            }

            if (todoTagDropdown.children.length > 0) {
                todoTagDropdown.classList.add('open');
                state.todoTagDropdownOpen = true;
            } else {
                todoTagDropdown.classList.remove('open');
                state.todoTagDropdownOpen = false;
            }
        }

        // Render tag dropdown for Engagement
        function renderOppTagDropdown(filter = '') {
            engTagDropdown.innerHTML = '';
            const filterLower = filter.toLowerCase();

            // Filter tags not already selected and matching the filter
            const availableTags = state.tags.filter(tag =>
                !state.selectedOppTagIds.includes(tag.id) &&
                tag.name.toLowerCase().includes(filterLower)
            );

            availableTags.forEach((tag, index) => {
                const item = document.createElement('div');
                item.className = 'tag-dropdown-item' + (index === state.oppTagHighlightIndex ? ' highlighted' : '');
                item.innerHTML = `
                    <span class="tag-color-dot" style="background-color: ${tag.color}"></span>
                    ${escapeHtml(tag.name)}
                `;
                item.onclick = () => selectOppTag(tag.id);
                engTagDropdown.appendChild(item);
            });

            // Show "create new" option if filter doesn't match existing tag exactly
            if (filter.trim() && !state.tags.some(t => t.name.toLowerCase() === filterLower)) {
                const createItem = document.createElement('div');
                createItem.className = 'tag-dropdown-item create-new' + (availableTags.length === state.oppTagHighlightIndex ? ' highlighted' : '');
                createItem.innerHTML = `
                    <span class="tag-color-dot"></span>
                    Create "${escapeHtml(filter.trim())}"
                `;
                createItem.onclick = () => createAndSelectOppTag(filter.trim());
                engTagDropdown.appendChild(createItem);
            }

            if (engTagDropdown.children.length > 0) {
                engTagDropdown.classList.add('open');
                state.engTagDropdownOpen = true;
            } else {
                engTagDropdown.classList.remove('open');
                state.engTagDropdownOpen = false;
            }
        }

        // Select existing tag for Todo
        function selectTodoTag(tagId) {
            if (!state.selectedTodoTagIds.includes(tagId)) {
                state.selectedTodoTagIds.push(tagId);
                renderTodoSelectedTags();
            }
            todoTagInput.value = '';
            closeTodoTagDropdown();
        }

        // Select existing tag for Engagement
        function selectOppTag(tagId) {
            if (!state.selectedOppTagIds.includes(tagId)) {
                state.selectedOppTagIds.push(tagId);
                renderOppSelectedTags();
            }
            engTagInput.value = '';
            closeOppTagDropdown();
        }

        // Create new tag and select it for Todo
        function createAndSelectTodoTag(name) {
            const tagId = getOrCreateTag(name);
            if (tagId) {
                selectTodoTag(tagId);
            }
        }

        // Create new tag and select it for Engagement
        function createAndSelectOppTag(name) {
            const tagId = getOrCreateTag(name);
            if (tagId) {
                selectOppTag(tagId);
            }
        }

        // Close Todo tag dropdown
        function closeTodoTagDropdown() {
            todoTagDropdown.classList.remove('open');
            state.todoTagDropdownOpen = false;
            state.todoTagHighlightIndex = -1;
        }

        // Close Engagement tag dropdown
        function closeOppTagDropdown() {
            engTagDropdown.classList.remove('open');
            state.engTagDropdownOpen = false;
            state.oppTagHighlightIndex = -1;
        }

        // Setup tag input event listeners
        function setupTagInputListeners() {
            // Todo tag input
            todoTagInput.addEventListener('input', (e) => {
                renderTodoTagDropdown(e.target.value);
                // Auto-highlight first item when typing
                const items = todoTagDropdown.querySelectorAll('.tag-dropdown-item');
                if (items.length > 0) {
                    state.todoTagHighlightIndex = 0;
                    renderTodoTagDropdown(e.target.value);
                } else {
                    state.todoTagHighlightIndex = -1;
                }
            });

            todoTagInput.addEventListener('focus', () => {
                // Only show dropdown if there's text (don't auto-open on focus)
                if (todoTagInput.value.trim()) {
                    renderTodoTagDropdown(todoTagInput.value);
                }
            });

            todoTagInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    e.stopPropagation();
                    closeTodoTagDropdown();
                    todoTagInput.value = '';
                    return;
                }

                if (e.key === 'Tab' && !e.shiftKey) {
                    // Tab (forward only): only select if user typed text
                    const items = todoTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (todoTagInput.value.trim() && items.length > 0) {
                        // User typed text and there are matches - select the highlighted/first item
                        e.preventDefault();
                        const indexToSelect = state.todoTagHighlightIndex >= 0 ? state.todoTagHighlightIndex : 0;
                        items[indexToSelect].click();
                    } else if (todoTagInput.value.trim()) {
                        // User typed text but no matches - create new tag
                        e.preventDefault();
                        createAndSelectTodoTag(todoTagInput.value.trim());
                    }
                    // If no text entered, let Tab naturally move to Save button
                    return;
                }

                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.stopPropagation(); // Prevent form submission
                    const items = todoTagDropdown.querySelectorAll('.tag-dropdown-item');
                    const inputText = todoTagInput.value.trim();

                    if (inputText) {
                        // Check for exact match first
                        const exactMatch = Array.from(items).find(item =>
                            item.textContent.trim().toLowerCase() === inputText.toLowerCase()
                        );

                        if (exactMatch) {
                            // Exact match found - select it
                            exactMatch.click();
                        } else if (items.length > 0 && state.todoTagHighlightIndex >= 0) {
                            // Highlighted item exists - select it
                            items[state.todoTagHighlightIndex].click();
                        } else {
                            // No exact match - create new tag
                            createAndSelectTodoTag(inputText);
                        }
                        // Focus Save button after tag action
                        closeTodoTagDropdown();
                        document.getElementById('todo-save-btn').focus();
                    }
                    return;
                }

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const items = todoTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (items.length > 0) {
                        state.todoTagHighlightIndex = Math.min(state.todoTagHighlightIndex + 1, items.length - 1);
                        renderTodoTagDropdown(todoTagInput.value);
                    }
                    return;
                }

                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (state.todoTagHighlightIndex > 0) {
                        state.todoTagHighlightIndex--;
                        renderTodoTagDropdown(todoTagInput.value);
                    }
                    return;
                }
            });

            // Engagement tag input
            engTagInput.addEventListener('input', (e) => {
                renderOppTagDropdown(e.target.value);
                // Auto-highlight first item when typing
                const items = engTagDropdown.querySelectorAll('.tag-dropdown-item');
                if (items.length > 0) {
                    state.oppTagHighlightIndex = 0;
                    renderOppTagDropdown(e.target.value);
                } else {
                    state.oppTagHighlightIndex = -1;
                }
            });

            engTagInput.addEventListener('focus', () => {
                renderOppTagDropdown(engTagInput.value);
            });

            engTagInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    e.stopPropagation();
                    closeOppTagDropdown();
                    engTagInput.value = '';
                    return;
                }

                if (e.key === 'Tab' && !e.shiftKey) {
                    // Tab (forward only) with dropdown open: select first/highlighted item and move on
                    const items = engTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (items.length > 0) {
                        e.preventDefault();
                        const indexToSelect = state.oppTagHighlightIndex >= 0 ? state.oppTagHighlightIndex : 0;
                        items[indexToSelect].click();
                    } else if (engTagInput.value.trim()) {
                        // If text entered but no matches, create tag and move on
                        e.preventDefault();
                        createAndSelectOppTag(engTagInput.value.trim());
                    }
                    // If nothing, let Tab naturally move to next control
                    return;
                }

                if (e.key === 'Enter') {
                    e.preventDefault();
                    const items = engTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (items.length > 0) {
                        const indexToSelect = state.oppTagHighlightIndex >= 0 ? state.oppTagHighlightIndex : 0;
                        items[indexToSelect].click();
                    } else if (engTagInput.value.trim()) {
                        createAndSelectOppTag(engTagInput.value.trim());
                    }
                    return;
                }

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const items = engTagDropdown.querySelectorAll('.tag-dropdown-item');
                    if (items.length > 0) {
                        state.oppTagHighlightIndex = Math.min(state.oppTagHighlightIndex + 1, items.length - 1);
                        renderOppTagDropdown(engTagInput.value);
                    }
                    return;
                }

                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (state.oppTagHighlightIndex > 0) {
                        state.oppTagHighlightIndex--;
                        renderOppTagDropdown(engTagInput.value);
                    }
                    return;
                }
            });

            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#todo-tag-container')) {
                    closeTodoTagDropdown();
                }
                if (!e.target.closest('#opp-tag-container')) {
                    closeOppTagDropdown();
                }
            });
        }

        // Initialize tag input listeners
        setupTagInputListeners();

        // ==================== End Tag Input Functions ====================

        // Get role name by ID
        function getRoleName(roleId) {
            const role = state.roles.find(r => r.id === roleId);
            return role ? role.name : '';
        }

        // Get or create role by name
        function getOrCreateRole(roleName) {
            if (!roleName || roleName.trim() === '') return null;
            const trimmedName = roleName.trim();
            const existingRole = state.roles.find(r => r.name.toLowerCase() === trimmedName.toLowerCase());
            if (existingRole) return existingRole.id;

            // Create new role
            const newRole = {
                id: generateId(),
                name: trimmedName
            };
            state.roles.push(newRole);
            return newRole.id;
        }

        // Open person modal
        function openPersonModal(personIndex = null) {
            state.personModalOpen = true;
            state.editingPersonIndex = personIndex;
            state.roleAutocompleteOpen = false;
            state.roleAutocompleteHighlightIndex = -1;

            personRoleInput.value = '';
            personRoleClear.classList.remove('visible');
            roleDropdown.classList.remove('open');

            if (personIndex !== null) {
                // Edit mode
                const person = state.people[personIndex];
                personModalTitle.textContent = 'Edit Person';
                personNameInput.value = person.name;
                if (person.roleId) {
                    personRoleInput.value = getRoleName(person.roleId);
                    personRoleClear.classList.add('visible');
                }
            } else {
                // Create mode
                personModalTitle.textContent = 'New Person';
                personNameInput.value = '';
            }

            personModal.classList.remove('hidden');
            setTimeout(() => personNameInput.focus(), 100);
        }

        // Close person modal
        function closePersonModal() {
            state.personModalOpen = false;
            state.editingPersonIndex = null;
            state.roleAutocompleteOpen = false;
            personModal.classList.add('hidden');
            personForm.reset();
            roleDropdown.classList.remove('open');
        }

        // Save person
        function savePerson(e) {
            e.preventDefault();

            const name = personNameInput.value.trim();
            if (!name) return;

            const roleName = personRoleInput.value.trim();
            const roleId = getOrCreateRole(roleName);

            if (state.editingPersonIndex !== null) {
                // Update existing person
                state.people[state.editingPersonIndex].name = name;
                state.people[state.editingPersonIndex].roleId = roleId;
            } else {
                // Create new person
                const newPerson = {
                    id: generateId(),
                    name: name,
                    roleId: roleId
                };
                state.people.push(newPerson);
            }

            closePersonModal();
            renderPeople();
            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
        }

        // Open delete person modal
        function openDeletePersonModal(index) {
            state.deletePersonIndex = index;
            const person = state.people[index];
            deletePersonName.textContent = person.name;
            deletePersonModal.classList.remove('hidden');
        }

        // Close delete person modal
        function closeDeletePersonModal() {
            state.deletePersonIndex = null;
            deletePersonModal.classList.add('hidden');
        }

        // Confirm delete person
        function confirmDeletePerson() {
            if (state.deletePersonIndex !== null) {
                const personId = state.people[state.deletePersonIndex].id;

                // Remove person from array
                state.people.splice(state.deletePersonIndex, 1);

                // Update engagements that referenced this person
                state.engagements.forEach(opp => {
                    if (opp.contactId === personId) {
                        opp.contactId = null;
                        opp.contact = ''; // Clear the text contact as well
                    }
                });

                closeDeletePersonModal();
                renderPeople();
                renderEngagements();
                // Auto-save to IndexedDB
                saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));
            }
        }

        // Clear person role input
        function clearPersonRole() {
            personRoleInput.value = '';
            personRoleClear.classList.remove('visible');
            roleDropdown.classList.remove('open');
            state.roleAutocompleteOpen = false;
        }

        // Filter roles based on search query
        function filterRoles(query) {
            if (!query || query.trim() === '') return [];
            const lowerQuery = query.toLowerCase().trim();
            return state.roles.filter(role =>
                role.name.toLowerCase().includes(lowerQuery)
            );
        }

        // Render role autocomplete dropdown
        function renderRoleDropdown(query) {
            const matches = filterRoles(query);
            roleDropdown.innerHTML = '';

            if (matches.length > 0) {
                matches.forEach((role, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.setAttribute('data-index', index);
                    item.setAttribute('data-id', role.id);
                    item.innerHTML = `<div class="autocomplete-item-name">${escapeHtml(role.name)}</div>`;
                    item.onclick = () => selectRole(role);
                    roleDropdown.appendChild(item);
                });
            } else if (query && query.trim() !== '') {
                // Show create option
                const createItem = document.createElement('div');
                createItem.className = 'autocomplete-item autocomplete-create';
                createItem.innerHTML = `
                    <div class="autocomplete-item-name">Create "${escapeHtml(query.trim())}"</div>
                `;
                createItem.onclick = () => {
                    personRoleInput.value = query.trim();
                    personRoleClear.classList.add('visible');
                    closeRoleDropdown();
                };
                roleDropdown.appendChild(createItem);
            }

            state.roleAutocompleteHighlightIndex = -1;
            updateRoleAutocompleteHighlight();
        }

        // Update role autocomplete highlight
        function updateRoleAutocompleteHighlight() {
            const items = roleDropdown.querySelectorAll('.autocomplete-item');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.roleAutocompleteHighlightIndex);
            });
        }

        // Select role from autocomplete
        function selectRole(role) {
            personRoleInput.value = role.name;
            personRoleClear.classList.add('visible');
            closeRoleDropdown();
        }

        // Open role dropdown
        function openRoleDropdown() {
            state.roleAutocompleteOpen = true;
            roleDropdown.classList.add('open');
        }

        // Close role dropdown
        function closeRoleDropdown() {
            state.roleAutocompleteOpen = false;
            roleDropdown.classList.remove('open');
            state.roleAutocompleteHighlightIndex = -1;
        }

        // Person role input event handlers
        personRoleInput.addEventListener('input', (e) => {
            const query = e.target.value;

            // Show/hide clear button
            personRoleClear.classList.toggle('visible', query.length > 0);

            // Render and open dropdown
            if (query.trim() !== '') {
                renderRoleDropdown(query);
                openRoleDropdown();
                // Auto-highlight first match when typing
                const matches = filterRoles(query);
                if (matches.length > 0) {
                    state.roleAutocompleteHighlightIndex = 0;
                    updateRoleAutocompleteHighlight();
                }
            } else {
                closeRoleDropdown();
            }
        });

        personRoleInput.addEventListener('focus', () => {
            const query = personRoleInput.value;
            if (query.trim() !== '') {
                renderRoleDropdown(query);
                openRoleDropdown();
            }
        });

        personRoleInput.addEventListener('keydown', (e) => {
            const items = roleDropdown.querySelectorAll('.autocomplete-item');
            const matches = filterRoles(personRoleInput.value);

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.roleAutocompleteOpen && items.length > 0) {
                    state.roleAutocompleteHighlightIndex = Math.min(state.roleAutocompleteHighlightIndex + 1, items.length - 1);
                    updateRoleAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.roleAutocompleteOpen && items.length > 0) {
                    state.roleAutocompleteHighlightIndex = Math.max(state.roleAutocompleteHighlightIndex - 1, 0);
                    updateRoleAutocompleteHighlight();
                }
            } else if (e.key === 'Tab' && !e.shiftKey) {
                // Tab (forward only) with dropdown open: select first/highlighted match and move on
                if (state.roleAutocompleteOpen && matches.length > 0) {
                    e.preventDefault();
                    const indexToSelect = state.roleAutocompleteHighlightIndex >= 0 ? state.roleAutocompleteHighlightIndex : 0;
                    selectRole(matches[indexToSelect]);
                }
                // If no matches, let Tab naturally move to next control
            } else if (e.key === 'Enter') {
                e.preventDefault();
                const query = personRoleInput.value.trim();

                if (state.roleAutocompleteOpen && matches.length > 0) {
                    // Select first/highlighted item
                    const indexToSelect = state.roleAutocompleteHighlightIndex >= 0 ? state.roleAutocompleteHighlightIndex : 0;
                    selectRole(matches[indexToSelect]);
                } else if (query) {
                    // Just accept the typed value
                    personRoleClear.classList.add('visible');
                    closeRoleDropdown();
                }
            } else if (e.key === 'Escape') {
                if (state.roleAutocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeRoleDropdown();
                }
            }
        });

        // =============================================
        // Contact Autocomplete Functions (Engagement Modal)
        // =============================================

        // Filter people based on search query
        function filterPeople(query) {
            if (!query || query.trim() === '') return [];
            const lowerQuery = query.toLowerCase().trim();
            return state.people.filter(person =>
                person.name.toLowerCase().includes(lowerQuery)
            );
        }

        // Render contact autocomplete dropdown
        function renderContactDropdown(query) {
            const matches = filterPeople(query);
            contactDropdown.innerHTML = '';

            if (matches.length > 0) {
                matches.forEach((person, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.setAttribute('data-index', index);
                    item.setAttribute('data-id', person.id);
                    const roleName = person.roleId ? getRoleName(person.roleId) : '';
                    item.innerHTML = `
                        <div class="autocomplete-item-name">${escapeHtml(person.name)}</div>
                        ${roleName ? `<div class="autocomplete-item-contact">${escapeHtml(roleName)}</div>` : ''}
                    `;
                    item.onclick = () => selectContact(person);
                    contactDropdown.appendChild(item);
                });
            } else if (query && query.trim() !== '') {
                // Show create option
                const createItem = document.createElement('div');
                createItem.className = 'autocomplete-item autocomplete-create';
                createItem.innerHTML = `
                    <div class="autocomplete-item-name">Create "${escapeHtml(query.trim())}" - press Enter</div>
                `;
                createItem.onclick = () => openInlinePersonForm(query.trim());
                contactDropdown.appendChild(createItem);
            }

            state.contactAutocompleteHighlightIndex = -1;
            updateContactAutocompleteHighlight();
        }

        // Update contact autocomplete highlight
        function updateContactAutocompleteHighlight() {
            const items = contactDropdown.querySelectorAll('.autocomplete-item');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.contactAutocompleteHighlightIndex);
            });
        }

        // Select contact from autocomplete
        function selectContact(person) {
            state.selectedPersonId = person.id;
            state.pendingPerson = null;
            engContactInput.value = person.name;
            engContactClear.classList.add('visible');
            closeContactDropdown();
            closeInlinePersonForm();
        }

        // Open contact dropdown
        function openContactDropdown() {
            state.contactAutocompleteOpen = true;
            contactDropdown.classList.add('open');
        }

        // Close contact dropdown
        function closeContactDropdown() {
            state.contactAutocompleteOpen = false;
            contactDropdown.classList.remove('open');
            state.contactAutocompleteHighlightIndex = -1;
        }

        // Clear engagement contact input
        function clearOppContact() {
            state.selectedPersonId = null;
            state.pendingPerson = null;
            engContactInput.value = '';
            engContactClear.classList.remove('visible');
            closeContactDropdown();
            closeInlinePersonForm();
        }

        // Open inline person form
        function openInlinePersonForm(name) {
            state.inlinePersonFormOpen = true;
            inlinePersonName.value = name;
            inlinePersonRole.value = '';
            inlinePersonForm.classList.add('open');
            closeContactDropdown();

            // Enable tab navigation for person form elements
            setFormTabIndex(inlinePersonForm, true);

            // Focus on role after animation
            setTimeout(() => inlinePersonRole.focus(), 350);
        }

        // Close inline person form
        function closeInlinePersonForm() {
            state.inlinePersonFormOpen = false;
            inlinePersonForm.classList.remove('open');

            // Disable tab navigation for person form elements
            setFormTabIndex(inlinePersonForm, false);
        }

        // Cancel inline person creation
        function cancelInlinePerson() {
            state.pendingPerson = null;
            engContactInput.value = '';
            engContactClear.classList.remove('visible');
            closeInlinePersonForm();
        }

        // Confirm inline person creation
        function confirmInlinePerson() {
            const name = inlinePersonName.value.trim();
            const role = inlinePersonRole.value.trim();

            if (!name) {
                inlinePersonName.focus();
                return;
            }

            // Store as pending person
            state.pendingPerson = { name, role };
            state.selectedPersonId = null;

            // Update the contact input to show the name
            engContactInput.value = name;
            engContactClear.classList.add('visible');

            closeInlinePersonForm();
        }

        // ============================================
        // Inline Person Creation within Inline Engagement (Todo Modal)
        // ============================================

        // Render inline opp contact dropdown
        function renderInlineOppContactDropdown(query) {
            const matches = filterPeople(query);
            inlineEngContactDropdown.innerHTML = '';

            if (matches.length === 0) {
                const item = document.createElement('div');
                item.className = 'autocomplete-item autocomplete-no-match';
                item.textContent = `Press Enter to create "${query}"`;
                inlineEngContactDropdown.appendChild(item);
            } else {
                matches.forEach((person, index) => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.dataset.index = index;

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'autocomplete-item-name';
                    nameSpan.textContent = person.name;
                    item.appendChild(nameSpan);

                    if (person.roleId) {
                        const role = state.roles.find(r => r.id === person.roleId);
                        if (role) {
                            const roleSpan = document.createElement('span');
                            roleSpan.className = 'autocomplete-item-role';
                            roleSpan.textContent = role.name;
                            item.appendChild(roleSpan);
                        }
                    }

                    item.addEventListener('click', () => selectInlineOppContact(person));
                    inlineEngContactDropdown.appendChild(item);
                });
            }
        }

        // Open inline opp contact dropdown
        function openInlineOppContactDropdown() {
            state.inlineEngContactAutocompleteOpen = true;
            state.inlineEngContactAutocompleteHighlightIndex = -1;
            inlineEngContactDropdown.classList.add('open');
        }

        // Close inline opp contact dropdown
        function closeInlineOppContactDropdown() {
            state.inlineEngContactAutocompleteOpen = false;
            state.inlineEngContactAutocompleteHighlightIndex = -1;
            inlineEngContactDropdown.classList.remove('open');
        }

        // Select contact for inline engagement
        function selectInlineOppContact(person) {
            state.selectedInlineOppPersonId = person.id;
            state.pendingInlineOppPerson = null;
            inlineEngContact.value = person.name;
            inlineEngContactClear.classList.add('visible');
            closeInlineOppContactDropdown();
            closeInlineOppPersonForm();
        }

        // Clear inline opp contact selection
        function clearInlineOppContact() {
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;
            inlineEngContact.value = '';
            inlineEngContactClear.classList.remove('visible');
            closeInlineOppContactDropdown();
            closeInlineOppPersonForm();
        }

        // Open inline person form within inline engagement
        function openInlineOppPersonForm(name) {
            state.inlineEngPersonFormOpen = true;
            updateTodoSaveButtonState();
            inlineEngPersonName.value = name;
            inlineEngPersonRole.value = '';
            inlineEngPersonForm.classList.add('open');
            closeInlineOppContactDropdown();

            // Disable engagement form buttons while person form is open
            if (inlineEngAddBtn) inlineEngAddBtn.disabled = true;
            if (inlineEngCancelBtn) inlineEngCancelBtn.disabled = true;

            // Enable tab navigation for person form elements
            setFormTabIndex(inlineEngPersonForm, true);

            // Focus on role field after animation
            setTimeout(() => {
                inlineEngPersonRole.focus();
            }, 150);
        }

        // Close inline person form within inline engagement
        function closeInlineOppPersonForm() {
            state.inlineEngPersonFormOpen = false;
            inlineEngPersonForm.classList.remove('open');
            updateTodoSaveButtonState();

            // Re-enable engagement form buttons
            if (inlineEngAddBtn) inlineEngAddBtn.disabled = false;
            if (inlineEngCancelBtn) inlineEngCancelBtn.disabled = false;

            // Disable tab navigation for person form elements
            setFormTabIndex(inlineEngPersonForm, false);
        }

        // Cancel inline person creation within inline engagement
        function cancelInlineOppPerson() {
            state.pendingInlineOppPerson = null;
            inlineEngContact.value = '';
            inlineEngContactClear.classList.remove('visible');
            closeInlineOppPersonForm();
            // Focus back to contact field
            setTimeout(() => inlineEngContact.focus(), 150);
        }

        // Confirm inline person creation within inline engagement
        function confirmInlineOppPerson() {
            const name = inlineEngPersonName.value.trim();
            const role = inlineEngPersonRole.value.trim();

            if (!name) {
                inlineEngPersonName.focus();
                return;
            }

            // Store as pending person for inline engagement
            state.pendingInlineOppPerson = { name, role };
            state.selectedInlineOppPersonId = null;

            // Update the contact input to show the name
            inlineEngContact.value = name;
            inlineEngContactClear.classList.add('visible');

            closeInlineOppPersonForm();
            // Focus on engagement Add button after collapse
            setTimeout(() => {
                if (inlineEngAddBtn) inlineEngAddBtn.focus();
            }, 150);
        }

        // Update autocomplete highlight for inline opp contact
        function updateInlineOppContactAutocompleteHighlight() {
            const items = inlineEngContactDropdown.querySelectorAll('.autocomplete-item:not(.autocomplete-no-match)');
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === state.inlineEngContactAutocompleteHighlightIndex);
            });
        }

        // Inline opp contact input event handlers
        inlineEngContact.addEventListener('input', (e) => {
            const query = e.target.value;

            // Clear selected person if user types
            state.selectedInlineOppPersonId = null;
            state.pendingInlineOppPerson = null;

            // Show/hide clear button
            inlineEngContactClear.classList.toggle('visible', query.length > 0);

            // Close inline form if open
            if (state.inlineEngPersonFormOpen) {
                closeInlineOppPersonForm();
            }

            // Render and open dropdown
            if (query.trim() !== '') {
                renderInlineOppContactDropdown(query);
                openInlineOppContactDropdown();
            } else {
                closeInlineOppContactDropdown();
            }
        });

        inlineEngContact.addEventListener('focus', (e) => {
            const query = inlineEngContact.value;
            if (query.trim() !== '' && !state.selectedInlineOppPersonId && !state.pendingInlineOppPerson) {
                renderInlineOppContactDropdown(query);
                openInlineOppContactDropdown();
            }
            // Scroll to make contact field visible
            setTimeout(() => {
                inlineEngContact.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
        });

        inlineEngContact.addEventListener('keydown', (e) => {
            const items = inlineEngContactDropdown.querySelectorAll('.autocomplete-item:not(.autocomplete-no-match)');
            const matches = filterPeople(inlineEngContact.value);
            const query = inlineEngContact.value.trim();

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.inlineEngContactAutocompleteOpen && items.length > 0) {
                    state.inlineEngContactAutocompleteHighlightIndex = Math.min(state.inlineEngContactAutocompleteHighlightIndex + 1, items.length - 1);
                    updateInlineOppContactAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.inlineEngContactAutocompleteOpen && items.length > 0) {
                    state.inlineEngContactAutocompleteHighlightIndex = Math.max(state.inlineEngContactAutocompleteHighlightIndex - 1, 0);
                    updateInlineOppContactAutocompleteHighlight();
                }
            } else if (e.key === 'Tab' && !e.shiftKey) {
                // Tab (forward only) behavior:
                // 1. If contact already selected, confirm inline opp and move to Tags
                // 2. If matches exist, select first/highlighted and move on
                // 3. If no matches but text entered, open inline person form
                // 4. If no text, natural tab
                if (state.selectedInlineOppPersonId || state.pendingInlineOppPerson) {
                    // Contact is selected - confirm the inline engagement and move to Tags
                    e.preventDefault();
                    confirmInlineEngagement();
                    todoTagInput.focus();
                } else if (matches.length > 0) {
                    e.preventDefault();
                    const indexToSelect = state.inlineEngContactAutocompleteHighlightIndex >= 0 ? state.inlineEngContactAutocompleteHighlightIndex : 0;
                    selectInlineOppContact(matches[indexToSelect]);
                } else if (query && !state.inlineEngPersonFormOpen) {
                    e.preventDefault();
                    openInlineOppPersonForm(query);
                }
                // If no text entered, let Tab naturally move
            } else if (e.key === 'Enter') {
                e.preventDefault();

                // Check for exact match (case-insensitive)
                const exactMatch = matches.find(person => person.name.toLowerCase() === query.toLowerCase());

                if (state.selectedInlineOppPersonId || state.pendingInlineOppPerson) {
                    // Contact is selected - confirm the inline engagement and move to Tags
                    confirmInlineEngagement();
                    todoTagInput.focus();
                } else if (state.inlineEngContactAutocompleteHighlightIndex >= 0 && matches.length > 0) {
                    // Select highlighted item
                    selectInlineOppContact(matches[state.inlineEngContactAutocompleteHighlightIndex]);
                } else if (exactMatch) {
                    // Exact match - select it
                    selectInlineOppContact(exactMatch);
                } else if (query && !state.inlineEngPersonFormOpen) {
                    // Partial match or no matches - open inline creation form for new person
                    openInlineOppPersonForm(query);
                } else if (state.inlineEngContactAutocompleteOpen) {
                    // Just close dropdown
                    closeInlineOppContactDropdown();
                }
            } else if (e.key === 'Escape') {
                if (state.inlineEngContactAutocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeInlineOppContactDropdown();
                }
            }
        });

        // Handle inline eng person form Enter key - confirm person AND engagement
        inlineEngPersonForm.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target.tagName === 'INPUT') {
                e.preventDefault();
                // First confirm the person
                confirmInlineOppPerson();
                // Then confirm the engagement (which will include the person)
                confirmInlineEngagement();
            }
        });

        // Contact input event handlers
        engContactInput.addEventListener('input', (e) => {
            const query = e.target.value;

            // Clear selected person if user types
            state.selectedPersonId = null;
            state.pendingPerson = null;

            // Show/hide clear button
            engContactClear.classList.toggle('visible', query.length > 0);

            // Close inline form if open
            if (state.inlinePersonFormOpen) {
                closeInlinePersonForm();
            }

            // Render and open dropdown
            if (query.trim() !== '') {
                renderContactDropdown(query);
                openContactDropdown();
                // Auto-highlight first match when typing
                const matches = filterPeople(query);
                if (matches.length > 0) {
                    state.contactAutocompleteHighlightIndex = 0;
                    updateContactAutocompleteHighlight();
                }
            } else {
                closeContactDropdown();
            }
        });

        engContactInput.addEventListener('focus', () => {
            const query = engContactInput.value;
            if (query.trim() !== '' && !state.selectedPersonId && !state.pendingPerson) {
                renderContactDropdown(query);
                openContactDropdown();
            }
        });

        engContactInput.addEventListener('keydown', (e) => {
            const items = contactDropdown.querySelectorAll('.autocomplete-item');
            const matches = filterPeople(engContactInput.value);
            const query = engContactInput.value.trim();

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.contactAutocompleteOpen && items.length > 0) {
                    state.contactAutocompleteHighlightIndex = Math.min(state.contactAutocompleteHighlightIndex + 1, items.length - 1);
                    updateContactAutocompleteHighlight();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.contactAutocompleteOpen && items.length > 0) {
                    state.contactAutocompleteHighlightIndex = Math.max(state.contactAutocompleteHighlightIndex - 1, 0);
                    updateContactAutocompleteHighlight();
                }
            } else if (e.key === 'Tab' && !e.shiftKey) {
                // Tab (forward only) behavior:
                // 1. If matches exist, select first/highlighted and move to Tags
                // 2. If no matches but text entered, open inline creation
                // 3. If no text, natural tab
                if (matches.length > 0) {
                    e.preventDefault();
                    const indexToSelect = state.contactAutocompleteHighlightIndex >= 0 ? state.contactAutocompleteHighlightIndex : 0;
                    selectContact(matches[indexToSelect]);
                    engTagInput.focus();
                } else if (query && !state.inlinePersonFormOpen) {
                    e.preventDefault();
                    openInlinePersonForm(query);
                }
                // If no text entered, let Tab naturally move to next control
            } else if (e.key === 'Enter') {
                e.preventDefault();

                // Check for exact match (case-insensitive)
                const exactMatch = matches.find(person => person.name.toLowerCase() === query.toLowerCase());

                if (state.contactAutocompleteHighlightIndex >= 0 && matches.length > 0) {
                    // Select highlighted item
                    selectContact(matches[state.contactAutocompleteHighlightIndex]);
                } else if (exactMatch) {
                    // Exact match - select it and move to next field
                    selectContact(exactMatch);
                    engTagInput.focus();
                } else if (query && !state.inlinePersonFormOpen) {
                    // Partial match or no matches - open inline creation form
                    openInlinePersonForm(query);
                }
            } else if (e.key === 'Escape') {
                if (state.contactAutocompleteOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeContactDropdown();
                }
            }
        });

        // Handle inline person form Enter key
        inlinePersonForm.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target.tagName === 'INPUT') {
                e.preventDefault();
                confirmInlinePerson();
            }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.autocomplete-wrapper') && state.autocompleteOpen) {
                closeAutocompleteDropdown();
            }
            if (!e.target.closest('.autocomplete-wrapper') && state.contactAutocompleteOpen) {
                closeContactDropdown();
            }
            if (!e.target.closest('.autocomplete-wrapper') && state.roleAutocompleteOpen) {
                closeRoleDropdown();
            }
            if (!e.target.closest('.autocomplete-wrapper') && state.inlineEngContactAutocompleteOpen) {
                closeInlineOppContactDropdown();
            }
        });

        // Add keyboard navigation (capture phase to intercept browser shortcuts)
        document.addEventListener('keydown', (e) => {
            // Skip if any modal is open and it's not Escape
            const anyModalOpen = state.modalOpen || state.engagementModalOpen || state.personModalOpen;

            // Handle Shift+N to open todo modal (only on home tab)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'home' && !anyModalOpen) {
                e.preventDefault();
                openModal();
                return;
            }

            // Handle Shift+N to open engagement modal (only on engagements tab)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'engagements' && !anyModalOpen) {
                e.preventDefault();
                openEngagementModal();
                return;
            }

            // Handle Shift+N to open person modal (only on settings page with people section)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'settings' && state.settingsSection === 'people' && !anyModalOpen) {
                e.preventDefault();
                openPersonModal();
                return;
            }

            // Handle Shift+N to open tag modal (only on settings page with tags section)
            if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase() === 'n' &&
                state.currentPage === 'app' && state.currentTab === 'settings' && state.settingsSection === 'tags' && !anyModalOpen) {
                e.preventDefault();
                openTagModal();
                return;
            }

            // Handle Escape key to close modals or side panel
            // Priority: innermost inline form first, then modals, then side panel
            if (e.key === 'Escape') {
                if (state.cancelModalOpen) {
                    e.preventDefault();
                    closeCancelModal();
                    return;
                }
                if (state.confirmModalOpen) {
                    e.preventDefault();
                    closeConfirmModal();
                    return;
                }
                // Handle inline forms within todo modal (innermost first)
                if (state.modalOpen) {
                    // First check if person inline form is open within engagement inline
                    if (state.inlineEngPersonFormOpen) {
                        e.preventDefault();
                        cancelInlineOppPerson();
                        return;
                    }
                    // Then check if engagement inline form is open
                    if (state.inlineEngFormOpen) {
                        e.preventDefault();
                        cancelInlineEngagement();
                        return;
                    }
                    // Otherwise close the whole modal
                    e.preventDefault();
                    closeModal();
                    return;
                }
                if (state.engagementModalOpen) {
                    // Check for inline person form in engagement modal
                    if (state.inlinePersonFormOpen) {
                        e.preventDefault();
                        cancelInlinePerson();
                        return;
                    }
                    e.preventDefault();
                    closeEngagementModal();
                    return;
                }
                if (state.personModalOpen) {
                    e.preventDefault();
                    closePersonModal();
                    return;
                }
                if (state.tagModalOpen) {
                    e.preventDefault();
                    closeTagModal();
                    return;
                }
                if (state.deletePersonIndex !== null) {
                    e.preventDefault();
                    closeDeletePersonModal();
                    return;
                }
                if (state.sidePanelOpen) {
                    e.preventDefault();
                    closeSidePanel();
                    return;
                }
            }

            // Landing page keyboard shortcuts
            if (state.currentPage === 'landing') {
                if (e.key === '1') {
                    startFromScratch();
                } else if (e.key === '2') {
                    continueWorking();
                }
            }
        }, true);  // Use capture phase to intercept before browser handles it

        // Migrate existing contacts to people
        function migrateContactsToPeople() {
            // Get all unique contacts from engagements that don't have a contactId
            const contactsToMigrate = new Map();

            state.engagements.forEach(opp => {
                if (opp.contact && !opp.contactId) {
                    const normalizedContact = opp.contact.trim().toLowerCase();
                    if (!contactsToMigrate.has(normalizedContact)) {
                        contactsToMigrate.set(normalizedContact, opp.contact.trim());
                    }
                }
            });

            // Create people for unique contacts
            contactsToMigrate.forEach((originalName, normalizedName) => {
                // Check if person already exists
                const existingPerson = state.people.find(p => p.name.toLowerCase() === normalizedName);
                if (!existingPerson) {
                    const newPerson = {
                        id: generateId(),
                        name: originalName,
                        roleId: null
                    };
                    state.people.push(newPerson);
                }
            });

            // Update engagements to reference the person
            state.engagements.forEach(opp => {
                if (opp.contact && !opp.contactId) {
                    const normalizedContact = opp.contact.trim().toLowerCase();
                    const person = state.people.find(p => p.name.toLowerCase() === normalizedContact);
                    if (person) {
                        opp.contactId = person.id;
                    }
                }
            });
        }

        // Migrate engagements to new lifecycle model
        function migrateEngagementLifecycle() {
            state.engagements.forEach(eng => {
                // Add type field if missing (default to 'engagement')
                if (!eng.type) {
                    eng.type = 'engagement';
                }

                // Migrate old status values to new model
                // Valid statuses: active, paused, completed, closed, dropped
                if (!['active', 'paused', 'completed', 'closed', 'dropped'].includes(eng.status)) {
                    // Map old statuses to new ones
                    const statusMap = {
                        'requested': 'active',
                        'open': 'active',
                        'closed': 'closed',
                        'cancelled': 'dropped'
                    };
                    eng.status = statusMap[eng.status] || 'active';
                }

                // Ensure preProject and project fields exist
                if (eng.preProject === undefined) {
                    eng.preProject = null;
                }
                if (eng.project === undefined) {
                    eng.project = null;
                }
            });
        }

        // Migrate existing engagement preProject/project data to new allocations format (Issue-57)
        function migrateEngagementAllocations() {
            state.engagements.forEach(eng => {
                // Check if this engagement already has an allocation entry
                const existingAllocation = getAllocationForEngagement(eng.id);
                if (existingAllocation) return; // Already migrated

                // Only migrate if there's preProject or project data to migrate
                if (!eng.preProject && !eng.project) return;

                const allocation = {
                    id: eng.id,
                    updatedAt: new Date().toISOString()
                };

                // Migrate preProject data
                if (eng.preProject && eng.preProject.allocations && eng.preProject.allocations.length > 0) {
                    const months = eng.preProject.allocations.map(a => a.month).sort();
                    const avgPercentage = Math.round(
                        eng.preProject.allocations.reduce((sum, a) => sum + (a.percentage || 0), 0) /
                        eng.preProject.allocations.length
                    );
                    allocation.preProject = {
                        allocationPercentage: avgPercentage || 25,
                        months: months
                    };
                }

                // Migrate project data
                if (eng.project && eng.project.timeline) {
                    const timeline = eng.project.timeline;
                    const avgPercentage = timeline.allocations && timeline.allocations.length > 0
                        ? Math.round(timeline.allocations.reduce((sum, a) => sum + (a.percentage || 0), 0) / timeline.allocations.length)
                        : 25;

                    // Convert dates to YYYY-MM format
                    const startMonth = timeline.startDate ? timeline.startDate.substring(0, 7) : null;
                    const endMonth = timeline.endDate ? timeline.endDate.substring(0, 7) : null;

                    if (startMonth && endMonth) {
                        allocation.project = {
                            allocationPercentage: avgPercentage,
                            startMonth: startMonth,
                            endMonth: endMonth
                        };
                    }
                }

                // Only add if there's actual allocation data
                if (allocation.preProject || allocation.project) {
                    state.allocations.push(allocation);
                }
            });
        }

        // ========================================
        // ALLOCATION HELPER FUNCTIONS (Issue-57)
        // ========================================

        // Get allocation for an engagement by ID
        function getAllocationForEngagement(engagementId) {
            return state.allocations.find(a => a.id === engagementId) || null;
        }

        // Save or update an allocation
        function saveAllocation(allocation) {
            const existingIndex = state.allocations.findIndex(a => a.id === allocation.id);
            allocation.updatedAt = new Date().toISOString();

            if (existingIndex >= 0) {
                state.allocations[existingIndex] = allocation;
            } else {
                state.allocations.push(allocation);
            }

            return saveStateToIndexedDB();
        }

        // Delete an allocation by engagement ID
        function deleteAllocation(engagementId) {
            const index = state.allocations.findIndex(a => a.id === engagementId);
            if (index >= 0) {
                state.allocations.splice(index, 1);
                return saveStateToIndexedDB();
            }
            return Promise.resolve();
        }

        // Get current month in YYYY-MM format
        function getCurrentMonth() {
            const now = new Date();
            return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        }

        // Check if a month is within an array of months (for pre-project with gaps)
        function isMonthInArray(month, monthsArray) {
            return monthsArray.includes(month);
        }

        // Check if a month is within a range (for project continuous range)
        function isMonthInRange(month, startMonth, endMonth) {
            return month >= startMonth && month <= endMonth;
        }

        // Get the display type for an engagement based on allocations and current date
        function getEngagementDisplayType(engagement) {
            const allocation = getAllocationForEngagement(engagement.id);
            const currentMonth = getCurrentMonth();

            if (!allocation) {
                return 'engagement';
            }

            // Check project allocation first (takes priority)
            if (allocation.project && allocation.project.startMonth && allocation.project.endMonth) {
                if (isMonthInRange(currentMonth, allocation.project.startMonth, allocation.project.endMonth)) {
                    return 'project';
                }
            }

            // Check pre-project allocation
            if (allocation.preProject && allocation.preProject.months && allocation.preProject.months.length > 0) {
                if (isMonthInArray(currentMonth, allocation.preProject.months)) {
                    return 'pre-project';
                }
            }

            // Has allocation but current month is not within any allocation period
            return 'engagement';
        }

        // Generate array of months between start and end (inclusive)
        function generateMonthRange(startMonth, endMonth) {
            const months = [];
            let current = startMonth;

            while (current <= endMonth) {
                months.push(current);
                // Increment month
                const [year, month] = current.split('-').map(Number);
                const nextMonth = month === 12 ? 1 : month + 1;
                const nextYear = month === 12 ? year + 1 : year;
                current = `${nextYear}-${String(nextMonth).padStart(2, '0')}`;
            }

            return months;
        }

        // Format month for display (e.g., "2025-01" -> "January")
        function formatMonthShort(monthStr) {
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const [year, month] = monthStr.split('-').map(Number);
            return monthNames[month - 1];
        }

        // Format month for display with year (e.g., "2025-01" -> "January, 2025")
        function formatMonthFull(monthStr) {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
            const [year, month] = monthStr.split('-').map(Number);
            return `${monthNames[month - 1]}, ${year}`;
        }

        // Get year from month string
        function getYearFromMonth(monthStr) {
            return monthStr.split('-')[0];
        }

        // ========================================
        // SCORING ALGORITHM FUNCTIONS
        // ========================================

        function getDaysUntilDeadline(deadline, currentDate = new Date()) {
            const deadlineDate = new Date(deadline);
            const today = new Date(currentDate);

            // Reset to start of day for comparison
            today.setHours(0, 0, 0, 0);
            const deadlineDay = new Date(deadlineDate);
            deadlineDay.setHours(0, 0, 0, 0);

            const msPerDay = 24 * 60 * 60 * 1000;
            return Math.floor((deadlineDay - today) / msPerDay);
        }

        function calculateDeadlineScore(todo, currentDate = new Date()) {
            if (!todo.deadline) return 0;

            const daysUntilDue = getDaysUntilDeadline(todo.deadline, currentDate);

            if (daysUntilDue < 0) {
                // OVERDUE: 150 base + 10 per day overdue, max 200
                return Math.min(200, 150 + (Math.abs(daysUntilDue) * 10));
            }

            if (daysUntilDue === 0) return 140;  // Due today
            if (daysUntilDue === 1) return 120;  // Due tomorrow
            if (daysUntilDue <= 3) return 100 - (daysUntilDue * 10);  // 70-90
            if (daysUntilDue <= 7) return 70 - (daysUntilDue * 5);    // 35-55
            if (daysUntilDue <= 14) return 30 - (daysUntilDue - 7);   // 23-30

            return Math.max(0, 20 - (daysUntilDue - 14));  // Distant future
        }

        function calculatePriorityScore(todo) {
            const priority = todo.priority || DEFAULT_PRIORITY;
            const weight = PRIORITY_TAGS[priority]?.weight;
            return weight ?? PRIORITY_TAGS[DEFAULT_PRIORITY].weight;
        }

        function calculateStalenessBonus(todo, currentDate = new Date()) {
            if (!todo.createdAt) return 0;

            const created = new Date(todo.createdAt);
            const today = new Date(currentDate);
            const msPerDay = 24 * 60 * 60 * 1000;
            const daysOld = Math.floor((today - created) / msPerDay);

            if (daysOld <= 7) return 0;
            if (daysOld <= 14) return 10;
            if (daysOld <= 30) return 20;
            return 30;
        }

        function calculateUrgencyScore(todo, currentDate = new Date()) {
            const deadline = calculateDeadlineScore(todo, currentDate);
            const priority = calculatePriorityScore(todo);
            const staleness = calculateStalenessBonus(todo, currentDate);

            return {
                total: deadline + priority + staleness,
                breakdown: { deadline, priority, staleness }
            };
        }

        function getScoreClassification(score) {
            if (score >= 250) return { label: 'Critical', class: 'critical' };
            if (score >= 200) return { label: 'Must Do Today', class: 'high' };
            if (score >= 150) return { label: 'High Priority', class: 'high' };
            if (score >= 100) return { label: 'Should Do Soon', class: 'medium' };
            if (score >= 50) return { label: 'Plan Ahead', class: '' };
            return { label: 'Backlog', class: '' };
        }

        // ========================================
        // DAILY PLAN GENERATION
        // ========================================

        function classifyTodos(scored, currentDate = new Date()) {
            const today = new Date(currentDate);
            today.setHours(0, 0, 0, 0);

            return {
                overdue: scored.filter(s => {
                    if (!s.todo.deadline) return false;
                    const d = new Date(s.todo.deadline);
                    d.setHours(0, 0, 0, 0);
                    return d < today;
                }),
                dueToday: scored.filter(s => {
                    if (!s.todo.deadline) return false;
                    const d = new Date(s.todo.deadline);
                    d.setHours(0, 0, 0, 0);
                    return d.getTime() === today.getTime();
                }),
                upcoming: scored.filter(s => {
                    if (!s.todo.deadline) return true; // Include todos without deadlines
                    const d = new Date(s.todo.deadline);
                    d.setHours(0, 0, 0, 0);
                    return d > today;
                })
            };
        }

        function buildPlan(classified, effectiveMinutes, config) {
            const plan = {
                date: new Date(),
                availableMinutes: effectiveMinutes,
                allocatedMinutes: 0,
                sections: {
                    overdue: [],
                    mustDoToday: [],
                    recommended: [],
                    ifTimePermits: []
                },
                warnings: [],
                insights: []
            };

            let remainingMinutes = effectiveMinutes;

            // Add overdue (capped, always shown)
            const overdueToShow = classified.overdue.slice(0, config.maxOverdueToShow);
            for (const item of overdueToShow) {
                plan.sections.overdue.push(formatScheduledItem(item));
                plan.allocatedMinutes += item.minutes;
            }

            // Add due today (always shown)
            for (const item of classified.dueToday) {
                plan.sections.mustDoToday.push(formatScheduledItem(item));
                plan.allocatedMinutes += item.minutes;
            }

            // Calculate remaining capacity
            remainingMinutes = effectiveMinutes - plan.allocatedMinutes;

            // Fill recommended from upcoming, respecting capacity
            for (const item of classified.upcoming) {
                if (remainingMinutes >= item.minutes) {
                    plan.sections.recommended.push(formatScheduledItem(item));
                    remainingMinutes -= item.minutes;
                    plan.allocatedMinutes += item.minutes;
                } else if (item.score.total >= 100) {
                    // High priority but doesn't fit
                    plan.sections.ifTimePermits.push(formatScheduledItem(item));
                }
            }

            return plan;
        }

        function formatScheduledItem(item) {
            return {
                todo: item.todo,
                urgencyScore: item.score.total,
                scoreBreakdown: item.score.breakdown,
                estimatedMinutes: item.minutes,
                reasoning: generateReasoning(item)
            };
        }

        function generateReasoning(item) {
            const parts = [];
            const daysUntil = getDaysUntilDeadline(item.todo.deadline);

            // Deadline reasoning
            if (daysUntil < 0) {
                parts.push(`Overdue by ${Math.abs(daysUntil)} day(s)`);
            } else if (daysUntil === 0) {
                parts.push("Due today");
            } else if (daysUntil === 1) {
                parts.push("Due tomorrow");
            } else if (daysUntil <= 7) {
                parts.push(`Due in ${daysUntil} days`);
            }

            // Priority reasoning (only mention if not normal)
            const priority = item.todo.priority || DEFAULT_PRIORITY;
            if (priority && priority !== "normal") {
                const priorityTag = PRIORITY_TAGS[priority];
                if (priorityTag) {
                    parts.push(priorityTag.label);
                }
            }

            // Effort reasoning
            const effort = item.todo.effort || DEFAULT_EFFORT;
            if (effort === "very_low") {
                parts.push("Quick win");
            } else if (effort === "very_high") {
                parts.push("Requires full day");
            }

            return parts.join(" â€¢ ") || "Scheduled based on priority";
        }

        function generateDailyPlan(currentDate = new Date()) {
            const config = { ...DEFAULT_SETTINGS, ...state.settings };

            // Calculate effective work time
            const effectiveMinutes = Math.floor(
                config.workdayMinutes * (1 - config.bufferPercentage / 100)
            );

            // 1. Filter incomplete and non-dropped todos
            const incomplete = state.todos.filter(t => !t.completed && !t.dropped);

            // 2. Score and sort
            const scored = incomplete
                .map(todo => ({
                    todo,
                    score: calculateUrgencyScore(todo, currentDate),
                    minutes: EFFORT_CONFIG[todo.effort || DEFAULT_EFFORT]?.minutes || 240
                }))
                .sort((a, b) => b.score.total - a.score.total);

            // 3. Classify by deadline status
            const classified = classifyTodos(scored, currentDate);

            // 4. Build the plan with time constraints
            const plan = buildPlan(classified, effectiveMinutes, config);

            // 5. Generate warnings and insights
            plan.warnings = generateWarnings(plan, scored, currentDate, config);
            plan.insights = generateInsights(plan, scored, currentDate);

            return plan;
        }

        // ========================================
        // WARNINGS AND INSIGHTS
        // ========================================

        function generateWarnings(plan, allScored, currentDate, config) {
            const warnings = [];

            // Check for overloaded day
            if (plan.allocatedMinutes > plan.availableMinutes) {
                const overloadHours = ((plan.allocatedMinutes - plan.availableMinutes) / 60).toFixed(1);
                warnings.push({
                    type: "overloaded",
                    severity: "critical",
                    message: `Today's critical items exceed available time by ${overloadHours} hours. Consider renegotiating deadlines or delegating.`
                });
            }

            // Check for large overdue backlog
            const totalOverdue = allScored.filter(s => getDaysUntilDeadline(s.todo.deadline) < 0).length;
            if (totalOverdue > config.maxOverdueToShow) {
                warnings.push({
                    type: "overdue_backlog",
                    severity: "warning",
                    message: `You have ${totalOverdue} overdue items total. Consider a backlog review session.`
                });
            }

            // Check for deadline cluster
            const next3Days = allScored.filter(s => {
                const d = getDaysUntilDeadline(s.todo.deadline);
                return d >= 0 && d <= 3;
            });
            const clusterMinutes = next3Days.reduce((sum, s) => sum + s.minutes, 0);

            if (clusterMinutes > config.workdayMinutes * 2) {
                const clusterHours = Math.round(clusterMinutes / 60);
                warnings.push({
                    type: "deadline_cluster",
                    severity: "warning",
                    message: `Heavy deadline cluster ahead: ${clusterHours} hours of work due in the next 3 days.`
                });
            }

            // Check for impossible single task
            const impossibleTask = allScored.find(s =>
                s.minutes > config.workdayMinutes && getDaysUntilDeadline(s.todo.deadline) <= 1
            );
            if (impossibleTask) {
                warnings.push({
                    type: "impossible_task",
                    severity: "critical",
                    message: `"${impossibleTask.todo.title}" requires ${(impossibleTask.minutes / 60).toFixed(1)} hours but is due very soon. Consider breaking it down.`
                });
            }

            return warnings;
        }

        function generateInsights(plan, allScored, currentDate) {
            const insights = [];

            // Light day - good opportunity
            const utilization = plan.availableMinutes > 0
                ? (plan.allocatedMinutes / plan.availableMinutes) * 100
                : 0;
            if (utilization < 50 && allScored.length > 0) {
                insights.push({
                    type: "light_day",
                    message: "Light day ahead! Good chance to get ahead on upcoming tasks or clear some backlog."
                });
            }

            // Quick wins available
            const quickWins = allScored.filter(s =>
                (s.todo.effort === "very_low") && s.score.total >= 50
            );
            if (quickWins.length >= 3) {
                insights.push({
                    type: "quick_wins",
                    message: `${quickWins.length} quick-win tasks available. Consider batching them to build momentum.`
                });
            }

            // All caught up
            if (plan.sections.overdue.length === 0 && plan.sections.mustDoToday.length === 0) {
                insights.push({
                    type: "caught_up",
                    message: "No overdue or urgent items! Great time to work on important-but-not-urgent tasks."
                });
            }

            // High effort concentration
            const highEffortToday = [...plan.sections.mustDoToday, ...plan.sections.recommended]
                .filter(s => s.todo.effort === "high" || s.todo.effort === "very_high");
            if (highEffortToday.length >= 2) {
                insights.push({
                    type: "high_effort",
                    message: "Multiple high-effort tasks today. Consider tackling the hardest one during your peak energy hours."
                });
            }

            return insights;
        }

        // ========================================
        // FORMATTING HELPERS
        // ========================================

        function formatDeadlineDisplay(deadline, currentDate = new Date()) {
            if (!deadline) return 'No deadline';

            const days = getDaysUntilDeadline(deadline, currentDate);

            if (days < -1) return `${Math.abs(days)} days overdue`;
            if (days === -1) return "Yesterday";
            if (days === 0) return "Today";
            if (days === 1) return "Tomorrow";
            if (days <= 7) return `In ${days} days`;

            return new Date(deadline).toLocaleDateString("en-US", {
                month: "short",
                day: "numeric"
            });
        }

        function formatEffortDisplay(effort) {
            const config = EFFORT_CONFIG[effort || DEFAULT_EFFORT];
            if (!config) return '4 hrs';
            if (config.minutes < 60) {
                return `${config.minutes} min`;
            }
            return `${config.minutes / 60} hrs`;
        }

        function formatPlanSummary(plan) {
            const overdueCount = plan.sections.overdue.length;
            const todayCount = plan.sections.mustDoToday.length;
            const totalHours = (plan.allocatedMinutes / 60).toFixed(1);

            const parts = [];
            if (overdueCount > 0) parts.push(`${overdueCount} overdue`);
            if (todayCount > 0) parts.push(`${todayCount} due today`);
            parts.push(`${totalHours} hrs planned`);

            return parts.join(" â€¢ ");
        }

        function formatDateHeader(date = new Date()) {
            return date.toLocaleDateString("en-US", {
                weekday: "long",
                month: "long",
                day: "numeric",
                year: "numeric"
            });
        }

        // ========================================
        // RECOMMENDATION PANEL RENDERING
        // ========================================

        function renderRecommendationPanel() {
            const plan = generateDailyPlan();

            // Update header
            recommendationDateText.textContent = `Daily Plan â€” ${formatDateHeader()}`;
            recommendationSummary.textContent = formatPlanSummary(plan);

            // Render warnings
            renderWarnings(plan.warnings);

            // Render sections
            renderRecommendationSection(overdueSection, overdueItems, overdueCount, plan.sections.overdue);
            renderRecommendationSection(mustDoSection, mustDoItems, mustDoCount, plan.sections.mustDoToday);
            renderRecommendationSection(recommendedSection, recommendedItems, recommendedCount, plan.sections.recommended);
            renderRecommendationSection(ifTimeSection, ifTimeItems, ifTimeCount, plan.sections.ifTimePermits);

            // Render insights
            renderInsights(plan.insights);

            // Show/hide empty state
            const hasItems = plan.sections.overdue.length > 0 ||
                           plan.sections.mustDoToday.length > 0 ||
                           plan.sections.recommended.length > 0 ||
                           plan.sections.ifTimePermits.length > 0;
            recommendationEmpty.classList.toggle('hidden', hasItems);
        }

        function renderRecommendationSection(sectionEl, itemsEl, countEl, items) {
            sectionEl.classList.toggle('hidden', items.length === 0);
            countEl.textContent = items.length;
            itemsEl.innerHTML = '';

            items.forEach((item, index) => {
                const itemEl = createRecommendationItemElement(item, index);
                itemsEl.appendChild(itemEl);
            });
        }

        function createRecommendationItemElement(item, index) {
            const div = document.createElement('div');
            div.className = `recommendation-item ${item.todo.completed ? 'completed' : ''}`;

            const priority = item.todo.priority || DEFAULT_PRIORITY;
            const effort = item.todo.effort || DEFAULT_EFFORT;
            const scoreClass = getScoreClassification(item.urgencyScore);

            // Build tags HTML
            let tagsHtml = '';
            if (priority !== 'normal') {
                const priorityTag = PRIORITY_TAGS[priority];
                tagsHtml += `<span class="priority-pill priority-${priority}">${priorityTag.label}</span>`;
            }

            // Add user tags
            if (item.todo.tagIds && item.todo.tagIds.length > 0) {
                item.todo.tagIds.forEach(tagId => {
                    const tag = state.tags.find(t => t.id === tagId);
                    if (tag) {
                        tagsHtml += `<span class="tag-pill" style="background-color: ${tag.color}20; color: ${tag.color}; border: 1px solid ${tag.color}40;">${escapeHtml(tag.name)}</span>`;
                    }
                });
            }

            div.innerHTML = `
                <div class="recommendation-item-header">
                    <div class="recommendation-item-checkbox ${item.todo.completed ? 'checked' : ''}"
                         onclick="toggleTodoFromRecommendation('${item.todo.id}')"></div>
                    <div class="recommendation-item-title">${escapeHtml(item.todo.title)}</div>
                </div>
                <div class="recommendation-item-meta">
                    <span class="recommendation-item-effort">â±ï¸ ${formatEffortDisplay(effort)}</span>
                    <span class="recommendation-item-deadline">ðŸ“… ${formatDeadlineDisplay(item.todo.deadline)}</span>
                </div>
                ${tagsHtml ? `<div class="recommendation-item-tags">${tagsHtml}</div>` : ''}
                <div class="recommendation-item-reasoning">${item.reasoning}</div>
                <div class="recommendation-item-score">
                    <span class="score-badge ${scoreClass.class}">Score: ${item.urgencyScore}</span>
                </div>
            `;

            return div;
        }

        function renderWarnings(warnings) {
            warningsSection.innerHTML = '';
            warningsSection.classList.toggle('hidden', warnings.length === 0);

            warnings.forEach(warning => {
                const card = document.createElement('div');
                card.className = `warning-card ${warning.severity === 'critical' ? 'critical' : ''}`;
                card.innerHTML = `
                    <span class="warning-icon">âš ï¸</span>
                    <span class="warning-message">${escapeHtml(warning.message)}</span>
                `;
                warningsSection.appendChild(card);
            });
        }

        function renderInsights(insights) {
            insightsSection.classList.toggle('hidden', insights.length === 0);
            insightsItems.innerHTML = '';

            insights.forEach(insight => {
                const card = document.createElement('div');
                card.className = 'insight-card';
                card.innerHTML = `
                    <span class="insight-icon">ðŸ’¡</span>
                    <span class="insight-message">${escapeHtml(insight.message)}</span>
                `;
                insightsItems.appendChild(card);
            });
        }

        function toggleTodoFromRecommendation(todoId) {
            const index = state.todos.findIndex(t => t.id === todoId);
            if (index !== -1) {
                toggleTodo(index);
            }
        }

        // ========================================
        // PRIORITY AUTOCOMPLETE FUNCTIONS
        // ========================================

        function getFilteredPriorityOptions(filter = '') {
            const filterLower = filter.toLowerCase();
            return Object.keys(PRIORITY_TAGS).filter(key => {
                const priority = PRIORITY_TAGS[key];
                if (filter && !priority.label.toLowerCase().includes(filterLower) &&
                    !priority.name.toLowerCase().includes(filterLower)) {
                    return false;
                }
                return true;
            });
        }

        function renderPriorityDropdown(filter = '') {
            priorityDropdown.innerHTML = '';
            const filteredOptions = getFilteredPriorityOptions(filter);

            filteredOptions.forEach((key, filteredIndex) => {
                const priority = PRIORITY_TAGS[key];
                const option = document.createElement('div');
                option.className = `priority-option ${state.selectedPriority === key ? 'selected' : ''} ${state.priorityHighlightIndex === filteredIndex ? 'highlighted' : ''}`;
                option.innerHTML = `
                    <span class="priority-option-color" style="background-color: ${priority.color}"></span>
                    <span class="priority-option-label">${priority.label}</span>
                    <span class="priority-option-desc">${priority.description}</span>
                `;
                option.onclick = () => selectPriority(key);
                priorityDropdown.appendChild(option);
            });
        }

        function selectPriority(key) {
            state.selectedPriority = key;
            todoPriorityInput.value = PRIORITY_TAGS[key].label;
            closePriorityDropdown();
        }

        function openPriorityDropdown() {
            state.priorityDropdownOpen = true;
            state.priorityHighlightIndex = -1;
            renderPriorityDropdown(todoPriorityInput.value);
            priorityDropdown.classList.add('open');
        }

        function closePriorityDropdown() {
            state.priorityDropdownOpen = false;
            state.priorityHighlightIndex = -1;
            priorityDropdown.classList.remove('open');
        }

        // Priority input event listeners
        if (todoPriorityInput) {
            todoPriorityInput.addEventListener('focus', () => {
                openPriorityDropdown();
            });

            todoPriorityInput.addEventListener('input', (e) => {
                openPriorityDropdown();
                renderPriorityDropdown(e.target.value);
                // Auto-highlight first match when typing
                const filteredOptions = getFilteredPriorityOptions(e.target.value);
                if (filteredOptions.length > 0) {
                    state.priorityHighlightIndex = 0;
                    renderPriorityDropdown(e.target.value);
                }
            });

            todoPriorityInput.addEventListener('keydown', (e) => {
                const filteredOptions = getFilteredPriorityOptions(todoPriorityInput.value);

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    state.priorityHighlightIndex = Math.min(state.priorityHighlightIndex + 1, filteredOptions.length - 1);
                    renderPriorityDropdown(todoPriorityInput.value);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    state.priorityHighlightIndex = Math.max(state.priorityHighlightIndex - 1, 0);
                    renderPriorityDropdown(todoPriorityInput.value);
                } else if (e.key === 'Tab' && !e.shiftKey && state.priorityDropdownOpen) {
                    // Tab (forward only) with dropdown open: select first/highlighted match and move on
                    if (filteredOptions.length > 0) {
                        e.preventDefault();
                        const indexToSelect = state.priorityHighlightIndex >= 0 ? state.priorityHighlightIndex : 0;
                        selectPriority(filteredOptions[indexToSelect]);
                        // Move focus to the next focusable element
                        todoEngagementInput.focus();
                    }
                    // If no filtered options, let Tab naturally move to next control
                } else if (e.key === 'Enter' && state.priorityDropdownOpen) {
                    e.preventDefault();
                    if (filteredOptions.length > 0) {
                        const indexToSelect = state.priorityHighlightIndex >= 0 ? state.priorityHighlightIndex : 0;
                        selectPriority(filteredOptions[indexToSelect]);
                    }
                } else if (e.key === 'Escape') {
                    closePriorityDropdown();
                }
            });

            todoPriorityInput.addEventListener('blur', () => {
                // Delay to allow click events on dropdown items
                setTimeout(() => {
                    // Validate input - if not a valid priority, reset to selected
                    const inputValue = todoPriorityInput.value.toLowerCase();
                    const matchingKey = Object.keys(PRIORITY_TAGS).find(
                        key => PRIORITY_TAGS[key].label.toLowerCase() === inputValue ||
                               PRIORITY_TAGS[key].name.toLowerCase() === inputValue
                    );

                    if (matchingKey) {
                        state.selectedPriority = matchingKey;
                    }

                    // Always show the selected priority label
                    todoPriorityInput.value = PRIORITY_TAGS[state.selectedPriority].label;
                    closePriorityDropdown();
                }, 200);
            });
        }

        // ========================================
        // PLANNING SETTINGS FUNCTIONS
        // ========================================

        function savePlanningSettings(event) {
            event.preventDefault();

            state.settings.workdayMinutes = parseInt(document.getElementById('workday-minutes').value) || DEFAULT_SETTINGS.workdayMinutes;
            state.settings.bufferPercentage = parseInt(document.getElementById('buffer-percentage').value) || DEFAULT_SETTINGS.bufferPercentage;
            state.settings.maxOverdueToShow = parseInt(document.getElementById('max-overdue').value) || DEFAULT_SETTINGS.maxOverdueToShow;
            state.settings.planningHorizonDays = parseInt(document.getElementById('planning-horizon').value) || DEFAULT_SETTINGS.planningHorizonDays;

            // Refresh recommendation panel with new settings
            if (state.currentPage === 'app' && state.currentTab === 'home') {
                renderRecommendationPanel();
            }

            // Auto-save to IndexedDB
            saveStateToIndexedDB().catch(err => console.error('Failed to save state:', err));

            alert('Planning settings saved successfully!');
        }

        function loadPlanningSettings() {
            document.getElementById('workday-minutes').value = state.settings.workdayMinutes;
            document.getElementById('buffer-percentage').value = state.settings.bufferPercentage;
            document.getElementById('max-overdue').value = state.settings.maxOverdueToShow;
            document.getElementById('planning-horizon').value = state.settings.planningHorizonDays;
        }

        function renderPlanningSettings() {
            loadPlanningSettings();
        }

        // ========================================
        // STORAGE SECTION FUNCTIONS
        // ========================================

        async function renderStorageSection() {
            const stats = await getStorageStats();
            document.getElementById('storage-size').textContent = formatBytes(stats.estimatedSize);
            document.getElementById('storage-todos').textContent = stats.todoCount;
            document.getElementById('storage-engagements').textContent = stats.engagementCount;
        }

        function openClearStateModal() {
            document.getElementById('clear-state-modal').classList.remove('hidden');
        }

        function closeClearStateModal() {
            document.getElementById('clear-state-modal').classList.add('hidden');
        }

        function exportThenClear() {
            // Export data first
            exportData();
            // Then clear after a short delay to allow download to start
            setTimeout(() => {
                confirmClearState();
            }, 500);
        }

        async function confirmClearState() {
            try {
                // Clear IndexedDB
                await clearIndexedDB();

                // Reset in-memory state
                state.todos = [];
                state.engagements = [];
                state.people = [];
                state.roles = [];
                state.tags = [];
                state.settings = { ...DEFAULT_SETTINGS };

                // Close modal and navigate to landing page
                closeClearStateModal();
                navigateTo('landing');
            } catch (error) {
                console.error('Failed to clear state:', error);
                alert('Failed to clear browser state. Please try again.');
            }
        }

        // ========================================
        // DATETIME HELPERS
        // ========================================

        function getDefaultDeadline() {
            const now = new Date();
            now.setHours(17, 0, 0, 0); // Default to 5 PM today
            return formatDateTimeLocal(now);
        }

        function formatDateTimeLocal(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        // Show IndexedDB warning modal
        function showIndexedDBWarning() {
            document.getElementById('indexeddb-warning-modal').classList.remove('hidden');
        }

        // Initialize application with IndexedDB
        async function initializeApp() {
            try {
                // Initialize IndexedDB
                await initDB();

                // Try to load saved state
                const savedState = await loadStateFromIndexedDB();

                if (savedState) {
                    // Restore state from IndexedDB
                    state.todos = Array.isArray(savedState.todos) ? savedState.todos : [];
                    state.engagements = Array.isArray(savedState.engagements) ? savedState.engagements : [];
                    state.people = Array.isArray(savedState.people) ? savedState.people : [];
                    state.roles = Array.isArray(savedState.roles) ? savedState.roles : [];
                    state.tags = Array.isArray(savedState.tags) ? savedState.tags : [];
                    state.allocations = Array.isArray(savedState.allocations) ? savedState.allocations : [];

                    // Restore settings (merge with defaults)
                    if (savedState.settings && typeof savedState.settings === 'object') {
                        state.settings = { ...DEFAULT_SETTINGS, ...savedState.settings };
                    }

                    // Ensure all todos have required fields with defaults
                    state.todos = state.todos.map(todo => ({
                        ...todo,
                        title: todo.title || todo.description || 'Untitled',
                        description: todo.description || null,
                        deadline: todo.deadline || (todo.dueDate ? new Date(todo.dueDate).toISOString() : null),
                        effort: todo.effort || DEFAULT_EFFORT,
                        priority: PRIORITY_TAGS[todo.priority] ? todo.priority : DEFAULT_PRIORITY,
                        completedAt: todo.completedAt || null,
                        createdAt: todo.createdAt || new Date().toISOString(),
                        updatedAt: todo.updatedAt || new Date().toISOString()
                    }));

                    // Run migration for backwards compatibility
                    migrateContactsToPeople();
                    migrateEngagementLifecycle();
                    migrateEngagementAllocations();

                    // Update all engagement statuses based on linked todos (auto-pause/resume)
                    updateAllEngagementStatuses();

                    // Navigate directly to app with home tab
                    state.currentTab = 'home';
                    navigateTo('app');
                } else {
                    // No saved state, show landing page
                    migrateContactsToPeople();
                    migrateEngagementLifecycle();
                    migrateEngagementAllocations();
                    updateAllEngagementStatuses();
                    navigateTo('landing');
                }
            } catch (error) {
                console.error('Failed to initialize IndexedDB:', error);
                // Show warning modal if IndexedDB is unavailable
                showIndexedDBWarning();
            }
        }

        // ========================================
        // DATETIMEPICKER COMPONENT
        // ========================================

        const DTP_MONTH_NAMES = ['January', 'February', 'March', 'April', 'May', 'June',
                                  'July', 'August', 'September', 'October', 'November', 'December'];
        const DTP_DAY_NAMES = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

        class DateTimePicker {
            constructor(inputElement, options = {}) {
                this.input = inputElement;

                // Auto-detect date-only mode from input type
                const isDateOnly = inputElement.type === 'date';

                this.options = {
                    defaultHour: 17,
                    defaultMinute: 0,
                    startOfWeek: 1, // Monday
                    closeOnSelect: true,
                    dateOnly: isDateOnly,
                    onChange: null,
                    ...options
                };

                // State
                this.isOpen = false;
                this.selectedDate = null;
                this.viewDate = new Date();
                this.focusedDate = new Date();
                this.hours = this.options.defaultHour;
                this.minutes = this.options.defaultMinute;
                this.focusedElement = 'calendar'; // 'calendar', 'hours', 'minutes', 'select'
                this.monthPickerOpen = false;
                this.yearPickerOpen = false;
                this.yearRangeStart = new Date().getFullYear() - 5;

                // Long press state
                this.pressTimer = null;
                this.pressInterval = null;

                // Scroll accumulator for month navigation
                this.scrollAccumulator = 0;

                // Initialize
                this.createElements();
                this.bindEvents();
                this.parseInitialValue();
            }

            createElements() {
                // Wrap input
                this.wrapper = document.createElement('div');
                this.wrapper.className = 'dtp-input-wrapper';
                this.input.parentNode.insertBefore(this.wrapper, this.input);
                this.wrapper.appendChild(this.input);

                // Add display input (replaces native input visually)
                this.displayInput = document.createElement('input');
                this.displayInput.type = 'text';
                this.displayInput.className = 'dtp-display-input';
                this.displayInput.readOnly = true;
                this.displayInput.placeholder = 'Select date and time';
                this.wrapper.appendChild(this.displayInput);

                // Hide original input
                this.input.style.display = 'none';

                // Calendar icon
                this.calendarIcon = document.createElement('span');
                this.calendarIcon.className = 'dtp-calendar-icon';
                this.calendarIcon.innerHTML = 'ðŸ“…';
                this.calendarIcon.setAttribute('role', 'button');
                this.calendarIcon.setAttribute('aria-label', 'Open date picker');
                this.wrapper.appendChild(this.calendarIcon);

                // Create picker container
                this.picker = document.createElement('div');
                this.picker.className = 'dtp-picker';
                this.picker.setAttribute('role', 'dialog');
                this.picker.setAttribute('aria-label', 'Select date and time');
                this.picker.innerHTML = this.createPickerHTML();
                this.wrapper.appendChild(this.picker);

                // Cache DOM references
                this.cacheElements();
            }

            createPickerHTML() {
                const title = this.options.dateOnly ? 'Select Date' : 'Select Date and Time';
                const timePanelHTML = this.options.dateOnly ? '' : `
                        <div class="dtp-time-panel">
                            <div class="dtp-date-display"></div>
                            <div class="dtp-time-spinners">
                                <div class="dtp-spinner dtp-hours-spinner">
                                    <button type="button" class="dtp-spinner-btn dtp-spinner-up" data-field="hours" data-dir="up" aria-label="Increase hours">â–²</button>
                                    <input type="text" class="dtp-time-input dtp-hours-input" maxlength="2" aria-label="Hours">
                                    <button type="button" class="dtp-spinner-btn dtp-spinner-down" data-field="hours" data-dir="down" aria-label="Decrease hours">â–¼</button>
                                </div>
                                <span class="dtp-time-separator">:</span>
                                <div class="dtp-spinner dtp-minutes-spinner">
                                    <button type="button" class="dtp-spinner-btn dtp-spinner-up" data-field="minutes" data-dir="up" aria-label="Increase minutes">â–²</button>
                                    <input type="text" class="dtp-time-input dtp-minutes-input" maxlength="2" aria-label="Minutes">
                                    <button type="button" class="dtp-spinner-btn dtp-spinner-down" data-field="minutes" data-dir="down" aria-label="Decrease minutes">â–¼</button>
                                </div>
                            </div>
                        </div>`;

                return `
                    <div class="dtp-header">
                        <span class="dtp-header-title">${title}</span>
                    </div>
                    <div class="dtp-body${this.options.dateOnly ? ' dtp-date-only' : ''}">
                        ${timePanelHTML}
                        <div class="dtp-calendar-panel">
                            <div class="dtp-calendar-header">
                                <button type="button" class="dtp-nav-btn dtp-prev-month" aria-label="Previous month">â—€</button>
                                <span class="dtp-month-year">
                                    <span class="dtp-month-name" tabindex="0"></span>
                                    <span class="dtp-year" tabindex="0"></span>
                                </span>
                                <button type="button" class="dtp-nav-btn dtp-next-month" aria-label="Next month">â–¶</button>
                            </div>
                            <div class="dtp-day-headers"></div>
                            <div class="dtp-calendar-grid" tabindex="0" role="grid" aria-label="Calendar"></div>
                        </div>
                    </div>
                    <div class="dtp-footer">
                        <button type="button" class="dtp-select-btn">Select</button>
                    </div>
                    <div class="dtp-overlay dtp-month-overlay">
                        <div class="dtp-overlay-header">Select Month</div>
                        <div class="dtp-overlay-grid dtp-month-grid"></div>
                    </div>
                    <div class="dtp-overlay dtp-year-overlay">
                        <div class="dtp-overlay-header">Select Year</div>
                        <div class="dtp-overlay-grid dtp-year-grid"></div>
                    </div>
                `;
            }

            cacheElements() {
                this.dateDisplay = this.picker.querySelector('.dtp-date-display');
                this.hoursInput = this.picker.querySelector('.dtp-hours-input');
                this.minutesInput = this.picker.querySelector('.dtp-minutes-input');
                this.calendarGrid = this.picker.querySelector('.dtp-calendar-grid');
                this.dayHeaders = this.picker.querySelector('.dtp-day-headers');
                this.monthName = this.picker.querySelector('.dtp-month-name');
                this.yearDisplay = this.picker.querySelector('.dtp-year');
                this.prevMonthBtn = this.picker.querySelector('.dtp-prev-month');
                this.nextMonthBtn = this.picker.querySelector('.dtp-next-month');
                this.selectBtn = this.picker.querySelector('.dtp-select-btn');
                this.monthOverlay = this.picker.querySelector('.dtp-month-overlay');
                this.yearOverlay = this.picker.querySelector('.dtp-year-overlay');
                this.monthGrid = this.picker.querySelector('.dtp-month-grid');
                this.yearGrid = this.picker.querySelector('.dtp-year-grid');
            }

            bindEvents() {
                // Open picker
                this.displayInput.addEventListener('click', () => this.open());
                this.displayInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation(); // Prevent form submission when inside a form
                        this.open();
                    }
                });
                this.calendarIcon.addEventListener('click', () => this.open());

                // Close on outside click (use mousedown to prevent race with click)
                document.addEventListener('mousedown', (e) => {
                    if (this.isOpen && !this.wrapper.contains(e.target)) {
                        this.close();
                    }
                });

                // Keyboard navigation (use capture phase to intercept before modal)
                this.wrapper.addEventListener('keydown', (e) => this.handleKeydown(e), true);

                // Month navigation buttons
                this.prevMonthBtn.addEventListener('click', () => this.navigateMonth(-1));
                this.nextMonthBtn.addEventListener('click', () => this.navigateMonth(1));

                // Calendar grid click
                this.calendarGrid.addEventListener('click', (e) => this.handleDayClick(e));

                // Mouse wheel on calendar
                this.calendarGrid.addEventListener('wheel', (e) => this.handleCalendarWheel(e));

                // Time spinner buttons
                this.picker.querySelectorAll('.dtp-spinner-btn').forEach(btn => {
                    btn.addEventListener('mousedown', (e) => this.startSpinnerPress(e));
                    btn.addEventListener('mouseup', () => this.stopSpinnerPress());
                    btn.addEventListener('mouseleave', () => this.stopSpinnerPress());
                    btn.addEventListener('click', (e) => this.handleSpinnerClick(e));
                });

                // Time inputs (only if not date-only mode)
                if (!this.options.dateOnly && this.hoursInput && this.minutesInput) {
                    this.hoursInput.addEventListener('focus', () => { this.focusedElement = 'hours'; });
                    this.minutesInput.addEventListener('focus', () => { this.focusedElement = 'minutes'; });
                    this.hoursInput.addEventListener('input', (e) => this.handleTimeInput(e, 'hours'));
                    this.minutesInput.addEventListener('input', (e) => this.handleTimeInput(e, 'minutes'));
                    this.hoursInput.addEventListener('blur', () => this.formatTimeInput('hours'));
                    this.minutesInput.addEventListener('blur', () => this.formatTimeInput('minutes'));

                    // Wheel on time inputs
                    this.hoursInput.addEventListener('wheel', (e) => this.handleTimeWheel(e, 'hours'));
                    this.minutesInput.addEventListener('wheel', (e) => this.handleTimeWheel(e, 'minutes'));
                }

                // Select button
                this.selectBtn.addEventListener('click', () => this.confirm());
                this.selectBtn.addEventListener('focus', () => { this.focusedElement = 'select'; });

                // Month/Year picker triggers
                this.monthName.addEventListener('mouseenter', () => this.showMonthPicker());
                this.monthName.addEventListener('click', () => this.showMonthPicker());
                this.yearDisplay.addEventListener('mouseenter', () => this.showYearPicker());
                this.yearDisplay.addEventListener('click', () => this.showYearPicker());

                // Overlay events
                this.monthOverlay.addEventListener('mouseleave', () => this.hideMonthPicker());
                this.yearOverlay.addEventListener('mouseleave', () => this.hideYearPicker());
                this.monthGrid.addEventListener('click', (e) => this.handleMonthSelect(e));
                this.yearGrid.addEventListener('click', (e) => this.handleYearSelect(e));
                this.monthGrid.addEventListener('wheel', (e) => this.handleMonthPickerWheel(e));
                this.yearGrid.addEventListener('wheel', (e) => this.handleYearPickerWheel(e));
            }

            parseInitialValue() {
                const value = this.input.value;
                if (value) {
                    const date = new Date(value);
                    if (!isNaN(date.getTime())) {
                        this.selectedDate = date;
                        this.viewDate = new Date(date);
                        this.focusedDate = new Date(date);
                        this.hours = date.getHours();
                        this.minutes = date.getMinutes();
                        this.updateDisplayInput();
                    }
                }
            }

            open() {
                if (this.isOpen) return;
                this.isOpen = true;

                // Re-parse value in case it was set externally after initialization
                this.parseInitialValue();

                // Set view date to selected or today
                if (this.selectedDate) {
                    this.viewDate = new Date(this.selectedDate);
                    this.focusedDate = new Date(this.selectedDate);
                    this.hours = this.selectedDate.getHours();
                    this.minutes = this.selectedDate.getMinutes();
                } else {
                    this.viewDate = new Date();
                    this.focusedDate = new Date();
                    this.hours = this.options.defaultHour;
                    this.minutes = this.options.defaultMinute;
                }

                this.render();

                // Detect if picker should appear above input (smart positioning)
                this.positionPicker();

                this.picker.classList.add('open');
                this.focusedElement = 'calendar';

                // Focus calendar grid
                setTimeout(() => this.calendarGrid.focus(), 50);
            }

            positionPicker() {
                // Reset position class
                this.picker.classList.remove('above');

                // Get input position and picker dimensions
                const inputRect = this.displayInput.getBoundingClientRect();
                const pickerHeight = this.picker.offsetHeight || 380; // Estimated height
                const viewportHeight = window.innerHeight;
                const spaceBelow = viewportHeight - inputRect.bottom;
                const spaceAbove = inputRect.top;

                // Position above if insufficient space below and more space above
                if (spaceBelow < pickerHeight + 20 && spaceAbove > spaceBelow) {
                    this.picker.classList.add('above');
                }
            }

            close() {
                if (!this.isOpen) return;
                this.isOpen = false;
                this.picker.classList.remove('open', 'above');
                this.hideMonthPicker();
                this.hideYearPicker();
                this.displayInput.focus();
            }

            confirm() {
                // Build final date
                const finalDate = new Date(this.focusedDate);
                finalDate.setHours(this.hours, this.minutes, 0, 0);
                this.selectedDate = finalDate;

                // Update inputs
                this.updateDisplayInput();
                this.updateHiddenInput();

                // Callback
                if (this.options.onChange) {
                    this.options.onChange(finalDate, this.formatDateTime(finalDate));
                }

                // Trigger change event on original input
                this.input.dispatchEvent(new Event('change', { bubbles: true }));

                this.close();
            }

            render() {
                this.renderDayHeaders();
                this.renderCalendar();
                this.renderTimePanel();
                this.renderMonthYearHeader();
            }

            renderDayHeaders() {
                this.dayHeaders.innerHTML = DTP_DAY_NAMES.map(day =>
                    `<span class="dtp-day-header">${day}</span>`
                ).join('');
            }

            renderCalendar() {
                const year = this.viewDate.getFullYear();
                const month = this.viewDate.getMonth();

                // First day of month
                const firstDay = new Date(year, month, 1);
                // Last day of month
                const lastDay = new Date(year, month + 1, 0);
                // Day of week for first day (adjusted for Monday start)
                let startDay = firstDay.getDay() - this.options.startOfWeek;
                if (startDay < 0) startDay += 7;

                const today = new Date();
                today.setHours(0, 0, 0, 0);

                let html = '';
                let dayCount = 1;
                let nextMonthDay = 1;

                // Previous month days
                const prevMonthLastDay = new Date(year, month, 0).getDate();

                for (let i = 0; i < 42; i++) { // 6 rows * 7 days
                    let dayNum, dateObj, classes = ['dtp-day'];

                    if (i < startDay) {
                        // Previous month
                        dayNum = prevMonthLastDay - startDay + i + 1;
                        dateObj = new Date(year, month - 1, dayNum);
                        classes.push('other-month');
                    } else if (dayCount <= lastDay.getDate()) {
                        // Current month
                        dayNum = dayCount;
                        dateObj = new Date(year, month, dayNum);
                        dayCount++;
                    } else {
                        // Next month
                        dayNum = nextMonthDay;
                        dateObj = new Date(year, month + 1, dayNum);
                        classes.push('other-month');
                        nextMonthDay++;
                    }

                    // Check states
                    const dateKey = this.dateToKey(dateObj);
                    const todayKey = this.dateToKey(today);
                    const selectedKey = this.selectedDate ? this.dateToKey(this.selectedDate) : null;
                    const focusedKey = this.dateToKey(this.focusedDate);

                    if (dateKey === todayKey) classes.push('today');
                    if (dateKey === selectedKey) classes.push('selected');
                    if (dateKey === focusedKey) classes.push('focused');

                    html += `<button type="button" class="${classes.join(' ')}" data-date="${dateObj.toISOString()}" tabindex="-1">${dayNum}</button>`;
                }

                this.calendarGrid.innerHTML = html;
            }

            renderTimePanel() {
                // Skip for date-only mode (no time panel exists)
                if (this.options.dateOnly) return;

                // Date display
                const dateStr = this.formatDate(this.focusedDate);
                if (this.dateDisplay) this.dateDisplay.textContent = dateStr;

                // Time inputs
                if (this.hoursInput) this.hoursInput.value = String(this.hours).padStart(2, '0');
                if (this.minutesInput) this.minutesInput.value = String(this.minutes).padStart(2, '0');
            }

            renderMonthYearHeader() {
                this.monthName.textContent = DTP_MONTH_NAMES[this.viewDate.getMonth()];
                this.yearDisplay.textContent = this.viewDate.getFullYear();
            }

            renderMonthPicker() {
                const currentMonth = this.viewDate.getMonth();
                let html = '';
                for (let i = 0; i < 12; i++) {
                    const classes = ['dtp-overlay-cell'];
                    if (i === currentMonth) classes.push('selected');
                    if (i === new Date().getMonth() && this.viewDate.getFullYear() === new Date().getFullYear()) {
                        classes.push('current');
                    }
                    html += `<button type="button" class="${classes.join(' ')}" data-month="${i}">${DTP_MONTH_NAMES[i].substring(0, 3)}</button>`;
                }
                this.monthGrid.innerHTML = html;
            }

            renderYearPicker() {
                const currentYear = this.viewDate.getFullYear();
                const thisYear = new Date().getFullYear();
                let html = '';
                for (let i = 0; i < 12; i++) {
                    const year = this.yearRangeStart + i;
                    const classes = ['dtp-overlay-cell'];
                    if (year === currentYear) classes.push('selected');
                    if (year === thisYear) classes.push('current');
                    html += `<button type="button" class="${classes.join(' ')}" data-year="${year}">${year}</button>`;
                }
                this.yearGrid.innerHTML = html;
            }

            // Navigation methods
            navigateMonth(delta) {
                this.viewDate.setMonth(this.viewDate.getMonth() + delta);
                this.focusedDate = new Date(this.viewDate);
                this.focusedDate.setDate(1);
                this.render();
            }

            navigateYear(delta) {
                this.viewDate.setFullYear(this.viewDate.getFullYear() + delta);
                this.focusedDate = new Date(this.viewDate);
                this.render();
            }

            navigateDay(delta) {
                this.focusedDate.setDate(this.focusedDate.getDate() + delta);
                // Update view if month changed
                if (this.focusedDate.getMonth() !== this.viewDate.getMonth() ||
                    this.focusedDate.getFullYear() !== this.viewDate.getFullYear()) {
                    this.viewDate = new Date(this.focusedDate);
                }
                this.render();
            }

            navigateWeek(delta) {
                this.navigateDay(delta * 7);
            }

            goToFirstDayOfMonth() {
                this.focusedDate = new Date(this.viewDate.getFullYear(), this.viewDate.getMonth(), 1);
                this.render();
            }

            goToLastDayOfMonth() {
                this.focusedDate = new Date(this.viewDate.getFullYear(), this.viewDate.getMonth() + 1, 0);
                this.render();
            }

            // Event handlers
            handleKeydown(e) {
                if (!this.isOpen) return;

                // Close overlays first
                if (this.monthPickerOpen || this.yearPickerOpen) {
                    if (e.key === 'Escape') {
                        this.hideMonthPicker();
                        this.hideYearPicker();
                        e.preventDefault();
                        e.stopPropagation();
                        return;
                    }
                }

                switch (e.key) {
                    case 'Escape':
                        this.close();
                        e.preventDefault();
                        e.stopPropagation();
                        break;
                    case 'Enter':
                        if (this.focusedElement === 'calendar') {
                            this.selectFocusedDate();
                            if (this.options.dateOnly) {
                                this.selectBtn.focus();
                            } else {
                                this.hoursInput.focus();
                            }
                        } else if (this.focusedElement === 'select') {
                            this.confirm();
                        }
                        e.preventDefault();
                        break;
                    case 'Tab':
                        this.handleTab(e);
                        break;
                    case 'ArrowLeft':
                        if (this.focusedElement === 'calendar') {
                            this.navigateDay(-1);
                            e.preventDefault();
                        } else if (!this.options.dateOnly && this.focusedElement === 'minutes') {
                            this.hoursInput.focus();
                            e.preventDefault();
                        }
                        break;
                    case 'ArrowRight':
                        if (this.focusedElement === 'calendar') {
                            this.navigateDay(1);
                            e.preventDefault();
                        } else if (!this.options.dateOnly && this.focusedElement === 'hours') {
                            this.minutesInput.focus();
                            e.preventDefault();
                        }
                        break;
                    case 'ArrowUp':
                        if (this.focusedElement === 'calendar') {
                            this.navigateWeek(-1);
                        } else if (this.focusedElement === 'hours') {
                            this.adjustTime('hours', 1);
                        } else if (this.focusedElement === 'minutes') {
                            this.adjustTime('minutes', 1);
                        }
                        e.preventDefault();
                        break;
                    case 'ArrowDown':
                        if (this.focusedElement === 'calendar') {
                            this.navigateWeek(1);
                        } else if (this.focusedElement === 'hours') {
                            this.adjustTime('hours', -1);
                        } else if (this.focusedElement === 'minutes') {
                            this.adjustTime('minutes', -1);
                        }
                        e.preventDefault();
                        break;
                    case 'PageUp':
                        if (e.ctrlKey) {
                            this.navigateYear(-1);
                        } else {
                            this.navigateMonth(-1);
                        }
                        e.preventDefault();
                        break;
                    case 'PageDown':
                        if (e.ctrlKey) {
                            this.navigateYear(1);
                        } else {
                            this.navigateMonth(1);
                        }
                        e.preventDefault();
                        break;
                    case 'Home':
                        if (this.focusedElement === 'calendar') {
                            this.goToFirstDayOfMonth();
                            e.preventDefault();
                        }
                        break;
                    case 'End':
                        if (this.focusedElement === 'calendar') {
                            this.goToLastDayOfMonth();
                            e.preventDefault();
                        }
                        break;
                    case ' ':
                        if (this.focusedElement === 'calendar') {
                            this.selectFocusedDate();
                            e.preventDefault();
                        }
                        break;
                }
            }

            handleTab(e) {
                if (this.options.dateOnly) {
                    // Date-only mode: Calendar -> Select button
                    if (e.shiftKey) {
                        if (this.focusedElement === 'select') {
                            this.calendarGrid.focus();
                            this.focusedElement = 'calendar';
                            e.preventDefault();
                        }
                    } else {
                        if (this.focusedElement === 'calendar') {
                            this.selectBtn.focus();
                            e.preventDefault();
                        } else if (this.focusedElement === 'select') {
                            this.close();
                        }
                    }
                } else {
                    // DateTime mode: Calendar -> Hours -> Minutes -> Select button
                    if (e.shiftKey) {
                        // Backward
                        if (this.focusedElement === 'hours') {
                            this.calendarGrid.focus();
                            this.focusedElement = 'calendar';
                            e.preventDefault();
                        } else if (this.focusedElement === 'minutes') {
                            this.hoursInput.focus();
                            e.preventDefault();
                        } else if (this.focusedElement === 'select') {
                            this.minutesInput.focus();
                            e.preventDefault();
                        }
                    } else {
                        // Forward
                        if (this.focusedElement === 'calendar') {
                            this.hoursInput.focus();
                            e.preventDefault();
                        } else if (this.focusedElement === 'hours') {
                            this.minutesInput.focus();
                            e.preventDefault();
                        } else if (this.focusedElement === 'minutes') {
                            this.selectBtn.focus();
                            e.preventDefault();
                        } else if (this.focusedElement === 'select') {
                            // Allow natural tab out, then close
                            this.close();
                        }
                    }
                }
            }

            handleDayClick(e) {
                const dayEl = e.target.closest('.dtp-day');
                if (!dayEl) return;

                const date = new Date(dayEl.dataset.date);
                this.focusedDate = date;
                this.viewDate = new Date(date);
                this.selectFocusedDate();

                // Move focus to time (or select button for date-only)
                if (this.options.dateOnly) {
                    this.selectBtn.focus();
                } else {
                    this.hoursInput.focus();
                }
            }

            handleCalendarWheel(e) {
                e.preventDefault();
                this.scrollAccumulator += e.deltaY;

                const threshold = 50;
                if (Math.abs(this.scrollAccumulator) >= threshold) {
                    const direction = this.scrollAccumulator > 0 ? 1 : -1;
                    this.navigateMonth(direction);
                    this.scrollAccumulator = 0;
                }
            }

            handleSpinnerClick(e) {
                const btn = e.target.closest('.dtp-spinner-btn');
                if (!btn) return;

                const field = btn.dataset.field;
                const dir = btn.dataset.dir;
                const delta = dir === 'up' ? 1 : -1;
                this.adjustTime(field, delta);
            }

            startSpinnerPress(e) {
                const btn = e.target.closest('.dtp-spinner-btn');
                if (!btn) return;

                const field = btn.dataset.field;
                const dir = btn.dataset.dir;
                const delta = dir === 'up' ? 1 : -1;

                let rate = 150;
                this.pressTimer = setTimeout(() => {
                    this.pressInterval = setInterval(() => {
                        this.adjustTime(field, delta);
                        rate = Math.max(30, rate * 0.9);
                    }, rate);
                }, 400);
            }

            stopSpinnerPress() {
                clearTimeout(this.pressTimer);
                clearInterval(this.pressInterval);
                this.pressTimer = null;
                this.pressInterval = null;
            }

            handleTimeInput(e, field) {
                let value = e.target.value.replace(/\D/g, '');
                const max = field === 'hours' ? 23 : 59;

                if (value.length > 0) {
                    let num = parseInt(value, 10);
                    if (num > max) num = max;
                    this[field] = num;
                }
            }

            formatTimeInput(field) {
                const input = field === 'hours' ? this.hoursInput : this.minutesInput;
                input.value = String(this[field]).padStart(2, '0');
            }

            handleTimeWheel(e, field) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -1 : 1;
                this.adjustTime(field, delta);
            }

            adjustTime(field, delta) {
                if (field === 'hours') {
                    this.hours = (this.hours + delta + 24) % 24;
                    this.hoursInput.value = String(this.hours).padStart(2, '0');
                } else {
                    this.minutes = (this.minutes + delta + 60) % 60;
                    this.minutesInput.value = String(this.minutes).padStart(2, '0');
                }
            }

            selectFocusedDate() {
                this.selectedDate = new Date(this.focusedDate);
                this.render();
            }

            // Month/Year picker methods
            showMonthPicker() {
                this.renderMonthPicker();
                this.monthOverlay.classList.add('open');
                this.monthPickerOpen = true;
                this.hideYearPicker();
            }

            hideMonthPicker() {
                this.monthOverlay.classList.remove('open');
                this.monthPickerOpen = false;
            }

            showYearPicker() {
                this.yearRangeStart = this.viewDate.getFullYear() - 5;
                this.renderYearPicker();
                this.yearOverlay.classList.add('open');
                this.yearPickerOpen = true;
                this.hideMonthPicker();
            }

            hideYearPicker() {
                this.yearOverlay.classList.remove('open');
                this.yearPickerOpen = false;
            }

            handleMonthSelect(e) {
                const cell = e.target.closest('.dtp-overlay-cell');
                if (!cell) return;

                const month = parseInt(cell.dataset.month, 10);
                this.viewDate.setMonth(month);
                this.focusedDate = new Date(this.viewDate);
                this.hideMonthPicker();
                this.render();
            }

            handleYearSelect(e) {
                const cell = e.target.closest('.dtp-overlay-cell');
                if (!cell) return;

                const year = parseInt(cell.dataset.year, 10);
                this.viewDate.setFullYear(year);
                this.focusedDate = new Date(this.viewDate);
                this.hideYearPicker();
                this.render();
            }

            handleMonthPickerWheel(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 1 : -1;
                let newMonth = this.viewDate.getMonth() + delta;

                if (newMonth > 11) {
                    newMonth = 0;
                    this.viewDate.setFullYear(this.viewDate.getFullYear() + 1);
                } else if (newMonth < 0) {
                    newMonth = 11;
                    this.viewDate.setFullYear(this.viewDate.getFullYear() - 1);
                }

                this.viewDate.setMonth(newMonth);
                this.renderMonthPicker();
                this.renderMonthYearHeader();
            }

            handleYearPickerWheel(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 4 : -4;
                this.yearRangeStart += delta;
                this.renderYearPicker();
            }

            // Utility methods
            dateToKey(date) {
                return `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
            }

            formatDate(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            formatDateTime(date) {
                const dateStr = this.formatDate(date);
                if (this.options.dateOnly) {
                    return dateStr;
                }
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${dateStr} ${hours}:${minutes}`;
            }

            updateDisplayInput() {
                if (this.selectedDate) {
                    this.displayInput.value = this.formatDateTime(this.selectedDate);
                } else {
                    this.displayInput.value = '';
                }
            }

            updateHiddenInput() {
                if (this.selectedDate) {
                    const year = this.selectedDate.getFullYear();
                    const month = String(this.selectedDate.getMonth() + 1).padStart(2, '0');
                    const day = String(this.selectedDate.getDate()).padStart(2, '0');

                    if (this.options.dateOnly) {
                        // Format for date input: YYYY-MM-DD
                        this.input.value = `${year}-${month}-${day}`;
                    } else {
                        // Format for datetime-local input: YYYY-MM-DDTHH:MM
                        const hours = String(this.selectedDate.getHours()).padStart(2, '0');
                        const minutes = String(this.selectedDate.getMinutes()).padStart(2, '0');
                        this.input.value = `${year}-${month}-${day}T${hours}:${minutes}`;
                    }
                } else {
                    this.input.value = '';
                }
            }

            // Public API
            getValue() {
                return this.selectedDate;
            }

            setValue(date) {
                if (typeof date === 'string') {
                    date = new Date(date);
                }
                if (date && !isNaN(date.getTime())) {
                    this.selectedDate = date;
                    this.viewDate = new Date(date);
                    this.focusedDate = new Date(date);
                    this.hours = date.getHours();
                    this.minutes = date.getMinutes();
                    this.updateDisplayInput();
                    this.updateHiddenInput();
                }
            }

            clear() {
                this.selectedDate = null;
                this.hours = this.options.defaultHour;
                this.minutes = this.options.defaultMinute;
                this.updateDisplayInput();
                this.input.value = '';
            }

            destroy() {
                // Move input back out of wrapper
                this.wrapper.parentNode.insertBefore(this.input, this.wrapper);
                this.input.style.display = '';
                // Remove wrapper and picker
                this.wrapper.remove();
            }
        }

        // Auto-initialize date pickers
        function initDateTimePickers() {
            document.querySelectorAll('[data-datetimepicker]').forEach(input => {
                if (!input._dtpInstance) {
                    input._dtpInstance = new DateTimePicker(input);
                }
            });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize inline forms with disabled tab navigation (they start closed)
            // Right panel is hidden by default (horizontal expansion)
            setFormTabIndex(todoFormRight, false);
            setFormTabIndex(inlineEngPersonForm, false);
            if (inlinePersonForm) setFormTabIndex(inlinePersonForm, false);

            // Initialize DateTimePickers
            initDateTimePickers();

            // Collapse status tooltips when mouse leaves container
            document.addEventListener('mouseleave', (e) => {
                if (e.target && e.target.closest) {
                    const container = e.target.closest('.status-tooltip-container');
                    if (container) {
                        const tooltip = container.querySelector('.status-tooltip');
                        if (tooltip && !tooltip.classList.contains('expanded')) {
                            tooltip.classList.remove('expanded');
                        }
                    }
                }
            }, true);

            // Collapse expanded status tooltips when clicking outside
            document.addEventListener('click', (e) => {
                if (e.target && e.target.closest) {
                    // If click is not inside a status tooltip, collapse all expanded tooltips
                    if (!e.target.closest('.status-tooltip')) {
                        collapseAllStatusTooltips();
                    }
                    // Issue-57: Collapse expanded engagement when clicking outside
                    if (state.expandedEngagementId && !e.target.closest('.engagement-item')) {
                        collapseEngagementExpansion();
                    }
                }
            });

            // Initialize app with IndexedDB (handles migration and navigation)
            initializeApp();
        });
    </script>
</body>
</html>
